
FreeRTOSatmega328p.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  00002574  00002608  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002574  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000074c  00800126  00800126  0000262e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000262e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000500  00000000  00000000  0000265e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00006325  00000000  00000000  00002b5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000019b1  00000000  00000000  00008e83  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002624  00000000  00000000  0000a834  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000ef8  00000000  00000000  0000ce58  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017d8  00000000  00000000  0000dd50  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00005613  00000000  00000000  0000f528  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000460  00000000  00000000  00014b3b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
       0:	0c 94 be 01 	jmp	0x37c	; 0x37c <__ctors_end>
       4:	0c 94 4d 09 	jmp	0x129a	; 0x129a <__vector_1>
       8:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
       c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      10:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      14:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      18:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
      1c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
      20:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      24:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
      28:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
      2c:	0c 94 5c 0b 	jmp	0x16b8	; 0x16b8 <__vector_11>
      30:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      34:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      38:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
      3c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      40:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      44:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      48:	0c 94 c1 06 	jmp	0xd82	; 0xd82 <__vector_18>
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );

		if( xWaitConditionMet != pdFALSE )
      4c:	0c 94 f1 06 	jmp	0xde2	; 0xde2 <__vector_19>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
      50:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
      54:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      58:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      5c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      60:	0c 94 a2 07 	jmp	0xf44	; 0xf44 <__vector_24>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
      64:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      68:	bc 07       	cpc	r27, r28
      6a:	1d 08       	sbc	r1, r13
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
      6c:	1d 08       	sbc	r1, r13
      6e:	1d 08       	sbc	r1, r13
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
      70:	1d 08       	sbc	r1, r13
      72:	1d 08       	sbc	r1, r13
      74:	1d 08       	sbc	r1, r13
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
      76:	1d 08       	sbc	r1, r13
      78:	bc 07       	cpc	r27, r28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
      7a:	1d 08       	sbc	r1, r13
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
      7c:	1d 08       	sbc	r1, r13
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
      7e:	1d 08       	sbc	r1, r13
      80:	1d 08       	sbc	r1, r13
      82:	1d 08       	sbc	r1, r13
      84:	1d 08       	sbc	r1, r13
      86:	1d 08       	sbc	r1, r13
      88:	be 07       	cpc	r27, r30
      8a:	1d 08       	sbc	r1, r13
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
      8c:	1d 08       	sbc	r1, r13
      8e:	1d 08       	sbc	r1, r13

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
      90:	1d 08       	sbc	r1, r13
      92:	1d 08       	sbc	r1, r13
		{
			portYIELD_WITHIN_API();
      94:	1d 08       	sbc	r1, r13
      96:	1d 08       	sbc	r1, r13

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
      98:	1d 08       	sbc	r1, r13
      9a:	1d 08       	sbc	r1, r13

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
      9c:	1d 08       	sbc	r1, r13
      9e:	1d 08       	sbc	r1, r13
		{
			taskENTER_CRITICAL();
      a0:	1d 08       	sbc	r1, r13
      a2:	1d 08       	sbc	r1, r13
      a4:	1d 08       	sbc	r1, r13
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
      a6:	1d 08       	sbc	r1, r13
      a8:	be 07       	cpc	r27, r30
      aa:	1d 08       	sbc	r1, r13

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
      ac:	1d 08       	sbc	r1, r13
      ae:	1d 08       	sbc	r1, r13
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
      b0:	1d 08       	sbc	r1, r13
      b2:	1d 08       	sbc	r1, r13
      b4:	1d 08       	sbc	r1, r13
      b6:	1d 08       	sbc	r1, r13
      b8:	1d 08       	sbc	r1, r13
      ba:	1d 08       	sbc	r1, r13
      bc:	1d 08       	sbc	r1, r13
      be:	1d 08       	sbc	r1, r13
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
      c0:	1d 08       	sbc	r1, r13
      c2:	1d 08       	sbc	r1, r13
      c4:	1d 08       	sbc	r1, r13
      c6:	1d 08       	sbc	r1, r13
      c8:	16 08       	sbc	r1, r6
      ca:	1d 08       	sbc	r1, r13
      cc:	1d 08       	sbc	r1, r13
      ce:	1d 08       	sbc	r1, r13
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
      d0:	1d 08       	sbc	r1, r13
      d2:	1d 08       	sbc	r1, r13
				{
					if( xClearOnExit != pdFALSE )
      d4:	1d 08       	sbc	r1, r13
      d6:	1d 08       	sbc	r1, r13
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
      d8:	eb 07       	cpc	r30, r27
      da:	1d 08       	sbc	r1, r13
      dc:	1d 08       	sbc	r1, r13
      de:	1d 08       	sbc	r1, r13
      e0:	1d 08       	sbc	r1, r13
      e2:	1d 08       	sbc	r1, r13
      e4:	1d 08       	sbc	r1, r13
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
      e6:	1d 08       	sbc	r1, r13
      e8:	1d 08       	sbc	r1, r13
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
      ea:	1d 08       	sbc	r1, r13
      ec:	1d 08       	sbc	r1, r13
      ee:	1d 08       	sbc	r1, r13
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
      f0:	1d 08       	sbc	r1, r13
      f2:	1d 08       	sbc	r1, r13
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
      f4:	1d 08       	sbc	r1, r13
      f6:	1d 08       	sbc	r1, r13
      f8:	df 07       	cpc	r29, r31
      fa:	1d 08       	sbc	r1, r13
      fc:	1d 08       	sbc	r1, r13
      fe:	1d 08       	sbc	r1, r13
     100:	1d 08       	sbc	r1, r13
     102:	1d 08       	sbc	r1, r13
     104:	1d 08       	sbc	r1, r13
     106:	1d 08       	sbc	r1, r13
     108:	03 08       	sbc	r0, r3

0000010a <__trampolines_end>:
     10a:	05 00       	.word	0x0005	; ????
     10c:	05 00       	.word	0x0005	; ????

0000010e <setServiceACK>:
     10e:	01 02 00 00 08 01                                   ......

00000114 <setService>:
     114:	01 0a 05 08 02 01 00 f9 81 00 00 01 2c              ............,

00000121 <serviceACK>:
     121:	0e 00 05 00                                         ....

00000125 <svcIndication>:
     125:	0e 0c 04 00 00 80 01 03 02 f9 81 00 00 03 e8        ...............

00000134 <operationalEvent>:
     134:	0f 09 02 00 00 00 24 05 00 00 00 00                 ......$.....

00000140 <alarmEvent>:
     140:	0f 09 04 00 00 00 02 04 00 00 00 00                 ............

0000014c <negotiatingEvent>:
     14c:	0f 09 04 00 00 01 00 03 00 00 00 08                 ............

00000158 <moteSearchingEvent>:
     158:	0f 09 04 00 00 00 02 02 00 00 00 08                 ............

00000164 <joinACK>:
     164:	06 00 05 00                                         ....

00000168 <joinCommand>:
     168:	06 00 04                                            ...

0000016b <eventACK>:
     16b:	0f 00 05 00                                         ....

0000016f <bootEvent>:
     16f:	0f 09 08 00 00 00 01 01 00 00 00 00                 ............

0000017b <fcstab>:
     17b:	00 00 89 11 12 23 9b 32 24 46 ad 57 36 65 bf 74     .....#.2$F.W6e.t
     18b:	48 8c c1 9d 5a af d3 be 6c ca e5 db 7e e9 f7 f8     H...Z...l...~...
     19b:	81 10 08 01 93 33 1a 22 a5 56 2c 47 b7 75 3e 64     .....3.".V,G.u>d
     1ab:	c9 9c 40 8d db bf 52 ae ed da 64 cb ff f9 76 e8     ..@...R...d...v.
     1bb:	02 21 8b 30 10 02 99 13 26 67 af 76 34 44 bd 55     .!.0....&g.v4D.U
     1cb:	4a ad c3 bc 58 8e d1 9f 6e eb e7 fa 7c c8 f5 d9     J...X...n...|...
     1db:	83 31 0a 20 91 12 18 03 a7 77 2e 66 b5 54 3c 45     .1. .....w.f.T<E
     1eb:	cb bd 42 ac d9 9e 50 8f ef fb 66 ea fd d8 74 c9     ..B...P...f...t.
     1fb:	04 42 8d 53 16 61 9f 70 20 04 a9 15 32 27 bb 36     .B.S.a.p ...2'.6
     20b:	4c ce c5 df 5e ed d7 fc 68 88 e1 99 7a ab f3 ba     L...^...h...z...
     21b:	85 52 0c 43 97 71 1e 60 a1 14 28 05 b3 37 3a 26     .R.C.q.`..(..7:&
     22b:	cd de 44 cf df fd 56 ec e9 98 60 89 fb bb 72 aa     ..D...V...`...r.
     23b:	06 63 8f 72 14 40 9d 51 22 25 ab 34 30 06 b9 17     .c.r.@.Q"%.40...
     24b:	4e ef c7 fe 5c cc d5 dd 6a a9 e3 b8 78 8a f1 9b     N...\...j...x...
     25b:	87 73 0e 62 95 50 1c 41 a3 35 2a 24 b1 16 38 07     .s.b.P.A.5*$..8.
     26b:	cf ff 46 ee dd dc 54 cd eb b9 62 a8 f9 9a 70 8b     ..F...T...b...p.
     27b:	08 84 81 95 1a a7 93 b6 2c c2 a5 d3 3e e1 b7 f0     ........,...>...
     28b:	40 08 c9 19 52 2b db 3a 64 4e ed 5f 76 6d ff 7c     @...R+.:dN._vm.|
     29b:	89 94 00 85 9b b7 12 a6 ad d2 24 c3 bf f1 36 e0     ..........$...6.
     2ab:	c1 18 48 09 d3 3b 5a 2a e5 5e 6c 4f f7 7d 7e 6c     ..H..;Z*.^lO.}~l
     2bb:	0a a5 83 b4 18 86 91 97 2e e3 a7 f2 3c c0 b5 d1     ............<...
     2cb:	42 29 cb 38 50 0a d9 1b 66 6f ef 7e 74 4c fd 5d     B).8P...fo.~tL.]
     2db:	8b b5 02 a4 99 96 10 87 af f3 26 e2 bd d0 34 c1     ..........&...4.
     2eb:	c3 39 4a 28 d1 1a 58 0b e7 7f 6e 6e f5 5c 7c 4d     .9J(..X...nn.\|M
     2fb:	0c c6 85 d7 1e e5 97 f4 28 80 a1 91 3a a3 b3 b2     ........(...:...
     30b:	44 4a cd 5b 56 69 df 78 60 0c e9 1d 72 2f fb 3e     DJ.[Vi.x`...r/.>
     31b:	8d d6 04 c7 9f f5 16 e4 a9 90 20 81 bb b3 32 a2     .......... ...2.
     32b:	c5 5a 4c 4b d7 79 5e 68 e1 1c 68 0d f3 3f 7a 2e     .ZLK.y^h..h..?z.
     33b:	0e e7 87 f6 1c c4 95 d5 2a a1 a3 b0 38 82 b1 93     ........*...8...
     34b:	46 6b cf 7a 54 48 dd 59 62 2d eb 3c 70 0e f9 1f     Fk.zTH.Yb-.<p...
     35b:	8f f7 06 e6 9d d4 14 c5 ab b1 22 a0 b9 92 30 83     .........."...0.
     36b:	c7 7b 4e 6a d5 58 5c 49 e3 3d 6a 2c f1 1e 78 0f     .{Nj.X\I.=j,..x.
	...

0000037c <__ctors_end>:
     37c:	11 24       	eor	r1, r1
     37e:	1f be       	out	0x3f, r1	; 63
     380:	cf ef       	ldi	r28, 0xFF	; 255
     382:	d8 e0       	ldi	r29, 0x08	; 8
     384:	de bf       	out	0x3e, r29	; 62
     386:	cd bf       	out	0x3d, r28	; 61

00000388 <__do_copy_data>:
     388:	11 e0       	ldi	r17, 0x01	; 1
     38a:	a0 e0       	ldi	r26, 0x00	; 0
     38c:	b1 e0       	ldi	r27, 0x01	; 1
     38e:	e4 e7       	ldi	r30, 0x74	; 116
     390:	f5 e2       	ldi	r31, 0x25	; 37
     392:	02 c0       	rjmp	.+4      	; 0x398 <__do_copy_data+0x10>
     394:	05 90       	lpm	r0, Z+
     396:	0d 92       	st	X+, r0
     398:	a6 32       	cpi	r26, 0x26	; 38
     39a:	b1 07       	cpc	r27, r17
     39c:	d9 f7       	brne	.-10     	; 0x394 <__do_copy_data+0xc>

0000039e <__do_clear_bss>:
     39e:	28 e0       	ldi	r18, 0x08	; 8
     3a0:	a6 e2       	ldi	r26, 0x26	; 38
     3a2:	b1 e0       	ldi	r27, 0x01	; 1
     3a4:	01 c0       	rjmp	.+2      	; 0x3a8 <.do_clear_bss_start>

000003a6 <.do_clear_bss_loop>:
     3a6:	1d 92       	st	X+, r1

000003a8 <.do_clear_bss_start>:
     3a8:	a2 37       	cpi	r26, 0x72	; 114
     3aa:	b2 07       	cpc	r27, r18
     3ac:	e1 f7       	brne	.-8      	; 0x3a6 <.do_clear_bss_loop>
     3ae:	0e 94 33 08 	call	0x1066	; 0x1066 <main>
     3b2:	0c 94 b8 12 	jmp	0x2570	; 0x2570 <_exit>

000003b6 <__bad_interrupt>:
     3b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003ba <xMoteTask>:
	moteReadySemaphore = xSemaphoreCreateBinary();
	xTaskCreate( xMoteTask,( signed char * ) "Mote", comSTACK_SIZE, NULL, uxPriority, NULL );
		
}

void xMoteTask( void* pvParameters){
     3ba:	cf 93       	push	r28
     3bc:	df 93       	push	r29
     3be:	00 d0       	rcall	.+0      	; 0x3c0 <xMoteTask+0x6>
     3c0:	cd b7       	in	r28, 0x3d	; 61
     3c2:	de b7       	in	r29, 0x3e	; 62
	
	
	configureMote();
     3c4:	0e 94 38 07 	call	0xe70	; 0xe70 <configureMote>
	xSemaphoreGive(moteReadySemaphore);
     3c8:	20 e0       	ldi	r18, 0x00	; 0
     3ca:	40 e0       	ldi	r20, 0x00	; 0
     3cc:	50 e0       	ldi	r21, 0x00	; 0
     3ce:	60 e0       	ldi	r22, 0x00	; 0
     3d0:	70 e0       	ldi	r23, 0x00	; 0
     3d2:	80 91 cc 07 	lds	r24, 0x07CC
     3d6:	90 91 cd 07 	lds	r25, 0x07CD
     3da:	0e 94 b1 0c 	call	0x1962	; 0x1962 <xQueueGenericSend>
	for ( ;; )
	{
		//sendMoteData(datos2,sizeof(datos2));
		//vTaskDelayUntil(&xLastWakeTime2,xFrequency2);
		
		if ( xQueueReceive(DataToSend,&(datos),DATA_READY_TO_SEND_BLOCK_TIME)  ) //Block on the DataToSendQueue
     3de:	20 e0       	ldi	r18, 0x00	; 0
     3e0:	4f ef       	ldi	r20, 0xFF	; 255
     3e2:	5f ef       	ldi	r21, 0xFF	; 255
     3e4:	be 01       	movw	r22, r28
     3e6:	6f 5f       	subi	r22, 0xFF	; 255
     3e8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ea:	80 91 70 08 	lds	r24, 0x0870
     3ee:	90 91 71 08 	lds	r25, 0x0871
     3f2:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     3f6:	88 23       	and	r24, r24
     3f8:	91 f3       	breq	.-28     	; 0x3de <xMoteTask+0x24>
		{
			//The queue is of size 1 and contains the pointer to the data to be sent
			sendMoteData(datos,NUMBER_OF_BYTES_TO_SEND);
     3fa:	60 e3       	ldi	r22, 0x30	; 48
     3fc:	89 81       	ldd	r24, Y+1	; 0x01
     3fe:	9a 81       	ldd	r25, Y+2	; 0x02
     400:	0e 94 32 07 	call	0xe64	; 0xe64 <sendMoteData>
     404:	ec cf       	rjmp	.-40     	; 0x3de <xMoteTask+0x24>

00000406 <startCommTasks>:
static xComPortHandle xPort = NULL;

extern QueueHandle_t DataToSend;
SemaphoreHandle_t moteReadySemaphore; // sync for sensor task

void startCommTasks(UBaseType_t uxPriority){
     406:	af 92       	push	r10
     408:	bf 92       	push	r11
     40a:	cf 92       	push	r12
     40c:	df 92       	push	r13
     40e:	ef 92       	push	r14
     410:	ff 92       	push	r15
     412:	0f 93       	push	r16
     414:	08 2f       	mov	r16, r24
	xSerialPortInitMinimal(BUFFER_LENGTH);
     416:	80 e8       	ldi	r24, 0x80	; 128
     418:	0e 94 77 06 	call	0xcee	; 0xcee <xSerialPortInitMinimal>
	/* The Tx task is spawned with a lower priority than the Rx task. */
	moteReadySemaphore = xSemaphoreCreateBinary();
     41c:	43 e0       	ldi	r20, 0x03	; 3
     41e:	60 e0       	ldi	r22, 0x00	; 0
     420:	81 e0       	ldi	r24, 0x01	; 1
     422:	0e 94 83 0c 	call	0x1906	; 0x1906 <xQueueGenericCreate>
     426:	90 93 cd 07 	sts	0x07CD, r25
     42a:	80 93 cc 07 	sts	0x07CC, r24
	xTaskCreate( xMoteTask,( signed char * ) "Mote", comSTACK_SIZE, NULL, uxPriority, NULL );
     42e:	a1 2c       	mov	r10, r1
     430:	b1 2c       	mov	r11, r1
     432:	c1 2c       	mov	r12, r1
     434:	d1 2c       	mov	r13, r1
     436:	e1 2c       	mov	r14, r1
     438:	f1 2c       	mov	r15, r1
     43a:	20 e0       	ldi	r18, 0x00	; 0
     43c:	30 e0       	ldi	r19, 0x00	; 0
     43e:	40 e0       	ldi	r20, 0x00	; 0
     440:	51 e0       	ldi	r21, 0x01	; 1
     442:	61 e0       	ldi	r22, 0x01	; 1
     444:	71 e0       	ldi	r23, 0x01	; 1
     446:	8d ed       	ldi	r24, 0xDD	; 221
     448:	91 e0       	ldi	r25, 0x01	; 1
     44a:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskGenericCreate>
		
}
     44e:	0f 91       	pop	r16
     450:	ff 90       	pop	r15
     452:	ef 90       	pop	r14
     454:	df 90       	pop	r13
     456:	cf 90       	pop	r12
     458:	bf 90       	pop	r11
     45a:	af 90       	pop	r10
     45c:	08 95       	ret

0000045e <InterruptReception>:

extern SemaphoreHandle_t frameHandle;



uint8_t InterruptReception (MoteData_p moteData) {
     45e:	0f 93       	push	r16
     460:	1f 93       	push	r17
     462:	cf 93       	push	r28
     464:	df 93       	push	r29
     466:	ec 01       	movw	r28, r24
//Place this function inside your Serial Receipt Interrupt
//Dont read the byte, the function serialMoteReceive will do it

moteData->RXbuffer[moteData->RXindex]=moteData->serialMoteReceive();
     468:	0c 81       	ldd	r16, Y+4	; 0x04
     46a:	10 e0       	ldi	r17, 0x00	; 0
     46c:	ea 81       	ldd	r30, Y+2	; 0x02
     46e:	fb 81       	ldd	r31, Y+3	; 0x03
     470:	09 95       	icall
     472:	fe 01       	movw	r30, r28
     474:	e0 0f       	add	r30, r16
     476:	f1 1f       	adc	r31, r17
     478:	85 83       	std	Z+5, r24	; 0x05
//moteData->RXbuffer[moteData->RXindex]=rxedChar;
	moteData->RXindex++;
     47a:	8c 81       	ldd	r24, Y+4	; 0x04
     47c:	8f 5f       	subi	r24, 0xFF	; 255
     47e:	8c 83       	std	Y+4, r24	; 0x04
	//sei();
	
	//serialPCtx(moteData->RXbuffer[moteData->RXindex-1]);
	
	
	if ((moteData->RXbuffer[moteData->RXindex-1] == 0x7E) && ((moteData->RXindex-1) > 0) )
     480:	ec 81       	ldd	r30, Y+4	; 0x04
     482:	f0 e0       	ldi	r31, 0x00	; 0
     484:	31 97       	sbiw	r30, 0x01	; 1
     486:	ec 0f       	add	r30, r28
     488:	fd 1f       	adc	r31, r29
     48a:	85 81       	ldd	r24, Z+5	; 0x05
     48c:	8e 37       	cpi	r24, 0x7E	; 126
     48e:	f9 f4       	brne	.+62     	; 0x4ce <InterruptReception+0x70>
     490:	8c 81       	ldd	r24, Y+4	; 0x04
     492:	90 e0       	ldi	r25, 0x00	; 0
     494:	01 97       	sbiw	r24, 0x01	; 1
     496:	18 16       	cp	r1, r24
     498:	19 06       	cpc	r1, r25
     49a:	cc f4       	brge	.+50     	; 0x4ce <InterruptReception+0x70>
	{
		//serialPCtxArray(moteData->RXbuffer,moteData->RXindex);
	
		//moteData->RXindex++;
		//serialPCtxArray(moteData->RXbuffer,moteData->RXindex);
	 moteData->decodeResult = hdlc_decode(moteData->hdlcDecoded, moteData->RXbuffer,&moteData->RXindex, sizeof(moteData->hdlcDecoded));
     49c:	20 e2       	ldi	r18, 0x20	; 32
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	ae 01       	movw	r20, r28
     4a2:	4c 5f       	subi	r20, 0xFC	; 252
     4a4:	5f 4f       	sbci	r21, 0xFF	; 255
     4a6:	be 01       	movw	r22, r28
     4a8:	6b 5f       	subi	r22, 0xFB	; 251
     4aa:	7f 4f       	sbci	r23, 0xFF	; 255
     4ac:	ce 01       	movw	r24, r28
     4ae:	8e 58       	subi	r24, 0x8E	; 142
     4b0:	9f 4f       	sbci	r25, 0xFF	; 255
     4b2:	0e 94 1f 05 	call	0xa3e	; 0xa3e <hdlc_decode>
     4b6:	9e 8f       	std	Y+30, r25	; 0x1e
     4b8:	8d 8f       	std	Y+29, r24	; 0x1d
		if (moteData->decodeResult>0)
     4ba:	8d 8d       	ldd	r24, Y+29	; 0x1d
     4bc:	9e 8d       	ldd	r25, Y+30	; 0x1e
     4be:	18 16       	cp	r1, r24
     4c0:	19 06       	cpc	r1, r25
     4c2:	14 f4       	brge	.+4      	; 0x4c8 <InterruptReception+0x6a>
		{
			moteData->validFrame=1;
     4c4:	81 e0       	ldi	r24, 0x01	; 1
     4c6:	8f 8f       	std	Y+31, r24	; 0x1f
			//serialPCtxArray(moteData->hdlcDecoded,moteData->decodeResult);
		}
		moteData->RXindex=0;
     4c8:	1c 82       	std	Y+4, r1	; 0x04
		return moteData->validFrame;
     4ca:	8f 8d       	ldd	r24, Y+31	; 0x1f
     4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <InterruptReception+0x74>
	}else{
		moteData->validFrame=0;
     4ce:	1f 8e       	std	Y+31, r1	; 0x1f
		return moteData->validFrame;}//moteData->RXindex++;}
     4d0:	8f 8d       	ldd	r24, Y+31	; 0x1f


}
     4d2:	df 91       	pop	r29
     4d4:	cf 91       	pop	r28
     4d6:	1f 91       	pop	r17
     4d8:	0f 91       	pop	r16
     4da:	08 95       	ret

000004dc <serialMoteSendArray>:
	}
}



void serialMoteSendArray(uint8_t* datos, uint8_t tam, MoteData_p moteData){
     4dc:	ef 92       	push	r14
     4de:	ff 92       	push	r15
     4e0:	0f 93       	push	r16
     4e2:	1f 93       	push	r17
     4e4:	cf 93       	push	r28
     4e6:	df 93       	push	r29
     4e8:	e6 2e       	mov	r14, r22
     4ea:	8a 01       	movw	r16, r20
	//send many bytes
	for (uint8_t i=0;i<tam;i++)
     4ec:	66 23       	and	r22, r22
     4ee:	59 f0       	breq	.+22     	; 0x506 <serialMoteSendArray+0x2a>
     4f0:	c8 2f       	mov	r28, r24
     4f2:	d9 2f       	mov	r29, r25
     4f4:	f1 2c       	mov	r15, r1
	{
		//serialMoteSend(datos[i]);
		moteData->serialMoteSend(datos[i]);
     4f6:	d8 01       	movw	r26, r16
     4f8:	ed 91       	ld	r30, X+
     4fa:	fc 91       	ld	r31, X
     4fc:	89 91       	ld	r24, Y+
     4fe:	09 95       	icall



void serialMoteSendArray(uint8_t* datos, uint8_t tam, MoteData_p moteData){
	//send many bytes
	for (uint8_t i=0;i<tam;i++)
     500:	f3 94       	inc	r15
     502:	fe 10       	cpse	r15, r14
     504:	f8 cf       	rjmp	.-16     	; 0x4f6 <serialMoteSendArray+0x1a>
	{
		//serialMoteSend(datos[i]);
		moteData->serialMoteSend(datos[i]);
	}
	
}
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	1f 91       	pop	r17
     50c:	0f 91       	pop	r16
     50e:	ff 90       	pop	r15
     510:	ef 90       	pop	r14
     512:	08 95       	ret

00000514 <compareBuffer>:
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     514:	44 23       	and	r20, r20
     516:	89 f0       	breq	.+34     	; 0x53a <compareBuffer+0x26>
     518:	28 2f       	mov	r18, r24
     51a:	e6 2f       	mov	r30, r22
     51c:	f7 2f       	mov	r31, r23
     51e:	a8 2f       	mov	r26, r24
     520:	b9 2f       	mov	r27, r25
	
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     522:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i=0;i<tam;i++)
	{
		//if (datos[i]==datos2[i])
		if (datos[i]==pgm_read_byte(&(datos2[i])))
     524:	8d 91       	ld	r24, X+
     526:	94 91       	lpm	r25, Z
     528:	89 13       	cpse	r24, r25
     52a:	01 c0       	rjmp	.+2      	; 0x52e <compareBuffer+0x1a>
		{
			comparacion++;
     52c:	3f 5f       	subi	r19, 0xFF	; 255
     52e:	31 96       	adiw	r30, 0x01	; 1
     530:	8a 2f       	mov	r24, r26
     532:	82 1b       	sub	r24, r18
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     534:	84 17       	cp	r24, r20
     536:	b0 f3       	brcs	.-20     	; 0x524 <compareBuffer+0x10>
     538:	01 c0       	rjmp	.+2      	; 0x53c <compareBuffer+0x28>
	
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     53a:	30 e0       	ldi	r19, 0x00	; 0
		{
			comparacion++;
		}
	}
	
	if (comparacion>=tam)
     53c:	81 e0       	ldi	r24, 0x01	; 1
     53e:	34 17       	cp	r19, r20
     540:	08 f4       	brcc	.+2      	; 0x544 <compareBuffer+0x30>
     542:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}else return 0;
	
	
	
}
     544:	08 95       	ret

00000546 <MoteInitialization>:
}




void MoteInitialization( MoteData_p moteData){
     546:	ef 92       	push	r14
     548:	ff 92       	push	r15
     54a:	0f 93       	push	r16
     54c:	1f 93       	push	r17
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
     552:	ec 01       	movw	r28, r24

while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     554:	20 e0       	ldi	r18, 0x00	; 0
     556:	4f ef       	ldi	r20, 0xFF	; 255
     558:	5f ef       	ldi	r21, 0xFF	; 255
     55a:	60 e0       	ldi	r22, 0x00	; 0
     55c:	70 e0       	ldi	r23, 0x00	; 0
     55e:	80 91 ce 07 	lds	r24, 0x07CE
     562:	90 91 cf 07 	lds	r25, 0x07CF
     566:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     56a:	81 30       	cpi	r24, 0x01	; 1
     56c:	99 f7       	brne	.-26     	; 0x554 <MoteInitialization+0xe>
	moteData->validFrame=0;
     56e:	1f 8e       	std	Y+31, r1	; 0x1f
	moteData->hdlcDecoded[2]=0x08;
     570:	88 e0       	ldi	r24, 0x08	; 8
     572:	fe 01       	movw	r30, r28
     574:	ec 58       	subi	r30, 0x8C	; 140
     576:	ff 4f       	sbci	r31, 0xFF	; 255
     578:	80 83       	st	Z, r24
	if (compareBuffer(moteData->hdlcDecoded,bootEvent,moteData->decodeResult))
     57a:	4d 8d       	ldd	r20, Y+29	; 0x1d
     57c:	5e 8d       	ldd	r21, Y+30	; 0x1e
     57e:	8e 01       	movw	r16, r28
     580:	0e 58       	subi	r16, 0x8E	; 142
     582:	1f 4f       	sbci	r17, 0xFF	; 255
     584:	6f e6       	ldi	r22, 0x6F	; 111
     586:	71 e0       	ldi	r23, 0x01	; 1
     588:	c8 01       	movw	r24, r16
     58a:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     58e:	88 23       	and	r24, r24
     590:	b1 f0       	breq	.+44     	; 0x5be <MoteInitialization+0x78>
	{
		//serialPCtx(0x00);
		
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     592:	22 e5       	ldi	r18, 0x52	; 82
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	44 e0       	ldi	r20, 0x04	; 4
     598:	50 e0       	ldi	r21, 0x00	; 0
     59a:	6b e6       	ldi	r22, 0x6B	; 107
     59c:	71 e0       	ldi	r23, 0x01	; 1
     59e:	7e 01       	movw	r14, r28
     5a0:	80 e2       	ldi	r24, 0x20	; 32
     5a2:	e8 0e       	add	r14, r24
     5a4:	f1 1c       	adc	r15, r1
     5a6:	c7 01       	movw	r24, r14
     5a8:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     5ac:	fe 01       	movw	r30, r28
     5ae:	ee 56       	subi	r30, 0x6E	; 110
     5b0:	ff 4f       	sbci	r31, 0xFF	; 255
     5b2:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     5b4:	ae 01       	movw	r20, r28
     5b6:	68 2f       	mov	r22, r24
     5b8:	c7 01       	movw	r24, r14
     5ba:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtxArray(moteData->hdlcOutput,moteData->sizeToSend);
	
	}
	//_delay_ms(100);
	moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,joinCommand,sizeof(joinCommand),sizeof(moteData->hdlcOutput));
     5be:	7e 01       	movw	r14, r28
     5c0:	80 e2       	ldi	r24, 0x20	; 32
     5c2:	e8 0e       	add	r14, r24
     5c4:	f1 1c       	adc	r15, r1
     5c6:	22 e5       	ldi	r18, 0x52	; 82
     5c8:	30 e0       	ldi	r19, 0x00	; 0
     5ca:	43 e0       	ldi	r20, 0x03	; 3
     5cc:	50 e0       	ldi	r21, 0x00	; 0
     5ce:	68 e6       	ldi	r22, 0x68	; 104
     5d0:	71 e0       	ldi	r23, 0x01	; 1
     5d2:	c7 01       	movw	r24, r14
     5d4:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     5d8:	fe 01       	movw	r30, r28
     5da:	ee 56       	subi	r30, 0x6E	; 110
     5dc:	ff 4f       	sbci	r31, 0xFF	; 255
     5de:	80 83       	st	Z, r24
	serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     5e0:	ae 01       	movw	r20, r28
     5e2:	68 2f       	mov	r22, r24
     5e4:	c7 01       	movw	r24, r14
     5e6:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     5ea:	20 e0       	ldi	r18, 0x00	; 0
     5ec:	4f ef       	ldi	r20, 0xFF	; 255
     5ee:	5f ef       	ldi	r21, 0xFF	; 255
     5f0:	60 e0       	ldi	r22, 0x00	; 0
     5f2:	70 e0       	ldi	r23, 0x00	; 0
     5f4:	80 91 ce 07 	lds	r24, 0x07CE
     5f8:	90 91 cf 07 	lds	r25, 0x07CF
     5fc:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     600:	81 30       	cpi	r24, 0x01	; 1
     602:	99 f7       	brne	.-26     	; 0x5ea <MoteInitialization+0xa4>
	moteData->validFrame=0;
     604:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,joinACK,moteData->decodeResult))
     606:	4d 8d       	ldd	r20, Y+29	; 0x1d
     608:	5e 8d       	ldd	r21, Y+30	; 0x1e
     60a:	64 e6       	ldi	r22, 0x64	; 100
     60c:	71 e0       	ldi	r23, 0x01	; 1
     60e:	c8 01       	movw	r24, r16
     610:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     614:	88 23       	and	r24, r24
     616:	91 f0       	breq	.+36     	; 0x63c <MoteInitialization+0xf6>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,joinACK,sizeof(joinACK),sizeof(moteData->hdlcOutput));
     618:	22 e5       	ldi	r18, 0x52	; 82
     61a:	30 e0       	ldi	r19, 0x00	; 0
     61c:	44 e0       	ldi	r20, 0x04	; 4
     61e:	50 e0       	ldi	r21, 0x00	; 0
     620:	64 e6       	ldi	r22, 0x64	; 100
     622:	71 e0       	ldi	r23, 0x01	; 1
     624:	c7 01       	movw	r24, r14
     626:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     62a:	fe 01       	movw	r30, r28
     62c:	ee 56       	subi	r30, 0x6E	; 110
     62e:	ff 4f       	sbci	r31, 0xFF	; 255
     630:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     632:	ae 01       	movw	r20, r28
     634:	68 2f       	mov	r22, r24
     636:	c7 01       	movw	r24, r14
     638:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x01);
	}
	
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     63c:	20 e0       	ldi	r18, 0x00	; 0
     63e:	4f ef       	ldi	r20, 0xFF	; 255
     640:	5f ef       	ldi	r21, 0xFF	; 255
     642:	60 e0       	ldi	r22, 0x00	; 0
     644:	70 e0       	ldi	r23, 0x00	; 0
     646:	80 91 ce 07 	lds	r24, 0x07CE
     64a:	90 91 cf 07 	lds	r25, 0x07CF
     64e:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     652:	81 30       	cpi	r24, 0x01	; 1
     654:	99 f7       	brne	.-26     	; 0x63c <MoteInitialization+0xf6>
	moteData->validFrame=0;
     656:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,moteSearchingEvent,moteData->decodeResult))
     658:	4d 8d       	ldd	r20, Y+29	; 0x1d
     65a:	5e 8d       	ldd	r21, Y+30	; 0x1e
     65c:	68 e5       	ldi	r22, 0x58	; 88
     65e:	71 e0       	ldi	r23, 0x01	; 1
     660:	c8 01       	movw	r24, r16
     662:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     666:	88 23       	and	r24, r24
     668:	91 f0       	breq	.+36     	; 0x68e <MoteInitialization+0x148>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     66a:	22 e5       	ldi	r18, 0x52	; 82
     66c:	30 e0       	ldi	r19, 0x00	; 0
     66e:	44 e0       	ldi	r20, 0x04	; 4
     670:	50 e0       	ldi	r21, 0x00	; 0
     672:	6b e6       	ldi	r22, 0x6B	; 107
     674:	71 e0       	ldi	r23, 0x01	; 1
     676:	c7 01       	movw	r24, r14
     678:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     67c:	fe 01       	movw	r30, r28
     67e:	ee 56       	subi	r30, 0x6E	; 110
     680:	ff 4f       	sbci	r31, 0xFF	; 255
     682:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     684:	ae 01       	movw	r20, r28
     686:	68 2f       	mov	r22, r24
     688:	c7 01       	movw	r24, r14
     68a:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x02);
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     68e:	20 e0       	ldi	r18, 0x00	; 0
     690:	4f ef       	ldi	r20, 0xFF	; 255
     692:	5f ef       	ldi	r21, 0xFF	; 255
     694:	60 e0       	ldi	r22, 0x00	; 0
     696:	70 e0       	ldi	r23, 0x00	; 0
     698:	80 91 ce 07 	lds	r24, 0x07CE
     69c:	90 91 cf 07 	lds	r25, 0x07CF
     6a0:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     6a4:	81 30       	cpi	r24, 0x01	; 1
     6a6:	99 f7       	brne	.-26     	; 0x68e <MoteInitialization+0x148>
	moteData->validFrame=0;
     6a8:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,negotiatingEvent,moteData->decodeResult))
     6aa:	4d 8d       	ldd	r20, Y+29	; 0x1d
     6ac:	5e 8d       	ldd	r21, Y+30	; 0x1e
     6ae:	6c e4       	ldi	r22, 0x4C	; 76
     6b0:	71 e0       	ldi	r23, 0x01	; 1
     6b2:	c8 01       	movw	r24, r16
     6b4:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     6b8:	88 23       	and	r24, r24
     6ba:	91 f0       	breq	.+36     	; 0x6e0 <MoteInitialization+0x19a>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     6bc:	22 e5       	ldi	r18, 0x52	; 82
     6be:	30 e0       	ldi	r19, 0x00	; 0
     6c0:	44 e0       	ldi	r20, 0x04	; 4
     6c2:	50 e0       	ldi	r21, 0x00	; 0
     6c4:	6b e6       	ldi	r22, 0x6B	; 107
     6c6:	71 e0       	ldi	r23, 0x01	; 1
     6c8:	c7 01       	movw	r24, r14
     6ca:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     6ce:	fe 01       	movw	r30, r28
     6d0:	ee 56       	subi	r30, 0x6E	; 110
     6d2:	ff 4f       	sbci	r31, 0xFF	; 255
     6d4:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     6d6:	ae 01       	movw	r20, r28
     6d8:	68 2f       	mov	r22, r24
     6da:	c7 01       	movw	r24, r14
     6dc:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x03);
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     6e0:	20 e0       	ldi	r18, 0x00	; 0
     6e2:	4f ef       	ldi	r20, 0xFF	; 255
     6e4:	5f ef       	ldi	r21, 0xFF	; 255
     6e6:	60 e0       	ldi	r22, 0x00	; 0
     6e8:	70 e0       	ldi	r23, 0x00	; 0
     6ea:	80 91 ce 07 	lds	r24, 0x07CE
     6ee:	90 91 cf 07 	lds	r25, 0x07CF
     6f2:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     6f6:	81 30       	cpi	r24, 0x01	; 1
     6f8:	99 f7       	brne	.-26     	; 0x6e0 <MoteInitialization+0x19a>
	moteData->validFrame=0;
     6fa:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,alarmEvent,moteData->decodeResult))
     6fc:	4d 8d       	ldd	r20, Y+29	; 0x1d
     6fe:	5e 8d       	ldd	r21, Y+30	; 0x1e
     700:	60 e4       	ldi	r22, 0x40	; 64
     702:	71 e0       	ldi	r23, 0x01	; 1
     704:	c8 01       	movw	r24, r16
     706:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     70a:	88 23       	and	r24, r24
     70c:	91 f0       	breq	.+36     	; 0x732 <MoteInitialization+0x1ec>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     70e:	22 e5       	ldi	r18, 0x52	; 82
     710:	30 e0       	ldi	r19, 0x00	; 0
     712:	44 e0       	ldi	r20, 0x04	; 4
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	6b e6       	ldi	r22, 0x6B	; 107
     718:	71 e0       	ldi	r23, 0x01	; 1
     71a:	c7 01       	movw	r24, r14
     71c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     720:	fe 01       	movw	r30, r28
     722:	ee 56       	subi	r30, 0x6E	; 110
     724:	ff 4f       	sbci	r31, 0xFF	; 255
     726:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     728:	ae 01       	movw	r20, r28
     72a:	68 2f       	mov	r22, r24
     72c:	c7 01       	movw	r24, r14
     72e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x04);
		
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) !=  pdTRUE);
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	4f ef       	ldi	r20, 0xFF	; 255
     736:	5f ef       	ldi	r21, 0xFF	; 255
     738:	60 e0       	ldi	r22, 0x00	; 0
     73a:	70 e0       	ldi	r23, 0x00	; 0
     73c:	80 91 ce 07 	lds	r24, 0x07CE
     740:	90 91 cf 07 	lds	r25, 0x07CF
     744:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     748:	81 30       	cpi	r24, 0x01	; 1
     74a:	99 f7       	brne	.-26     	; 0x732 <MoteInitialization+0x1ec>
	moteData->validFrame=0;
     74c:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,operationalEvent,moteData->decodeResult))
     74e:	4d 8d       	ldd	r20, Y+29	; 0x1d
     750:	5e 8d       	ldd	r21, Y+30	; 0x1e
     752:	64 e3       	ldi	r22, 0x34	; 52
     754:	71 e0       	ldi	r23, 0x01	; 1
     756:	c8 01       	movw	r24, r16
     758:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     75c:	88 23       	and	r24, r24
     75e:	91 f0       	breq	.+36     	; 0x784 <MoteInitialization+0x23e>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     760:	22 e5       	ldi	r18, 0x52	; 82
     762:	30 e0       	ldi	r19, 0x00	; 0
     764:	44 e0       	ldi	r20, 0x04	; 4
     766:	50 e0       	ldi	r21, 0x00	; 0
     768:	6b e6       	ldi	r22, 0x6B	; 107
     76a:	71 e0       	ldi	r23, 0x01	; 1
     76c:	c7 01       	movw	r24, r14
     76e:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     772:	fe 01       	movw	r30, r28
     774:	ee 56       	subi	r30, 0x6E	; 110
     776:	ff 4f       	sbci	r31, 0xFF	; 255
     778:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     77a:	ae 01       	movw	r20, r28
     77c:	68 2f       	mov	r22, r24
     77e:	c7 01       	movw	r24, r14
     780:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x05);
		
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     784:	20 e0       	ldi	r18, 0x00	; 0
     786:	4f ef       	ldi	r20, 0xFF	; 255
     788:	5f ef       	ldi	r21, 0xFF	; 255
     78a:	60 e0       	ldi	r22, 0x00	; 0
     78c:	70 e0       	ldi	r23, 0x00	; 0
     78e:	80 91 ce 07 	lds	r24, 0x07CE
     792:	90 91 cf 07 	lds	r25, 0x07CF
     796:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     79a:	81 30       	cpi	r24, 0x01	; 1
     79c:	99 f7       	brne	.-26     	; 0x784 <MoteInitialization+0x23e>
	moteData->validFrame=0;
     79e:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,svcIndication,moteData->decodeResult))
     7a0:	4d 8d       	ldd	r20, Y+29	; 0x1d
     7a2:	5e 8d       	ldd	r21, Y+30	; 0x1e
     7a4:	65 e2       	ldi	r22, 0x25	; 37
     7a6:	71 e0       	ldi	r23, 0x01	; 1
     7a8:	c8 01       	movw	r24, r16
     7aa:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     7ae:	88 23       	and	r24, r24
     7b0:	91 f0       	breq	.+36     	; 0x7d6 <MoteInitialization+0x290>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,serviceACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     7b2:	22 e5       	ldi	r18, 0x52	; 82
     7b4:	30 e0       	ldi	r19, 0x00	; 0
     7b6:	44 e0       	ldi	r20, 0x04	; 4
     7b8:	50 e0       	ldi	r21, 0x00	; 0
     7ba:	61 e2       	ldi	r22, 0x21	; 33
     7bc:	71 e0       	ldi	r23, 0x01	; 1
     7be:	c7 01       	movw	r24, r14
     7c0:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     7c4:	fe 01       	movw	r30, r28
     7c6:	ee 56       	subi	r30, 0x6E	; 110
     7c8:	ff 4f       	sbci	r31, 0xFF	; 255
     7ca:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     7cc:	ae 01       	movw	r20, r28
     7ce:	68 2f       	mov	r22, r24
     7d0:	c7 01       	movw	r24, r14
     7d2:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	{
		//return to state machine
	}


}
     7d6:	df 91       	pop	r29
     7d8:	cf 91       	pop	r28
     7da:	1f 91       	pop	r17
     7dc:	0f 91       	pop	r16
     7de:	ff 90       	pop	r15
     7e0:	ef 90       	pop	r14
     7e2:	08 95       	ret

000007e4 <MoteSvcInitialization>:

void MoteSvcInitialization( MoteData_p moteData){
     7e4:	cf 92       	push	r12
     7e6:	df 92       	push	r13
     7e8:	ef 92       	push	r14
     7ea:	ff 92       	push	r15
     7ec:	0f 93       	push	r16
     7ee:	1f 93       	push	r17
     7f0:	cf 93       	push	r28
     7f2:	df 93       	push	r29
     7f4:	ec 01       	movw	r28, r24

// requesting service
	
	moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,setService,sizeof(setService),sizeof(moteData->hdlcOutput));
     7f6:	8c 01       	movw	r16, r24
     7f8:	00 5e       	subi	r16, 0xE0	; 224
     7fa:	1f 4f       	sbci	r17, 0xFF	; 255
     7fc:	22 e5       	ldi	r18, 0x52	; 82
     7fe:	30 e0       	ldi	r19, 0x00	; 0
     800:	4d e0       	ldi	r20, 0x0D	; 13
     802:	50 e0       	ldi	r21, 0x00	; 0
     804:	64 e1       	ldi	r22, 0x14	; 20
     806:	71 e0       	ldi	r23, 0x01	; 1
     808:	c8 01       	movw	r24, r16
     80a:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     80e:	fe 01       	movw	r30, r28
     810:	ee 56       	subi	r30, 0x6E	; 110
     812:	ff 4f       	sbci	r31, 0xFF	; 255
     814:	80 83       	st	Z, r24
	serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     816:	ae 01       	movw	r20, r28
     818:	68 2f       	mov	r22, r24
     81a:	c8 01       	movw	r24, r16
     81c:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     820:	20 e0       	ldi	r18, 0x00	; 0
     822:	4f ef       	ldi	r20, 0xFF	; 255
     824:	5f ef       	ldi	r21, 0xFF	; 255
     826:	60 e0       	ldi	r22, 0x00	; 0
     828:	70 e0       	ldi	r23, 0x00	; 0
     82a:	80 91 ce 07 	lds	r24, 0x07CE
     82e:	90 91 cf 07 	lds	r25, 0x07CF
     832:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     836:	81 30       	cpi	r24, 0x01	; 1
     838:	99 f7       	brne	.-26     	; 0x820 <MoteSvcInitialization+0x3c>
	moteData->validFrame=0;
     83a:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,setServiceACK,moteData->decodeResult))
     83c:	4d 8d       	ldd	r20, Y+29	; 0x1d
     83e:	5e 8d       	ldd	r21, Y+30	; 0x1e
     840:	6e e0       	ldi	r22, 0x0E	; 14
     842:	71 e0       	ldi	r23, 0x01	; 1
     844:	ce 01       	movw	r24, r28
     846:	8e 58       	subi	r24, 0x8E	; 142
     848:	9f 4f       	sbci	r25, 0xFF	; 255
     84a:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
	{
		while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
		moteData->validFrame=0;
		//en este punto esperamos un svcIndication con el tiempo pedido, puede llegar uno de delayed response
		//asi que todos los respondes con el serviceACK y checamos si se nos otorgo el tiempo
			moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,serviceACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     84e:	6e 01       	movw	r12, r28
     850:	82 e9       	ldi	r24, 0x92	; 146
     852:	c8 0e       	add	r12, r24
     854:	d1 1c       	adc	r13, r1
			serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
			
		if (moteData->hdlcDecoded[3]==0x03)//delayed response
     856:	7e 01       	movw	r14, r28
     858:	e5 e7       	ldi	r30, 0x75	; 117
     85a:	ee 0e       	add	r14, r30
     85c:	f1 1c       	adc	r15, r1
	}
	
	uint8_t serviceReady=0;
	while (!serviceReady)
	{
		while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     85e:	20 e0       	ldi	r18, 0x00	; 0
     860:	4f ef       	ldi	r20, 0xFF	; 255
     862:	5f ef       	ldi	r21, 0xFF	; 255
     864:	60 e0       	ldi	r22, 0x00	; 0
     866:	70 e0       	ldi	r23, 0x00	; 0
     868:	80 91 ce 07 	lds	r24, 0x07CE
     86c:	90 91 cf 07 	lds	r25, 0x07CF
     870:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     874:	81 30       	cpi	r24, 0x01	; 1
     876:	99 f7       	brne	.-26     	; 0x85e <MoteSvcInitialization+0x7a>
		moteData->validFrame=0;
     878:	1f 8e       	std	Y+31, r1	; 0x1f
		//en este punto esperamos un svcIndication con el tiempo pedido, puede llegar uno de delayed response
		//asi que todos los respondes con el serviceACK y checamos si se nos otorgo el tiempo
			moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,serviceACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     87a:	22 e5       	ldi	r18, 0x52	; 82
     87c:	30 e0       	ldi	r19, 0x00	; 0
     87e:	44 e0       	ldi	r20, 0x04	; 4
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	61 e2       	ldi	r22, 0x21	; 33
     884:	71 e0       	ldi	r23, 0x01	; 1
     886:	c8 01       	movw	r24, r16
     888:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     88c:	f6 01       	movw	r30, r12
     88e:	80 83       	st	Z, r24
			serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     890:	ae 01       	movw	r20, r28
     892:	68 2f       	mov	r22, r24
     894:	c8 01       	movw	r24, r16
     896:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
			
		if (moteData->hdlcDecoded[3]==0x03)//delayed response
     89a:	f7 01       	movw	r30, r14
     89c:	80 81       	ld	r24, Z
     89e:	83 30       	cpi	r24, 0x03	; 3
     8a0:	f1 f2       	breq	.-68     	; 0x85e <MoteSvcInitialization+0x7a>
		{
			serviceReady=0;
		}
		else{
			if (moteData->hdlcDecoded[3]==0x00)//created
     8a2:	80 81       	ld	r24, Z
     8a4:	81 11       	cpse	r24, r1
     8a6:	db cf       	rjmp	.-74     	; 0x85e <MoteSvcInitialization+0x7a>
				serviceReady=1;
				//serialPCtx(0xF0);
			}
		}
	}
}
     8a8:	df 91       	pop	r29
     8aa:	cf 91       	pop	r28
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	ff 90       	pop	r15
     8b2:	ef 90       	pop	r14
     8b4:	df 90       	pop	r13
     8b6:	cf 90       	pop	r12
     8b8:	08 95       	ret

000008ba <compareBuffer_D>:
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     8ba:	44 23       	and	r20, r20
     8bc:	81 f0       	breq	.+32     	; 0x8de <compareBuffer_D+0x24>
     8be:	28 2f       	mov	r18, r24
     8c0:	a6 2f       	mov	r26, r22
     8c2:	b7 2f       	mov	r27, r23
     8c4:	e8 2f       	mov	r30, r24
     8c6:	f9 2f       	mov	r31, r25
	
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     8c8:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i=0;i<tam;i++)
	{
		//if (datos[i]==datos2[i])
		if (datos[i]==(datos2[i]))
     8ca:	91 91       	ld	r25, Z+
     8cc:	8d 91       	ld	r24, X+
     8ce:	98 13       	cpse	r25, r24
     8d0:	01 c0       	rjmp	.+2      	; 0x8d4 <compareBuffer_D+0x1a>
		{
			comparacion++;
     8d2:	3f 5f       	subi	r19, 0xFF	; 255
     8d4:	8e 2f       	mov	r24, r30
     8d6:	82 1b       	sub	r24, r18
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     8d8:	84 17       	cp	r24, r20
     8da:	b8 f3       	brcs	.-18     	; 0x8ca <compareBuffer_D+0x10>
     8dc:	01 c0       	rjmp	.+2      	; 0x8e0 <compareBuffer_D+0x26>
	
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     8de:	30 e0       	ldi	r19, 0x00	; 0
		{
			comparacion++;
		}
	}
	
	if (comparacion>=tam)
     8e0:	81 e0       	ldi	r24, 0x01	; 1
     8e2:	34 17       	cp	r19, r20
     8e4:	08 f4       	brcc	.+2      	; 0x8e8 <compareBuffer_D+0x2e>
     8e6:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}else return 0;
	
	
	
}
     8e8:	08 95       	ret

000008ea <sendData>:
		moteData->serialMoteSend(datos[i]);
	}
	
}

uint8_t sendData(uint8_t* data, uint8_t tam, uint8_t svcId, MoteData_p moteData){
     8ea:	df 92       	push	r13
     8ec:	ef 92       	push	r14
     8ee:	ff 92       	push	r15
     8f0:	0f 93       	push	r16
     8f2:	1f 93       	push	r17
     8f4:	cf 93       	push	r28
     8f6:	df 93       	push	r29
     8f8:	d6 2e       	mov	r13, r22
     8fa:	14 2f       	mov	r17, r20
     8fc:	e9 01       	movw	r28, r18
	
	
	moteData->sizeToSend=0;
     8fe:	79 01       	movw	r14, r18
     900:	22 e9       	ldi	r18, 0x92	; 146
     902:	e2 0e       	add	r14, r18
     904:	f1 1c       	adc	r15, r1
     906:	f7 01       	movw	r30, r14
     908:	10 82       	st	Z, r1
	uint8_t newTam = 12+tam;
	//uint8_t* arr;
	static uint8_t arr[BUFFER_LENGHT];
	//arr = (uint8_t*)malloc(newTam);
	memcpy(arr,sendComand,11);
     90a:	2b e0       	ldi	r18, 0x0B	; 11
     90c:	e6 e0       	ldi	r30, 0x06	; 6
     90e:	f1 e0       	ldi	r31, 0x01	; 1
     910:	a6 e2       	ldi	r26, 0x26	; 38
     912:	b1 e0       	ldi	r27, 0x01	; 1
     914:	01 90       	ld	r0, Z+
     916:	0d 92       	st	X+, r0
     918:	2a 95       	dec	r18
     91a:	e1 f7       	brne	.-8      	; 0x914 <__stack+0x15>
	arr[1]=newTam-3;//menos el header
     91c:	29 e0       	ldi	r18, 0x09	; 9
     91e:	26 0f       	add	r18, r22
     920:	20 93 27 01 	sts	0x0127, r18
	arr[11]=tam;//tanaio del payload
     924:	60 93 31 01 	sts	0x0131, r22
	memcpy(&arr[12],data,tam);
     928:	46 2f       	mov	r20, r22
     92a:	50 e0       	ldi	r21, 0x00	; 0
     92c:	bc 01       	movw	r22, r24
     92e:	82 e3       	ldi	r24, 0x32	; 50
     930:	91 e0       	ldi	r25, 0x01	; 1
     932:	0e 94 af 12 	call	0x255e	; 0x255e <memcpy>
	arr[5]=svcId;
     936:	10 93 2b 01 	sts	0x012B, r17
	moteData->sizeToSend=(int8_t)hdlc_encode_D(moteData->hdlcOutput,arr,newTam,sizeof(moteData->hdlcOutput));
     93a:	8e 01       	movw	r16, r28
     93c:	00 5e       	subi	r16, 0xE0	; 224
     93e:	1f 4f       	sbci	r17, 0xFF	; 255

uint8_t sendData(uint8_t* data, uint8_t tam, uint8_t svcId, MoteData_p moteData){
	
	
	moteData->sizeToSend=0;
	uint8_t newTam = 12+tam;
     940:	4c e0       	ldi	r20, 0x0C	; 12
     942:	4d 0d       	add	r20, r13
	memcpy(arr,sendComand,11);
	arr[1]=newTam-3;//menos el header
	arr[11]=tam;//tanaio del payload
	memcpy(&arr[12],data,tam);
	arr[5]=svcId;
	moteData->sizeToSend=(int8_t)hdlc_encode_D(moteData->hdlcOutput,arr,newTam,sizeof(moteData->hdlcOutput));
     944:	50 e0       	ldi	r21, 0x00	; 0
     946:	22 e5       	ldi	r18, 0x52	; 82
     948:	30 e0       	ldi	r19, 0x00	; 0
     94a:	66 e2       	ldi	r22, 0x26	; 38
     94c:	71 e0       	ldi	r23, 0x01	; 1
     94e:	c8 01       	movw	r24, r16
     950:	0e 94 b0 05 	call	0xb60	; 0xb60 <hdlc_encode_D>
     954:	f7 01       	movw	r30, r14
     956:	80 83       	st	Z, r24
	serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     958:	ae 01       	movw	r20, r28
     95a:	68 2f       	mov	r22, r24
     95c:	c8 01       	movw	r24, r16
     95e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	//free(arr);
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     962:	20 e0       	ldi	r18, 0x00	; 0
     964:	4f ef       	ldi	r20, 0xFF	; 255
     966:	5f ef       	ldi	r21, 0xFF	; 255
     968:	60 e0       	ldi	r22, 0x00	; 0
     96a:	70 e0       	ldi	r23, 0x00	; 0
     96c:	80 91 ce 07 	lds	r24, 0x07CE
     970:	90 91 cf 07 	lds	r25, 0x07CF
     974:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
     978:	81 30       	cpi	r24, 0x01	; 1
     97a:	99 f7       	brne	.-26     	; 0x962 <__stack+0x63>
	moteData->validFrame=0;
     97c:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer_D(moteData->hdlcDecoded,sendACK,moteData->decodeResult))
     97e:	4d 8d       	ldd	r20, Y+29	; 0x1d
     980:	5e 8d       	ldd	r21, Y+30	; 0x1e
     982:	6a e0       	ldi	r22, 0x0A	; 10
     984:	71 e0       	ldi	r23, 0x01	; 1
     986:	ce 01       	movw	r24, r28
     988:	8e 58       	subi	r24, 0x8E	; 142
     98a:	9f 4f       	sbci	r25, 0xFF	; 255
     98c:	0e 94 5d 04 	call	0x8ba	; 0x8ba <compareBuffer_D>
     990:	91 e0       	ldi	r25, 0x01	; 1
     992:	81 11       	cpse	r24, r1
     994:	01 c0       	rjmp	.+2      	; 0x998 <__stack+0x99>
     996:	90 e0       	ldi	r25, 0x00	; 0
	
	
	
	
	
}
     998:	89 2f       	mov	r24, r25
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	1f 91       	pop	r17
     9a0:	0f 91       	pop	r16
     9a2:	ff 90       	pop	r15
     9a4:	ef 90       	pop	r14
     9a6:	df 90       	pop	r13
     9a8:	08 95       	ret

000009aa <fcs_fcs16>:
 */
INT16U fcs_fcs16(INT16U fcs, INT8U data)
{
  // return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff];
   
   return (fcs >> 8) ^ pgm_read_word(&fcstab[(fcs ^ data) & 0xff]);
     9aa:	fc 01       	movw	r30, r24
     9ac:	e6 27       	eor	r30, r22
     9ae:	ff 27       	eor	r31, r31
     9b0:	ee 0f       	add	r30, r30
     9b2:	ff 1f       	adc	r31, r31
     9b4:	e5 58       	subi	r30, 0x85	; 133
     9b6:	fe 4f       	sbci	r31, 0xFE	; 254
     9b8:	25 91       	lpm	r18, Z+
     9ba:	34 91       	lpm	r19, Z
     9bc:	89 2f       	mov	r24, r25
     9be:	99 27       	eor	r25, r25
}
     9c0:	82 27       	eor	r24, r18
     9c2:	93 27       	eor	r25, r19
     9c4:	08 95       	ret

000009c6 <fcs_calcFcs>:
 * @param len - length of buffer
 * 
 * @return INT16U - calculated FCS16
 */
INT16U fcs_calcFcs(INT8U* buf, INT32U len)
{
     9c6:	0f 93       	push	r16
     9c8:	1f 93       	push	r17
     9ca:	cf 93       	push	r28
     9cc:	df 93       	push	r29
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     9ce:	61 15       	cp	r22, r1
     9d0:	71 05       	cpc	r23, r1
     9d2:	79 f0       	breq	.+30     	; 0x9f2 <fcs_calcFcs+0x2c>
     9d4:	ec 01       	movw	r28, r24
     9d6:	8c 01       	movw	r16, r24
     9d8:	06 0f       	add	r16, r22
     9da:	17 1f       	adc	r17, r23
INT16U fcs_calcFcs(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     9dc:	8f ef       	ldi	r24, 0xFF	; 255
     9de:	9f ef       	ldi	r25, 0xFF	; 255
   for (i = 0; i < len; i++) {
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, pgm_read_byte(&buf[i]));
     9e0:	fe 01       	movw	r30, r28
     9e2:	64 91       	lpm	r22, Z
     9e4:	0e 94 d5 04 	call	0x9aa	; 0x9aa <fcs_fcs16>
     9e8:	21 96       	adiw	r28, 0x01	; 1
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     9ea:	c0 17       	cp	r28, r16
     9ec:	d1 07       	cpc	r29, r17
     9ee:	c1 f7       	brne	.-16     	; 0x9e0 <fcs_calcFcs+0x1a>
     9f0:	02 c0       	rjmp	.+4      	; 0x9f6 <fcs_calcFcs+0x30>
INT16U fcs_calcFcs(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     9f2:	8f ef       	ldi	r24, 0xFF	; 255
     9f4:	9f ef       	ldi	r25, 0xFF	; 255
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, pgm_read_byte(&buf[i]));
   }

   return (fcs ^ 0xffff); /* return complement */
}
     9f6:	80 95       	com	r24
     9f8:	90 95       	com	r25
     9fa:	df 91       	pop	r29
     9fc:	cf 91       	pop	r28
     9fe:	1f 91       	pop	r17
     a00:	0f 91       	pop	r16
     a02:	08 95       	ret

00000a04 <fcs_calcFcs_D>:
 * @param len - length of buffer
 * 
 * @return INT16U - calculated FCS16
 */
INT16U fcs_calcFcs_D(INT8U* buf, INT32U len)
{
     a04:	0f 93       	push	r16
     a06:	1f 93       	push	r17
     a08:	cf 93       	push	r28
     a0a:	df 93       	push	r29
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     a0c:	61 15       	cp	r22, r1
     a0e:	71 05       	cpc	r23, r1
     a10:	69 f0       	breq	.+26     	; 0xa2c <fcs_calcFcs_D+0x28>
     a12:	ec 01       	movw	r28, r24
     a14:	8c 01       	movw	r16, r24
     a16:	06 0f       	add	r16, r22
     a18:	17 1f       	adc	r17, r23
INT16U fcs_calcFcs_D(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     a1a:	8f ef       	ldi	r24, 0xFF	; 255
     a1c:	9f ef       	ldi	r25, 0xFF	; 255
   for (i = 0; i < len; i++) {
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, buf[i]);
     a1e:	69 91       	ld	r22, Y+
     a20:	0e 94 d5 04 	call	0x9aa	; 0x9aa <fcs_fcs16>
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     a24:	c0 17       	cp	r28, r16
     a26:	d1 07       	cpc	r29, r17
     a28:	d1 f7       	brne	.-12     	; 0xa1e <fcs_calcFcs_D+0x1a>
     a2a:	02 c0       	rjmp	.+4      	; 0xa30 <fcs_calcFcs_D+0x2c>
INT16U fcs_calcFcs_D(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     a2c:	8f ef       	ldi	r24, 0xFF	; 255
     a2e:	9f ef       	ldi	r25, 0xFF	; 255
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, buf[i]);
   }

   return (fcs ^ 0xffff); /* return complement */
}
     a30:	80 95       	com	r24
     a32:	90 95       	com	r25
     a34:	df 91       	pop	r29
     a36:	cf 91       	pop	r28
     a38:	1f 91       	pop	r17
     a3a:	0f 91       	pop	r16
     a3c:	08 95       	ret

00000a3e <hdlc_decode>:
 * Returns:
 *    > 0: length of decoded data
 *    < 0: error code
 */
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
     a3e:	4f 92       	push	r4
     a40:	5f 92       	push	r5
     a42:	6f 92       	push	r6
     a44:	7f 92       	push	r7
     a46:	8f 92       	push	r8
     a48:	9f 92       	push	r9
     a4a:	af 92       	push	r10
     a4c:	bf 92       	push	r11
     a4e:	cf 92       	push	r12
     a50:	df 92       	push	r13
     a52:	ef 92       	push	r14
     a54:	ff 92       	push	r15
     a56:	0f 93       	push	r16
     a58:	1f 93       	push	r17
     a5a:	cf 93       	push	r28
     a5c:	df 93       	push	r29
     a5e:	4c 01       	movw	r8, r24
     a60:	6a 01       	movw	r12, r20
     a62:	59 01       	movw	r10, r18
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
     a64:	fa 01       	movw	r30, r20
     a66:	80 81       	ld	r24, Z
     a68:	88 23       	and	r24, r24
     a6a:	09 f4       	brne	.+2      	; 0xa6e <hdlc_decode+0x30>
     a6c:	4d c0       	rjmp	.+154    	; 0xb08 <hdlc_decode+0xca>
     a6e:	06 2f       	mov	r16, r22
     a70:	17 2f       	mov	r17, r23
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
     a72:	40 e0       	ldi	r20, 0x00	; 0
{
   INT32U i;
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
     a74:	50 e0       	ldi	r21, 0x00	; 0
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
   INT32U i;
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
   INT8U fOpenFlag = 0;
     a76:	71 2c       	mov	r7, r1
 */
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
   INT32U i;
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
     a78:	8f ef       	ldi	r24, 0xFF	; 255
     a7a:	9f ef       	ldi	r25, 0xFF	; 255
 *    < 0: error code
 */
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
   INT32U i;
   INT32U wIdx = 0;
     a7c:	e1 2c       	mov	r14, r1
     a7e:	f1 2c       	mov	r15, r1
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
     a80:	c0 e0       	ldi	r28, 0x00	; 0
     a82:	d0 e0       	ldi	r29, 0x00	; 0
               return HDLC_ERR_CRC;
            }
         }
      }
      else if (curByte == HDLC_ESCAPE_BYTE) {
         fEscape = 1;
     a84:	66 24       	eor	r6, r6
     a86:	63 94       	inc	r6
            }
            if (wIdx > maxOutLen) {
               return HDLC_ERR_LEN;
            }
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
            wIdx++;
     a88:	51 2c       	mov	r5, r1
      else {
         if (fOpenFlag) {
            fDataStart = 1;
            if (fEscape) {
               fEscape = 0;
               pOut[wIdx] = (curByte ^ 0x20);
     a8a:	68 94       	set
     a8c:	44 24       	eor	r4, r4
     a8e:	45 f8       	bld	r4, 5
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
      curByte = pIn[i];
     a90:	f8 01       	movw	r30, r16
     a92:	21 91       	ld	r18, Z+
     a94:	8f 01       	movw	r16, r30
      if (curByte == HDLC_FRAME_BYTE) {
     a96:	2e 37       	cpi	r18, 0x7E	; 126
     a98:	69 f4       	brne	.+26     	; 0xab4 <hdlc_decode+0x76>
         if (!fOpenFlag) {
     a9a:	77 20       	and	r7, r7
     a9c:	51 f1       	breq	.+84     	; 0xaf2 <hdlc_decode+0xb4>
            fOpenFlag = 1;
         }
         else if (fDataStart) {
     a9e:	55 23       	and	r21, r21
     aa0:	59 f1       	breq	.+86     	; 0xaf8 <hdlc_decode+0xba>
            // output amount of input read
            *inLen = i+1;
     aa2:	cf 5f       	subi	r28, 0xFF	; 255
     aa4:	f6 01       	movw	r30, r12
     aa6:	c0 83       	st	Z, r28
            if (calcCrc == FCS_GOOD_FCS16) {
     aa8:	88 3b       	cpi	r24, 0xB8	; 184
     aaa:	90 4f       	sbci	r25, 0xF0	; 240
     aac:	81 f5       	brne	.+96     	; 0xb0e <hdlc_decode+0xd0>
               // return length excluding CRC bytes
               return (wIdx - 2);
     aae:	c7 01       	movw	r24, r14
     ab0:	02 97       	sbiw	r24, 0x02	; 2
     ab2:	35 c0       	rjmp	.+106    	; 0xb1e <hdlc_decode+0xe0>
            else {
               return HDLC_ERR_CRC;
            }
         }
      }
      else if (curByte == HDLC_ESCAPE_BYTE) {
     ab4:	2d 37       	cpi	r18, 0x7D	; 125
     ab6:	f9 f0       	breq	.+62     	; 0xaf6 <hdlc_decode+0xb8>
         fEscape = 1;
      }
      else {
         if (fOpenFlag) {
     ab8:	77 20       	and	r7, r7
     aba:	f1 f0       	breq	.+60     	; 0xaf8 <hdlc_decode+0xba>
            fDataStart = 1;
            if (fEscape) {
     abc:	44 23       	and	r20, r20
     abe:	31 f0       	breq	.+12     	; 0xacc <hdlc_decode+0x8e>
               fEscape = 0;
               pOut[wIdx] = (curByte ^ 0x20);
     ac0:	f4 01       	movw	r30, r8
     ac2:	ee 0d       	add	r30, r14
     ac4:	ff 1d       	adc	r31, r15
     ac6:	24 25       	eor	r18, r4
     ac8:	20 83       	st	Z, r18
     aca:	04 c0       	rjmp	.+8      	; 0xad4 <hdlc_decode+0x96>
            }
            else {
               pOut[wIdx] = curByte;
     acc:	f4 01       	movw	r30, r8
     ace:	ee 0d       	add	r30, r14
     ad0:	ff 1d       	adc	r31, r15
     ad2:	20 83       	st	Z, r18
            }
            if (wIdx > maxOutLen) {
     ad4:	ae 14       	cp	r10, r14
     ad6:	bf 04       	cpc	r11, r15
     ad8:	e8 f0       	brcs	.+58     	; 0xb14 <hdlc_decode+0xd6>
               return HDLC_ERR_LEN;
            }
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
     ada:	f4 01       	movw	r30, r8
     adc:	ee 0d       	add	r30, r14
     ade:	ff 1d       	adc	r31, r15
     ae0:	60 81       	ld	r22, Z
     ae2:	0e 94 d5 04 	call	0x9aa	; 0x9aa <fcs_fcs16>
            wIdx++;
     ae6:	2f ef       	ldi	r18, 0xFF	; 255
     ae8:	e2 1a       	sub	r14, r18
     aea:	f2 0a       	sbc	r15, r18
     aec:	45 2d       	mov	r20, r5
      else if (curByte == HDLC_ESCAPE_BYTE) {
         fEscape = 1;
      }
      else {
         if (fOpenFlag) {
            fDataStart = 1;
     aee:	56 2d       	mov	r21, r6
     af0:	03 c0       	rjmp	.+6      	; 0xaf8 <hdlc_decode+0xba>
   
   for (i = 0; i < *inLen; i++) {
      curByte = pIn[i];
      if (curByte == HDLC_FRAME_BYTE) {
         if (!fOpenFlag) {
            fOpenFlag = 1;
     af2:	76 2c       	mov	r7, r6
     af4:	01 c0       	rjmp	.+2      	; 0xaf8 <hdlc_decode+0xba>
               return HDLC_ERR_CRC;
            }
         }
      }
      else if (curByte == HDLC_ESCAPE_BYTE) {
         fEscape = 1;
     af6:	46 2d       	mov	r20, r6
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
     af8:	21 96       	adiw	r28, 0x01	; 1
     afa:	f6 01       	movw	r30, r12
     afc:	20 81       	ld	r18, Z
     afe:	30 e0       	ldi	r19, 0x00	; 0
     b00:	c2 17       	cp	r28, r18
     b02:	d3 07       	cpc	r29, r19
     b04:	28 f2       	brcs	.-118    	; 0xa90 <hdlc_decode+0x52>
     b06:	09 c0       	rjmp	.+18     	; 0xb1a <hdlc_decode+0xdc>
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
            wIdx++;
         }
      }
   }
   return HDLC_ERR_FRAME;
     b08:	8e ef       	ldi	r24, 0xFE	; 254
     b0a:	9f ef       	ldi	r25, 0xFF	; 255
     b0c:	08 c0       	rjmp	.+16     	; 0xb1e <hdlc_decode+0xe0>
            if (calcCrc == FCS_GOOD_FCS16) {
               // return length excluding CRC bytes
               return (wIdx - 2);
            }
            else {
               return HDLC_ERR_CRC;
     b0e:	8f ef       	ldi	r24, 0xFF	; 255
     b10:	9f ef       	ldi	r25, 0xFF	; 255
     b12:	05 c0       	rjmp	.+10     	; 0xb1e <hdlc_decode+0xe0>
            }
            else {
               pOut[wIdx] = curByte;
            }
            if (wIdx > maxOutLen) {
               return HDLC_ERR_LEN;
     b14:	8d ef       	ldi	r24, 0xFD	; 253
     b16:	9f ef       	ldi	r25, 0xFF	; 255
     b18:	02 c0       	rjmp	.+4      	; 0xb1e <hdlc_decode+0xe0>
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
            wIdx++;
         }
      }
   }
   return HDLC_ERR_FRAME;
     b1a:	8e ef       	ldi	r24, 0xFE	; 254
     b1c:	9f ef       	ldi	r25, 0xFF	; 255
}
     b1e:	df 91       	pop	r29
     b20:	cf 91       	pop	r28
     b22:	1f 91       	pop	r17
     b24:	0f 91       	pop	r16
     b26:	ff 90       	pop	r15
     b28:	ef 90       	pop	r14
     b2a:	df 90       	pop	r13
     b2c:	cf 90       	pop	r12
     b2e:	bf 90       	pop	r11
     b30:	af 90       	pop	r10
     b32:	9f 90       	pop	r9
     b34:	8f 90       	pop	r8
     b36:	7f 90       	pop	r7
     b38:	6f 90       	pop	r6
     b3a:	5f 90       	pop	r5
     b3c:	4f 90       	pop	r4
     b3e:	08 95       	ret

00000b40 <hdlc_stuffByte>:
 * Returns:
 *    Number of bytes written to destination (1 or 2 if escaped) 
 */
INT8U hdlc_stuffByte(INT8U* pDest, INT8U byte)
{
   if (byte == HDLC_FRAME_BYTE || byte == HDLC_ESCAPE_BYTE) {
     b40:	23 e8       	ldi	r18, 0x83	; 131
     b42:	26 0f       	add	r18, r22
     b44:	22 30       	cpi	r18, 0x02	; 2
     b46:	40 f4       	brcc	.+16     	; 0xb58 <hdlc_stuffByte+0x18>
      *pDest = HDLC_ESCAPE_BYTE;
     b48:	2d e7       	ldi	r18, 0x7D	; 125
     b4a:	fc 01       	movw	r30, r24
     b4c:	20 83       	st	Z, r18
      *(pDest+1) = byte ^ 0x20;
     b4e:	20 e2       	ldi	r18, 0x20	; 32
     b50:	62 27       	eor	r22, r18
     b52:	61 83       	std	Z+1, r22	; 0x01
      return 2;
     b54:	82 e0       	ldi	r24, 0x02	; 2
     b56:	08 95       	ret
   }
   else {
      *pDest = byte;
     b58:	fc 01       	movw	r30, r24
     b5a:	60 83       	st	Z, r22
      return 1;
     b5c:	81 e0       	ldi	r24, 0x01	; 1
   }
}
     b5e:	08 95       	ret

00000b60 <hdlc_encode_D>:
 *    maxOutLen: Max output length  
 * Returns:
 *    Number of bytes written to destination 
 */
INT32S hdlc_encode_D(INT8U* pOut, INT8U* pIn, INT32U inLen, INT32U maxOutLen)
{
     b60:	8f 92       	push	r8
     b62:	9f 92       	push	r9
     b64:	af 92       	push	r10
     b66:	bf 92       	push	r11
     b68:	cf 92       	push	r12
     b6a:	df 92       	push	r13
     b6c:	ef 92       	push	r14
     b6e:	ff 92       	push	r15
     b70:	0f 93       	push	r16
     b72:	1f 93       	push	r17
     b74:	cf 93       	push	r28
     b76:	df 93       	push	r29
     b78:	7c 01       	movw	r14, r24
     b7a:	5b 01       	movw	r10, r22
     b7c:	ea 01       	movw	r28, r20
     b7e:	69 01       	movw	r12, r18
   INT16U wIdx = 0;
   INT16U txFcs = 0;
   INT8U fcsHi, fcsLo;

   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);
     b80:	ba 01       	movw	r22, r20
     b82:	c5 01       	movw	r24, r10
     b84:	0e 94 02 05 	call	0xa04	; 0xa04 <fcs_calcFcs_D>
     b88:	88 2e       	mov	r8, r24
     b8a:	99 2e       	mov	r9, r25

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     b8c:	8e e7       	ldi	r24, 0x7E	; 126
     b8e:	f7 01       	movw	r30, r14
     b90:	80 83       	st	Z, r24
   for (i = 0; i < inLen; i++) {
     b92:	20 97       	sbiw	r28, 0x00	; 0
     b94:	c9 f0       	breq	.+50     	; 0xbc8 <hdlc_encode_D+0x68>
     b96:	85 01       	movw	r16, r10
     b98:	ac 0e       	add	r10, r28
     b9a:	bd 1e       	adc	r11, r29

   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     b9c:	c1 e0       	ldi	r28, 0x01	; 1
     b9e:	d0 e0       	ldi	r29, 0x00	; 0
   for (i = 0; i < inLen; i++) {
      wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  //wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
     ba0:	f4 e0       	ldi	r31, 0x04	; 4
     ba2:	cf 1a       	sub	r12, r31
     ba4:	d1 08       	sbc	r13, r1
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
      wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
     ba6:	f8 01       	movw	r30, r16
     ba8:	61 91       	ld	r22, Z+
     baa:	8f 01       	movw	r16, r30
     bac:	c7 01       	movw	r24, r14
     bae:	8c 0f       	add	r24, r28
     bb0:	9d 1f       	adc	r25, r29
     bb2:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     bb6:	c8 0f       	add	r28, r24
     bb8:	d1 1d       	adc	r29, r1
	  //wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
     bba:	cc 16       	cp	r12, r28
     bbc:	dd 06       	cpc	r13, r29
     bbe:	f0 f0       	brcs	.+60     	; 0xbfc <hdlc_encode_D+0x9c>
   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     bc0:	0a 15       	cp	r16, r10
     bc2:	1b 05       	cpc	r17, r11
     bc4:	81 f7       	brne	.-32     	; 0xba6 <hdlc_encode_D+0x46>
     bc6:	02 c0       	rjmp	.+4      	; 0xbcc <hdlc_encode_D+0x6c>

   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     bc8:	c1 e0       	ldi	r28, 0x01	; 1
     bca:	d0 e0       	ldi	r29, 0x00	; 0
   }
   
   // append CRC
   fcsHi = (txFcs & 0xFF);
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
     bcc:	68 2d       	mov	r22, r8
     bce:	c7 01       	movw	r24, r14
     bd0:	8c 0f       	add	r24, r28
     bd2:	9d 1f       	adc	r25, r29
     bd4:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     bd8:	c8 0f       	add	r28, r24
     bda:	d1 1d       	adc	r29, r1
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
     bdc:	69 2d       	mov	r22, r9
     bde:	c7 01       	movw	r24, r14
     be0:	8c 0f       	add	r24, r28
     be2:	9d 1f       	adc	r25, r29
     be4:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     be8:	c8 0f       	add	r28, r24
     bea:	d1 1d       	adc	r29, r1
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     bec:	f7 01       	movw	r30, r14
     bee:	ec 0f       	add	r30, r28
     bf0:	fd 1f       	adc	r31, r29
     bf2:	8e e7       	ldi	r24, 0x7E	; 126
     bf4:	80 83       	st	Z, r24
     bf6:	ce 01       	movw	r24, r28
     bf8:	01 96       	adiw	r24, 0x01	; 1
   return wIdx;
     bfa:	02 c0       	rjmp	.+4      	; 0xc00 <hdlc_encode_D+0xa0>
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
      wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  //wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
         return HDLC_ERR_LEN; 
     bfc:	8d ef       	ldi	r24, 0xFD	; 253
     bfe:	9f ef       	ldi	r25, 0xFF	; 255
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   return wIdx;
}
     c00:	df 91       	pop	r29
     c02:	cf 91       	pop	r28
     c04:	1f 91       	pop	r17
     c06:	0f 91       	pop	r16
     c08:	ff 90       	pop	r15
     c0a:	ef 90       	pop	r14
     c0c:	df 90       	pop	r13
     c0e:	cf 90       	pop	r12
     c10:	bf 90       	pop	r11
     c12:	af 90       	pop	r10
     c14:	9f 90       	pop	r9
     c16:	8f 90       	pop	r8
     c18:	08 95       	ret

00000c1a <hdlc_encode>:
 *    maxOutLen: Max output length  
 * Returns:
 *    Number of bytes written to destination 
 */
INT32S hdlc_encode(INT8U* pOut, INT8U* pIn, INT32U inLen, INT32U maxOutLen)
{
     c1a:	8f 92       	push	r8
     c1c:	9f 92       	push	r9
     c1e:	af 92       	push	r10
     c20:	bf 92       	push	r11
     c22:	cf 92       	push	r12
     c24:	df 92       	push	r13
     c26:	ef 92       	push	r14
     c28:	ff 92       	push	r15
     c2a:	0f 93       	push	r16
     c2c:	1f 93       	push	r17
     c2e:	cf 93       	push	r28
     c30:	df 93       	push	r29
     c32:	7c 01       	movw	r14, r24
     c34:	5b 01       	movw	r10, r22
     c36:	ea 01       	movw	r28, r20
     c38:	69 01       	movw	r12, r18
   INT16U wIdx = 0;
   INT16U txFcs = 0;
   INT8U fcsHi, fcsLo;

   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);
     c3a:	ba 01       	movw	r22, r20
     c3c:	c5 01       	movw	r24, r10
     c3e:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <fcs_calcFcs>
     c42:	88 2e       	mov	r8, r24
     c44:	99 2e       	mov	r9, r25

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     c46:	8e e7       	ldi	r24, 0x7E	; 126
     c48:	f7 01       	movw	r30, r14
     c4a:	80 83       	st	Z, r24
   for (i = 0; i < inLen; i++) {
     c4c:	20 97       	sbiw	r28, 0x00	; 0
     c4e:	d1 f0       	breq	.+52     	; 0xc84 <hdlc_encode+0x6a>
     c50:	85 01       	movw	r16, r10
     c52:	ac 0e       	add	r10, r28
     c54:	bd 1e       	adc	r11, r29

   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     c56:	c1 e0       	ldi	r28, 0x01	; 1
     c58:	d0 e0       	ldi	r29, 0x00	; 0
   for (i = 0; i < inLen; i++) {
     // wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(&pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
     c5a:	f4 e0       	ldi	r31, 0x04	; 4
     c5c:	cf 1a       	sub	r12, r31
     c5e:	d1 08       	sbc	r13, r1

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     // wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(&pIn[i]));
     c60:	f8 01       	movw	r30, r16
     c62:	64 91       	lpm	r22, Z
     c64:	c7 01       	movw	r24, r14
     c66:	8c 0f       	add	r24, r28
     c68:	9d 1f       	adc	r25, r29
     c6a:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     c6e:	c8 0f       	add	r28, r24
     c70:	d1 1d       	adc	r29, r1
      if (wIdx > (maxOutLen - 4)) {
     c72:	cc 16       	cp	r12, r28
     c74:	dd 06       	cpc	r13, r29
     c76:	00 f1       	brcs	.+64     	; 0xcb8 <hdlc_encode+0x9e>
     c78:	0f 5f       	subi	r16, 0xFF	; 255
     c7a:	1f 4f       	sbci	r17, 0xFF	; 255
   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     c7c:	0a 15       	cp	r16, r10
     c7e:	1b 05       	cpc	r17, r11
     c80:	79 f7       	brne	.-34     	; 0xc60 <hdlc_encode+0x46>
     c82:	02 c0       	rjmp	.+4      	; 0xc88 <hdlc_encode+0x6e>

   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     c84:	c1 e0       	ldi	r28, 0x01	; 1
     c86:	d0 e0       	ldi	r29, 0x00	; 0
   }
   
   // append CRC
   fcsHi = (txFcs & 0xFF);
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
     c88:	68 2d       	mov	r22, r8
     c8a:	c7 01       	movw	r24, r14
     c8c:	8c 0f       	add	r24, r28
     c8e:	9d 1f       	adc	r25, r29
     c90:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     c94:	c8 0f       	add	r28, r24
     c96:	d1 1d       	adc	r29, r1
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
     c98:	69 2d       	mov	r22, r9
     c9a:	c7 01       	movw	r24, r14
     c9c:	8c 0f       	add	r24, r28
     c9e:	9d 1f       	adc	r25, r29
     ca0:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     ca4:	c8 0f       	add	r28, r24
     ca6:	d1 1d       	adc	r29, r1
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     ca8:	f7 01       	movw	r30, r14
     caa:	ec 0f       	add	r30, r28
     cac:	fd 1f       	adc	r31, r29
     cae:	8e e7       	ldi	r24, 0x7E	; 126
     cb0:	80 83       	st	Z, r24
     cb2:	ce 01       	movw	r24, r28
     cb4:	01 96       	adiw	r24, 0x01	; 1
   return wIdx;
     cb6:	02 c0       	rjmp	.+4      	; 0xcbc <hdlc_encode+0xa2>
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     // wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(&pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
         return HDLC_ERR_LEN; 
     cb8:	8d ef       	ldi	r24, 0xFD	; 253
     cba:	9f ef       	ldi	r25, 0xFF	; 255
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   return wIdx;
}
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	1f 91       	pop	r17
     cc2:	0f 91       	pop	r16
     cc4:	ff 90       	pop	r15
     cc6:	ef 90       	pop	r14
     cc8:	df 90       	pop	r13
     cca:	cf 90       	pop	r12
     ccc:	bf 90       	pop	r11
     cce:	af 90       	pop	r10
     cd0:	9f 90       	pop	r9
     cd2:	8f 90       	pop	r8
     cd4:	08 95       	ret

00000cd6 <vLEDInit>:
{

	// Set LED_O as output pin

	//DDR_LED_O |= (1<<BIT_LED_O);
	DDR_LED_O |= 0xFF;
     cd6:	84 b1       	in	r24, 0x04	; 4
     cd8:	8f ef       	ldi	r24, 0xFF	; 255
     cda:	84 b9       	out	0x04, r24	; 4
     cdc:	08 95       	ret

00000cde <vLEDToggle>:

{

	//Toggle LED

	PORT_LED_O ^= (1<<BIT_LED_O);
     cde:	95 b1       	in	r25, 0x05	; 5
     ce0:	81 e0       	ldi	r24, 0x01	; 1
     ce2:	89 27       	eor	r24, r25
     ce4:	85 b9       	out	0x05, r24	; 5
     ce6:	08 95       	ret

00000ce8 <serialMoteReceive>:
	xSerialPutChar(NULL,tx,0x0010);
	
}

int8_t serialMoteReceive(void){
	return UDR0;
     ce8:	80 91 c6 00 	lds	r24, 0x00C6
}
     cec:	08 95       	ret

00000cee <xSerialPortInitMinimal>:



xComPortHandle xSerialPortInitMinimal( unsigned portBASE_TYPE uxQueueLength ){	
	
	portENTER_CRITICAL();
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	0f 92       	push	r0
	/* Create the queues used by the com test task. */
		//xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     cf4:	40 e0       	ldi	r20, 0x00	; 0
     cf6:	61 e0       	ldi	r22, 0x01	; 1
     cf8:	0e 94 83 0c 	call	0x1906	; 0x1906 <xQueueGenericCreate>
     cfc:	90 93 67 01 	sts	0x0167, r25
     d00:	80 93 66 01 	sts	0x0166, r24
		UBRR0 = UBRRMOTE;
     d04:	83 e0       	ldi	r24, 0x03	; 3
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	90 93 c5 00 	sts	0x00C5, r25
     d0c:	80 93 c4 00 	sts	0x00C4, r24
		//UCSR0A = (1<<U2X0);
		UCSR0B = (1<<TXEN0)|(1<<RXEN0)|(1<<RXCIE0);                // enable receiver and transmitter
     d10:	88 e9       	ldi	r24, 0x98	; 152
     d12:	80 93 c1 00 	sts	0x00C1, r24
		UCSR0C = (1<<UCSZ00)|(1<<UCSZ01);   // 8bit data format
     d16:	86 e0       	ldi	r24, 0x06	; 6
     d18:	80 93 c2 00 	sts	0x00C2, r24
		//Enable interrupts for  TX later
		
	frameHandle = xSemaphoreCreateBinary();
     d1c:	43 e0       	ldi	r20, 0x03	; 3
     d1e:	60 e0       	ldi	r22, 0x00	; 0
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	0e 94 83 0c 	call	0x1906	; 0x1906 <xQueueGenericCreate>
     d26:	90 93 cf 07 	sts	0x07CF, r25
     d2a:	80 93 ce 07 	sts	0x07CE, r24

	portEXIT_CRITICAL();
     d2e:	0f 90       	pop	r0
     d30:	0f be       	out	0x3f, r0	; 63

	instead just return NULL. */

	return NULL;

}
     d32:	80 e0       	ldi	r24, 0x00	; 0
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	08 95       	ret

00000d38 <xSerialPutChar>:



signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )

{
     d38:	cf 93       	push	r28
     d3a:	df 93       	push	r29
     d3c:	1f 92       	push	r1
     d3e:	cd b7       	in	r28, 0x3d	; 61
     d40:	de b7       	in	r29, 0x3e	; 62
     d42:	69 83       	std	Y+1, r22	; 0x01



	/* Return false if after the block time there is no room on the Tx queue. */

	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     d44:	20 e0       	ldi	r18, 0x00	; 0
     d46:	be 01       	movw	r22, r28
     d48:	6f 5f       	subi	r22, 0xFF	; 255
     d4a:	7f 4f       	sbci	r23, 0xFF	; 255
     d4c:	80 91 66 01 	lds	r24, 0x0166
     d50:	90 91 67 01 	lds	r25, 0x0167
     d54:	0e 94 b1 0c 	call	0x1962	; 0x1962 <xQueueGenericSend>
     d58:	81 30       	cpi	r24, 0x01	; 1
     d5a:	31 f4       	brne	.+12     	; 0xd68 <xSerialPutChar+0x30>
	



	//vInterruptOn();
	UCSR0B |= (1<<UDRIE0);
     d5c:	e1 ec       	ldi	r30, 0xC1	; 193
     d5e:	f0 e0       	ldi	r31, 0x00	; 0
     d60:	90 81       	ld	r25, Z
     d62:	90 62       	ori	r25, 0x20	; 32
     d64:	90 83       	st	Z, r25
	return pdPASS;
     d66:	01 c0       	rjmp	.+2      	; 0xd6a <xSerialPutChar+0x32>
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )

	{
		

		return pdFAIL;
     d68:	80 e0       	ldi	r24, 0x00	; 0

	//vInterruptOn();
	UCSR0B |= (1<<UDRIE0);
	return pdPASS;

}
     d6a:	0f 90       	pop	r0
     d6c:	df 91       	pop	r29
     d6e:	cf 91       	pop	r28
     d70:	08 95       	ret

00000d72 <serialMoteSend>:

}

void serialMoteSend(int8_t tx){
	
	xSerialPutChar(NULL,tx,0x0010);
     d72:	40 e1       	ldi	r20, 0x10	; 16
     d74:	50 e0       	ldi	r21, 0x00	; 0
     d76:	68 2f       	mov	r22, r24
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	0e 94 9c 06 	call	0xd38	; 0xd38 <xSerialPutChar>
     d80:	08 95       	ret

00000d82 <__vector_18>:

/*-----------------------------------------------------------*/
/*-----------------------------------------------------------*/
ISR( USART_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART_RX_vect )
{
     d82:	1f 92       	push	r1
     d84:	0f 92       	push	r0
     d86:	0f b6       	in	r0, 0x3f	; 63
     d88:	0f 92       	push	r0
     d8a:	11 24       	eor	r1, r1
     d8c:	2f 93       	push	r18
     d8e:	3f 93       	push	r19
     d90:	4f 93       	push	r20
     d92:	5f 93       	push	r21
     d94:	6f 93       	push	r22
     d96:	7f 93       	push	r23
     d98:	8f 93       	push	r24
     d9a:	9f 93       	push	r25
     d9c:	af 93       	push	r26
     d9e:	bf 93       	push	r27
     da0:	ef 93       	push	r30
     da2:	ff 93       	push	r31

	may have a higher priority than the task we have interrupted. */
	//PORTB ^= (1<<PORTB1);
	
	
	if( InterruptReception(&moteData)){//check to see if a valid frame has been received
     da4:	80 ed       	ldi	r24, 0xD0	; 208
     da6:	97 e0       	ldi	r25, 0x07	; 7
     da8:	0e 94 2f 02 	call	0x45e	; 0x45e <InterruptReception>
     dac:	88 23       	and	r24, r24
     dae:	41 f0       	breq	.+16     	; 0xdc0 <__vector_18+0x3e>
		
		xSemaphoreGiveFromISR(frameHandle,NULL);
     db0:	60 e0       	ldi	r22, 0x00	; 0
     db2:	70 e0       	ldi	r23, 0x00	; 0
     db4:	80 91 ce 07 	lds	r24, 0x07CE
     db8:	90 91 cf 07 	lds	r25, 0x07CF
     dbc:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <xQueueGiveFromISR>

		taskYIELD();

	}

}
     dc0:	ff 91       	pop	r31
     dc2:	ef 91       	pop	r30
     dc4:	bf 91       	pop	r27
     dc6:	af 91       	pop	r26
     dc8:	9f 91       	pop	r25
     dca:	8f 91       	pop	r24
     dcc:	7f 91       	pop	r23
     dce:	6f 91       	pop	r22
     dd0:	5f 91       	pop	r21
     dd2:	4f 91       	pop	r20
     dd4:	3f 91       	pop	r19
     dd6:	2f 91       	pop	r18
     dd8:	0f 90       	pop	r0
     dda:	0f be       	out	0x3f, r0	; 63
     ddc:	0f 90       	pop	r0
     dde:	1f 90       	pop	r1
     de0:	18 95       	reti

00000de2 <__vector_19>:

/*-----------------------------------------------------------*/

ISR( USART_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART_UDRE_vect )
{
     de2:	1f 92       	push	r1
     de4:	0f 92       	push	r0
     de6:	0f b6       	in	r0, 0x3f	; 63
     de8:	0f 92       	push	r0
     dea:	11 24       	eor	r1, r1
     dec:	2f 93       	push	r18
     dee:	3f 93       	push	r19
     df0:	4f 93       	push	r20
     df2:	5f 93       	push	r21
     df4:	6f 93       	push	r22
     df6:	7f 93       	push	r23
     df8:	8f 93       	push	r24
     dfa:	9f 93       	push	r25
     dfc:	af 93       	push	r26
     dfe:	bf 93       	push	r27
     e00:	ef 93       	push	r30
     e02:	ff 93       	push	r31
     e04:	cf 93       	push	r28
     e06:	df 93       	push	r29
     e08:	1f 92       	push	r1
     e0a:	cd b7       	in	r28, 0x3d	; 61
     e0c:	de b7       	in	r29, 0x3e	; 62

signed char cChar, cTaskWoken;
PORTB |= (1<<PORTB2);
     e0e:	2a 9a       	sbi	0x05, 2	; 5

	if( xQueueReceiveFromISR( xCharsForTx, &cChar,NULL) == pdTRUE )
     e10:	40 e0       	ldi	r20, 0x00	; 0
     e12:	50 e0       	ldi	r21, 0x00	; 0
     e14:	be 01       	movw	r22, r28
     e16:	6f 5f       	subi	r22, 0xFF	; 255
     e18:	7f 4f       	sbci	r23, 0xFF	; 255
     e1a:	80 91 66 01 	lds	r24, 0x0166
     e1e:	90 91 67 01 	lds	r25, 0x0167
     e22:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xQueueReceiveFromISR>
     e26:	81 30       	cpi	r24, 0x01	; 1
     e28:	21 f4       	brne	.+8      	; 0xe32 <__vector_19+0x50>
	{
		/* Send the next character queued for Tx. */
    	UDR0 = cChar;
     e2a:	89 81       	ldd	r24, Y+1	; 0x01
     e2c:	80 93 c6 00 	sts	0x00C6, r24
     e30:	05 c0       	rjmp	.+10     	; 0xe3c <__vector_19+0x5a>
	}
	else
	{/* Queue empty, nothing to send. */
	//vInterruptOff();
	UCSR0B &= ~(1<<UDRIE0);		
     e32:	e1 ec       	ldi	r30, 0xC1	; 193
     e34:	f0 e0       	ldi	r31, 0x00	; 0
     e36:	80 81       	ld	r24, Z
     e38:	8f 7d       	andi	r24, 0xDF	; 223
     e3a:	80 83       	st	Z, r24
	}

}
     e3c:	0f 90       	pop	r0
     e3e:	df 91       	pop	r29
     e40:	cf 91       	pop	r28
     e42:	ff 91       	pop	r31
     e44:	ef 91       	pop	r30
     e46:	bf 91       	pop	r27
     e48:	af 91       	pop	r26
     e4a:	9f 91       	pop	r25
     e4c:	8f 91       	pop	r24
     e4e:	7f 91       	pop	r23
     e50:	6f 91       	pop	r22
     e52:	5f 91       	pop	r21
     e54:	4f 91       	pop	r20
     e56:	3f 91       	pop	r19
     e58:	2f 91       	pop	r18
     e5a:	0f 90       	pop	r0
     e5c:	0f be       	out	0x3f, r0	; 63
     e5e:	0f 90       	pop	r0
     e60:	1f 90       	pop	r1
     e62:	18 95       	reti

00000e64 <sendMoteData>:
	return UDR0;
}

uint8_t sendMoteData(uint8_t* data, uint8_t data_size){
	
	return sendData(data,data_size,serviceID,&moteData);
     e64:	20 ed       	ldi	r18, 0xD0	; 208
     e66:	37 e0       	ldi	r19, 0x07	; 7
     e68:	42 e0       	ldi	r20, 0x02	; 2
     e6a:	0e 94 75 04 	call	0x8ea	; 0x8ea <sendData>
	
	
}
     e6e:	08 95       	ret

00000e70 <configureMote>:


void configureMote(void){
	
	
	moteData.serialMoteSend=serialMoteSend; 
     e70:	89 eb       	ldi	r24, 0xB9	; 185
     e72:	96 e0       	ldi	r25, 0x06	; 6
     e74:	90 93 d1 07 	sts	0x07D1, r25
     e78:	80 93 d0 07 	sts	0x07D0, r24
	moteData.serialMoteReceive=serialMoteReceive;
     e7c:	84 e7       	ldi	r24, 0x74	; 116
     e7e:	96 e0       	ldi	r25, 0x06	; 6
     e80:	90 93 d3 07 	sts	0x07D3, r25
     e84:	80 93 d2 07 	sts	0x07D2, r24
	
	DDRC = (1<<PORTC0)|(1<<PORTC1); // select pc0 and pc1 as outputs
     e88:	83 e0       	ldi	r24, 0x03	; 3
     e8a:	87 b9       	out	0x07, r24	; 7
	//pc0 drives the reset on the whmt, pc1 is the led indication
	
	PORTC = (1<<PORTC2);//Pull up on the button, reset the mote
     e8c:	84 e0       	ldi	r24, 0x04	; 4
     e8e:	88 b9       	out	0x08, r24	; 8
	
	vTaskDelay(200);
     e90:	88 ec       	ldi	r24, 0xC8	; 200
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskDelay>
	
	PORTC |= (1<<PORTC0);// turn on the mote
     e98:	40 9a       	sbi	0x08, 0	; 8
	
	MoteInitialization(&moteData);
     e9a:	80 ed       	ldi	r24, 0xD0	; 208
     e9c:	97 e0       	ldi	r25, 0x07	; 7
     e9e:	0e 94 a3 02 	call	0x546	; 0x546 <MoteInitialization>
	MoteSvcInitialization(&moteData);
     ea2:	80 ed       	ldi	r24, 0xD0	; 208
     ea4:	97 e0       	ldi	r25, 0x07	; 7
     ea6:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <MoteSvcInitialization>
	
	PORTC |= (1<<PORTC1); //turn on LED, the Mote is ready to send
     eaa:	41 9a       	sbi	0x08, 1	; 8
     eac:	08 95       	ret

00000eae <TWI_Master_Initialise>:
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
	TWSR = 0; //no prescaler
     eae:	10 92 b9 00 	sts	0x00B9, r1
	TWBR = 29;// 100 Khz                             //
     eb2:	8d e1       	ldi	r24, 0x1D	; 29
     eb4:	80 93 b8 00 	sts	0x00B8, r24
     eb8:	08 95       	ret

00000eba <TWI_Start_Transceiver_With_Data>:
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
	//return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
	return twi_done;
     eba:	20 91 6a 01 	lds	r18, 0x016A
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
	unsigned char temp;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     ebe:	21 11       	cpse	r18, r1
     ec0:	fc cf       	rjmp	.-8      	; 0xeba <TWI_Start_Transceiver_With_Data>

	TWI_msgSize = msgSize;                        // Number of data to transmit.
     ec2:	60 93 63 08 	sts	0x0863, r22
	TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
     ec6:	fc 01       	movw	r30, r24
     ec8:	20 81       	ld	r18, Z
     eca:	20 93 64 08 	sts	0x0864, r18
	if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
     ece:	20 81       	ld	r18, Z
     ed0:	20 fd       	sbrc	r18, 0
     ed2:	12 c0       	rjmp	.+36     	; 0xef8 <TWI_Start_Transceiver_With_Data+0x3e>
	{
		for ( temp = 1; temp < msgSize; temp++ )
     ed4:	62 30       	cpi	r22, 0x02	; 2
     ed6:	80 f0       	brcs	.+32     	; 0xef8 <TWI_Start_Transceiver_With_Data+0x3e>
     ed8:	31 96       	adiw	r30, 0x01	; 1
     eda:	9c 01       	movw	r18, r24
     edc:	02 96       	adiw	r24, 0x02	; 2
     ede:	62 50       	subi	r22, 0x02	; 2
     ee0:	86 0f       	add	r24, r22
     ee2:	91 1d       	adc	r25, r1
     ee4:	df 01       	movw	r26, r30
     ee6:	a2 1b       	sub	r26, r18
     ee8:	b3 0b       	sbc	r27, r19
		TWI_buf[ temp ] = msg[ temp ];
     eea:	41 91       	ld	r20, Z+
     eec:	ac 59       	subi	r26, 0x9C	; 156
     eee:	b7 4f       	sbci	r27, 0xF7	; 247
     ef0:	4c 93       	st	X, r20

	TWI_msgSize = msgSize;                        // Number of data to transmit.
	TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	{
		for ( temp = 1; temp < msgSize; temp++ )
     ef2:	e8 17       	cp	r30, r24
     ef4:	f9 07       	cpc	r31, r25
     ef6:	b1 f7       	brne	.-20     	; 0xee4 <TWI_Start_Transceiver_With_Data+0x2a>
		TWI_buf[ temp ] = msg[ temp ];
	}
	TWI_statusReg.all = 0;
     ef8:	10 92 69 01 	sts	0x0169, r1
	TWI_state         = TWI_NO_STATE ;
     efc:	88 ef       	ldi	r24, 0xF8	; 248
     efe:	80 93 00 01 	sts	0x0100, r24
	TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     f02:	85 ea       	ldi	r24, 0xA5	; 165
     f04:	80 93 bc 00 	sts	0x00BC, r24
	(1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
	(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
	(0<<TWWC);                             //
	twi_done=1;
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	80 93 6a 01 	sts	0x016A, r24
     f0e:	08 95       	ret

00000f10 <TWI_Get_Data_From_Transceiver>:
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
	//return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
	return twi_done;
     f10:	20 91 6a 01 	lds	r18, 0x016A
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
	unsigned char i;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     f14:	21 11       	cpse	r18, r1
     f16:	fc cf       	rjmp	.-8      	; 0xf10 <TWI_Get_Data_From_Transceiver>

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.
     f18:	20 91 69 01 	lds	r18, 0x0169
     f1c:	20 ff       	sbrs	r18, 0
     f1e:	0e c0       	rjmp	.+28     	; 0xf3c <TWI_Get_Data_From_Transceiver+0x2c>
	{
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     f20:	66 23       	and	r22, r22
     f22:	61 f0       	breq	.+24     	; 0xf3c <TWI_Get_Data_From_Transceiver+0x2c>
     f24:	e8 2f       	mov	r30, r24
     f26:	f9 2f       	mov	r31, r25
     f28:	80 e0       	ldi	r24, 0x00	; 0
     f2a:	90 e0       	ldi	r25, 0x00	; 0
		{
			msg[ i ] = TWI_buf[ i ];
     f2c:	dc 01       	movw	r26, r24
     f2e:	ac 59       	subi	r26, 0x9C	; 156
     f30:	b7 4f       	sbci	r27, 0xF7	; 247
     f32:	2c 91       	ld	r18, X
     f34:	21 93       	st	Z+, r18
     f36:	01 96       	adiw	r24, 0x01	; 1

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.
	{
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     f38:	86 17       	cp	r24, r22
     f3a:	c0 f3       	brcs	.-16     	; 0xf2c <TWI_Get_Data_From_Transceiver+0x1c>
		{
			msg[ i ] = TWI_buf[ i ];
		}
	}
	return( TWI_statusReg.lastTransOK );
     f3c:	80 91 69 01 	lds	r24, 0x0169
}
     f40:	81 70       	andi	r24, 0x01	; 1
     f42:	08 95       	ret

00000f44 <__vector_24>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR (TWI_vect) __attribute__ ((hot, flatten));
ISR (TWI_vect)
{
     f44:	1f 92       	push	r1
     f46:	0f 92       	push	r0
     f48:	0f b6       	in	r0, 0x3f	; 63
     f4a:	0f 92       	push	r0
     f4c:	11 24       	eor	r1, r1
     f4e:	2f 93       	push	r18
     f50:	3f 93       	push	r19
     f52:	8f 93       	push	r24
     f54:	9f 93       	push	r25
     f56:	af 93       	push	r26
     f58:	bf 93       	push	r27
     f5a:	ef 93       	push	r30
     f5c:	ff 93       	push	r31
	static unsigned char TWI_bufPtr=0;
	
	switch (TWSR)
     f5e:	80 91 b9 00 	lds	r24, 0x00B9
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	fc 01       	movw	r30, r24
     f66:	38 97       	sbiw	r30, 0x08	; 8
     f68:	e1 35       	cpi	r30, 0x51	; 81
     f6a:	f1 05       	cpc	r31, r1
     f6c:	08 f0       	brcs	.+2      	; 0xf70 <__vector_24+0x2c>
     f6e:	65 c0       	rjmp	.+202    	; 0x103a <__vector_24+0xf6>
     f70:	ec 5c       	subi	r30, 0xCC	; 204
     f72:	ff 4f       	sbci	r31, 0xFF	; 255
     f74:	0c 94 a9 12 	jmp	0x2552	; 0x2552 <__tablejump2__>
	{
		case TWI_START:             // START has been transmitted
		case TWI_REP_START:         // Repeated START has been transmitted
		TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
     f78:	10 92 68 01 	sts	0x0168, r1
		case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
		case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
		if (TWI_bufPtr < TWI_msgSize)
     f7c:	e0 91 68 01 	lds	r30, 0x0168
     f80:	80 91 63 08 	lds	r24, 0x0863
     f84:	e8 17       	cp	r30, r24
     f86:	80 f4       	brcc	.+32     	; 0xfa8 <__vector_24+0x64>
		{
			twi_done=1;
     f88:	81 e0       	ldi	r24, 0x01	; 1
     f8a:	80 93 6a 01 	sts	0x016A, r24
			TWDR = TWI_buf[TWI_bufPtr++];
     f8e:	8e 0f       	add	r24, r30
     f90:	80 93 68 01 	sts	0x0168, r24
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	ec 59       	subi	r30, 0x9C	; 156
     f98:	f7 4f       	sbci	r31, 0xF7	; 247
     f9a:	80 81       	ld	r24, Z
     f9c:	80 93 bb 00 	sts	0x00BB, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     fa0:	85 e8       	ldi	r24, 0x85	; 133
     fa2:	80 93 bc 00 	sts	0x00BC, r24
     fa6:	52 c0       	rjmp	.+164    	; 0x104c <__vector_24+0x108>
			(1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
			(0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
			TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully.
     fa8:	80 91 69 01 	lds	r24, 0x0169
     fac:	81 60       	ori	r24, 0x01	; 1
     fae:	80 93 69 01 	sts	0x0169, r24
			twi_done=0;
     fb2:	10 92 6a 01 	sts	0x016A, r1
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     fb6:	84 e9       	ldi	r24, 0x94	; 148
     fb8:	80 93 bc 00 	sts	0x00BC, r24
     fbc:	47 c0       	rjmp	.+142    	; 0x104c <__vector_24+0x108>
			(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			(0<<TWWC);                                 //
		}
		break;
		case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
		TWI_buf[TWI_bufPtr++] = TWDR;
     fbe:	e0 91 68 01 	lds	r30, 0x0168
     fc2:	81 e0       	ldi	r24, 0x01	; 1
     fc4:	8e 0f       	add	r24, r30
     fc6:	80 93 68 01 	sts	0x0168, r24
     fca:	f0 e0       	ldi	r31, 0x00	; 0
     fcc:	80 91 bb 00 	lds	r24, 0x00BB
     fd0:	ec 59       	subi	r30, 0x9C	; 156
     fd2:	f7 4f       	sbci	r31, 0xF7	; 247
     fd4:	80 83       	st	Z, r24
		case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
		if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
     fd6:	80 91 63 08 	lds	r24, 0x0863
     fda:	20 91 68 01 	lds	r18, 0x0168
     fde:	30 e0       	ldi	r19, 0x00	; 0
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	01 97       	sbiw	r24, 0x01	; 1
     fe4:	28 17       	cp	r18, r24
     fe6:	39 07       	cpc	r19, r25
     fe8:	3c f4       	brge	.+14     	; 0xff8 <__vector_24+0xb4>
		{
			twi_done =1;
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	80 93 6a 01 	sts	0x016A, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     ff0:	85 ec       	ldi	r24, 0xC5	; 197
     ff2:	80 93 bc 00 	sts	0x00BC, r24
     ff6:	2a c0       	rjmp	.+84     	; 0x104c <__vector_24+0x108>
			(1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
			(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
			(0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			twi_done=1;
     ff8:	81 e0       	ldi	r24, 0x01	; 1
     ffa:	80 93 6a 01 	sts	0x016A, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     ffe:	85 e8       	ldi	r24, 0x85	; 133
    1000:	80 93 bc 00 	sts	0x00BC, r24
    1004:	23 c0       	rjmp	.+70     	; 0x104c <__vector_24+0x108>
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
			(0<<TWWC);                                 //
		}
		break;
		case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
		TWI_buf[TWI_bufPtr] = TWDR;
    1006:	e0 91 68 01 	lds	r30, 0x0168
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	80 91 bb 00 	lds	r24, 0x00BB
    1010:	ec 59       	subi	r30, 0x9C	; 156
    1012:	f7 4f       	sbci	r31, 0xF7	; 247
    1014:	80 83       	st	Z, r24
		TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully.
    1016:	80 91 69 01 	lds	r24, 0x0169
    101a:	81 60       	ori	r24, 0x01	; 1
    101c:	80 93 69 01 	sts	0x0169, r24
		twi_done=0;
    1020:	10 92 6a 01 	sts	0x016A, r1
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1024:	84 e9       	ldi	r24, 0x94	; 148
    1026:	80 93 bc 00 	sts	0x00BC, r24
		(0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
		(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
		(0<<TWWC);                                 //
		break;
    102a:	10 c0       	rjmp	.+32     	; 0x104c <__vector_24+0x108>
		case TWI_ARB_LOST:          // Arbitration lost
		twi_done=1;
    102c:	81 e0       	ldi	r24, 0x01	; 1
    102e:	80 93 6a 01 	sts	0x016A, r24
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1032:	85 ea       	ldi	r24, 0xA5	; 165
    1034:	80 93 bc 00 	sts	0x00BC, r24
		(1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
		(0<<TWWC);                                 //
		break;
    1038:	09 c0       	rjmp	.+18     	; 0x104c <__vector_24+0x108>
		case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received
		case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
		//    case TWI_NO_STATE              // No relevant state information available; TWINT
		case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
		default:
		twi_done=0;
    103a:	10 92 6a 01 	sts	0x016A, r1
		TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    103e:	80 91 b9 00 	lds	r24, 0x00B9
    1042:	80 93 00 01 	sts	0x0100, r24
		// Reset TWI Interface
		TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    1046:	84 e0       	ldi	r24, 0x04	; 4
    1048:	80 93 bc 00 	sts	0x00BC, r24
		(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
		(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
		(0<<TWWC);                                 //
	}
}
    104c:	ff 91       	pop	r31
    104e:	ef 91       	pop	r30
    1050:	bf 91       	pop	r27
    1052:	af 91       	pop	r26
    1054:	9f 91       	pop	r25
    1056:	8f 91       	pop	r24
    1058:	3f 91       	pop	r19
    105a:	2f 91       	pop	r18
    105c:	0f 90       	pop	r0
    105e:	0f be       	out	0x3f, r0	; 63
    1060:	0f 90       	pop	r0
    1062:	1f 90       	pop	r1
    1064:	18 95       	reti

00001066 <main>:



portSHORT main(void)
{
	startCommTasks(mainComm_TASK_PRIORITY);
    1066:	82 e0       	ldi	r24, 0x02	; 2
    1068:	0e 94 03 02 	call	0x406	; 0x406 <startCommTasks>
    startSensorTasks( mainSensor_TASK_PRIORITY);
    106c:	82 e0       	ldi	r24, 0x02	; 2
    106e:	0e 94 2d 09 	call	0x125a	; 0x125a <startSensorTasks>
	
	xTaskCreate( vLEDFlashTask, ( signed char * ) "LED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
    1072:	a1 2c       	mov	r10, r1
    1074:	b1 2c       	mov	r11, r1
    1076:	c1 2c       	mov	r12, r1
    1078:	d1 2c       	mov	r13, r1
    107a:	e1 2c       	mov	r14, r1
    107c:	f1 2c       	mov	r15, r1
    107e:	01 e0       	ldi	r16, 0x01	; 1
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	45 e5       	ldi	r20, 0x55	; 85
    1086:	50 e0       	ldi	r21, 0x00	; 0
    1088:	66 e1       	ldi	r22, 0x16	; 22
    108a:	71 e0       	ldi	r23, 0x01	; 1
    108c:	8d e4       	ldi	r24, 0x4D	; 77
    108e:	98 e0       	ldi	r25, 0x08	; 8
    1090:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskGenericCreate>

	//start scheduler

	vTaskStartScheduler();
    1094:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <vTaskStartScheduler>
    1098:	ff cf       	rjmp	.-2      	; 0x1098 <main+0x32>

0000109a <vLEDFlashTask>:
#include "FreeRTOS.h"
#include "task.h"
#include "Drivers/LED.h"
#include "mytasks.h"

void vLEDFlashTask( void *pvParameters ){
    109a:	cf 93       	push	r28
    109c:	df 93       	push	r29
    109e:	00 d0       	rcall	.+0      	; 0x10a0 <vLEDFlashTask+0x6>
    10a0:	cd b7       	in	r28, 0x3d	; 61
    10a2:	de b7       	in	r29, 0x3e	; 62

	vLEDInit();
    10a4:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vLEDInit>

	portTickType xLastWakeTime;

	const portTickType xFrequency = 1000;

	xLastWakeTime=xTaskGetTickCount();
    10a8:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <xTaskGetTickCount>
    10ac:	9a 83       	std	Y+2, r25	; 0x02
    10ae:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )	{

		vLEDToggle();
    10b0:	0e 94 6f 06 	call	0xcde	; 0xcde <vLEDToggle>

		vTaskDelayUntil(&xLastWakeTime,xFrequency);
    10b4:	68 ee       	ldi	r22, 0xE8	; 232
    10b6:	73 e0       	ldi	r23, 0x03	; 3
    10b8:	ce 01       	movw	r24, r28
    10ba:	01 96       	adiw	r24, 0x01	; 1
    10bc:	0e 94 42 11 	call	0x2284	; 0x2284 <vTaskDelayUntil>
    10c0:	f7 cf       	rjmp	.-18     	; 0x10b0 <vLEDFlashTask+0x16>

000010c2 <xSensorTask>:
	xSemaphoreGiveFromISR(dataReadySemaphore,NULL);
}



void xSensorTask (void* pvParameters){
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
    10c6:	cd b7       	in	r28, 0x3d	; 61
    10c8:	de b7       	in	r29, 0x3e	; 62
    10ca:	2c 97       	sbiw	r28, 0x0c	; 12
    10cc:	0f b6       	in	r0, 0x3f	; 63
    10ce:	f8 94       	cli
    10d0:	de bf       	out	0x3e, r29	; 62
    10d2:	0f be       	out	0x3f, r0	; 63
    10d4:	cd bf       	out	0x3d, r28	; 61
	static uint8_t sensorData[NUMBER_OF_BYTES_TO_SEND];
	uint8_t messages=0;
	uint8_t *pSensorData;
	
	
	DataToSend = xQueueCreate(1,sizeof(uint8_t*));
    10d6:	40 e0       	ldi	r20, 0x00	; 0
    10d8:	62 e0       	ldi	r22, 0x02	; 2
    10da:	81 e0       	ldi	r24, 0x01	; 1
    10dc:	0e 94 83 0c 	call	0x1906	; 0x1906 <xQueueGenericCreate>
    10e0:	90 93 71 08 	sts	0x0871, r25
    10e4:	80 93 70 08 	sts	0x0870, r24
	//only 1 element in queue, pointer to data
	dataReadySemaphore = xSemaphoreCreateBinary();
    10e8:	43 e0       	ldi	r20, 0x03	; 3
    10ea:	60 e0       	ldi	r22, 0x00	; 0
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	0e 94 83 0c 	call	0x1906	; 0x1906 <xQueueGenericCreate>
    10f2:	90 93 6f 08 	sts	0x086F, r25
    10f6:	80 93 6e 08 	sts	0x086E, r24
	//create semaphore for dataReady, the sensorTask will block on this semaphore
	while(xSemaphoreTake(moteReadySemaphore,0xFFFF) != pdTRUE);
    10fa:	20 e0       	ldi	r18, 0x00	; 0
    10fc:	4f ef       	ldi	r20, 0xFF	; 255
    10fe:	5f ef       	ldi	r21, 0xFF	; 255
    1100:	60 e0       	ldi	r22, 0x00	; 0
    1102:	70 e0       	ldi	r23, 0x00	; 0
    1104:	80 91 cc 07 	lds	r24, 0x07CC
    1108:	90 91 cd 07 	lds	r25, 0x07CD
    110c:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
    1110:	81 30       	cpi	r24, 0x01	; 1
    1112:	99 f7       	brne	.-26     	; 0x10fa <xSensorTask+0x38>
	//wait a long time for mote to be ready to send
	
	
	DDRD &= ~(1<<PORTD2); // as input
    1114:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<PORTD2); // pull up
    1116:	5a 9a       	sbi	0x0b, 2	; 11
	EIMSK |= (1<<INT0); //enable external Interrupt 0 for Data ready Pin
    1118:	e8 9a       	sbi	0x1d, 0	; 29
	EICRA |= (1<<ISC01);//the falling edge generates the interrupt
    111a:	e9 e6       	ldi	r30, 0x69	; 105
    111c:	f0 e0       	ldi	r31, 0x00	; 0
    111e:	80 81       	ld	r24, Z
    1120:	82 60       	ori	r24, 0x02	; 2
    1122:	80 83       	st	Z, r24
	
	
	TWI_Master_Initialise();
    1124:	0e 94 57 07 	call	0xeae	; 0xeae <TWI_Master_Initialise>
	
	uint8_t sensorConfig[10];
	//(8-average, 15 Hz default, normal measurement)
	sensorConfig[0]=SLAVE_SENSOR_W;
    1128:	1c e3       	ldi	r17, 0x3C	; 60
    112a:	1b 83       	std	Y+3, r17	; 0x03
	sensorConfig[1]=CRA;
    112c:	1c 82       	std	Y+4, r1	; 0x04
	sensorConfig[2]=0x70;//(8-average, 15 Hz default, normal measurement)
    112e:	80 e7       	ldi	r24, 0x70	; 112
    1130:	8d 83       	std	Y+5, r24	; 0x05
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
    1132:	63 e0       	ldi	r22, 0x03	; 3
    1134:	ce 01       	movw	r24, r28
    1136:	03 96       	adiw	r24, 0x03	; 3
    1138:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
	vTaskDelay(100);
    113c:	84 e6       	ldi	r24, 0x64	; 100
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskDelay>
	sensorConfig[0]=SLAVE_SENSOR_W;
    1144:	1b 83       	std	Y+3, r17	; 0x03
	sensorConfig[1]=CRB;
    1146:	01 e0       	ldi	r16, 0x01	; 1
    1148:	0c 83       	std	Y+4, r16	; 0x04
	sensorConfig[2]= 0xA0; //(Gain=5, or any  other desired gain
    114a:	80 ea       	ldi	r24, 0xA0	; 160
    114c:	8d 83       	std	Y+5, r24	; 0x05
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
    114e:	63 e0       	ldi	r22, 0x03	; 3
    1150:	ce 01       	movw	r24, r28
    1152:	03 96       	adiw	r24, 0x03	; 3
    1154:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
	vTaskDelay(100);
    1158:	84 e6       	ldi	r24, 0x64	; 100
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskDelay>
	sensorConfig[0]=SLAVE_SENSOR_W;
    1160:	1b 83       	std	Y+3, r17	; 0x03
	sensorConfig[1]=MODE_REGISTER;
    1162:	82 e0       	ldi	r24, 0x02	; 2
    1164:	8c 83       	std	Y+4, r24	; 0x04
	sensorConfig[2]=0x01; // single measurement mode
    1166:	0d 83       	std	Y+5, r16	; 0x05
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
    1168:	63 e0       	ldi	r22, 0x03	; 3
    116a:	ce 01       	movw	r24, r28
    116c:	03 96       	adiw	r24, 0x03	; 3
    116e:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
	vTaskDelay(100);
    1172:	84 e6       	ldi	r24, 0x64	; 100
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskDelay>


void xSensorTask (void* pvParameters){
	
	static uint8_t sensorData[NUMBER_OF_BYTES_TO_SEND];
	uint8_t messages=0;
    117a:	d1 2c       	mov	r13, r1
		
		
		if (xSemaphoreTake(dataReadySemaphore,0xFFFF))//Block on sensor interrupt
		{
			
			sensorConfig[0]=SLAVE_SENSOR_R;
    117c:	0f 2e       	mov	r0, r31
    117e:	fd e3       	ldi	r31, 0x3D	; 61
    1180:	8f 2e       	mov	r8, r31
    1182:	f0 2d       	mov	r31, r0
			sensorConfig[1]=DATA_OUTPUT_REGISTER; //Start with X MSB register
    1184:	0f 2e       	mov	r0, r31
    1186:	f3 e0       	ldi	r31, 0x03	; 3
    1188:	cf 2e       	mov	r12, r31
    118a:	f0 2d       	mov	r31, r0
    118c:	8e 01       	movw	r16, r28
    118e:	05 5f       	subi	r16, 0xF5	; 245
    1190:	1f 4f       	sbci	r17, 0xFF	; 255
				sensorData[(messages*NUMBER_OF_BYTES_TO_READ)+i]=sensorConfig[i+2];
			}
			messages++;
			if (messages>=NUMBER_OF_MEASURES){
				messages=0;
				sensorData[0]=0x10;
    1192:	0f 2e       	mov	r0, r31
    1194:	fb e6       	ldi	r31, 0x6B	; 107
    1196:	ef 2e       	mov	r14, r31
    1198:	f1 e0       	ldi	r31, 0x01	; 1
    119a:	ff 2e       	mov	r15, r31
    119c:	f0 2d       	mov	r31, r0
    119e:	68 94       	set
    11a0:	77 24       	eor	r7, r7
    11a2:	74 f8       	bld	r7, 4
				pSensorData = sensorData;
				xQueueSend( DataToSend, (void*) &pSensorData, ( TickType_t ) 0 );
			}
			
			sensorConfig[0]=SLAVE_SENSOR_W;
    11a4:	0f 2e       	mov	r0, r31
    11a6:	fc e3       	ldi	r31, 0x3C	; 60
    11a8:	9f 2e       	mov	r9, r31
    11aa:	f0 2d       	mov	r31, r0
			sensorConfig[1]=MODE_REGISTER;
    11ac:	68 94       	set
    11ae:	aa 24       	eor	r10, r10
    11b0:	a1 f8       	bld	r10, 1
			sensorConfig[2]=0x01; // single measurement mode
    11b2:	bb 24       	eor	r11, r11
    11b4:	b3 94       	inc	r11
	vTaskDelay(100);

	while(1){
		
		
		if (xSemaphoreTake(dataReadySemaphore,0xFFFF))//Block on sensor interrupt
    11b6:	20 e0       	ldi	r18, 0x00	; 0
    11b8:	4f ef       	ldi	r20, 0xFF	; 255
    11ba:	5f ef       	ldi	r21, 0xFF	; 255
    11bc:	60 e0       	ldi	r22, 0x00	; 0
    11be:	70 e0       	ldi	r23, 0x00	; 0
    11c0:	80 91 6e 08 	lds	r24, 0x086E
    11c4:	90 91 6f 08 	lds	r25, 0x086F
    11c8:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xQueueGenericReceive>
    11cc:	88 23       	and	r24, r24
    11ce:	99 f3       	breq	.-26     	; 0x11b6 <xSensorTask+0xf4>
		{
			
			sensorConfig[0]=SLAVE_SENSOR_R;
    11d0:	8b 82       	std	Y+3, r8	; 0x03
			sensorConfig[1]=DATA_OUTPUT_REGISTER; //Start with X MSB register
    11d2:	cc 82       	std	Y+4, r12	; 0x04
			TWI_Start_Transceiver_With_Data(sensorConfig,8); // 2 + 6 bytes to be read
    11d4:	68 e0       	ldi	r22, 0x08	; 8
    11d6:	ce 01       	movw	r24, r28
    11d8:	03 96       	adiw	r24, 0x03	; 3
    11da:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
			vTaskDelay(1);
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskDelay>
			TWI_Get_Data_From_Transceiver(sensorConfig,8);// get the data from the i2c buffer into sensorconfig array
    11e6:	68 e0       	ldi	r22, 0x08	; 8
    11e8:	ce 01       	movw	r24, r28
    11ea:	03 96       	adiw	r24, 0x03	; 3
    11ec:	0e 94 88 07 	call	0xf10	; 0xf10 <TWI_Get_Data_From_Transceiver>
    11f0:	fe 01       	movw	r30, r28
    11f2:	35 96       	adiw	r30, 0x05	; 5
			
			for (uint8_t i =0;i<6;i++){
				sensorData[(messages*NUMBER_OF_BYTES_TO_READ)+i]=sensorConfig[i+2];
    11f4:	8d 2d       	mov	r24, r13
    11f6:	90 e0       	ldi	r25, 0x00	; 0
    11f8:	dc 01       	movw	r26, r24
    11fa:	aa 0f       	add	r26, r26
    11fc:	bb 1f       	adc	r27, r27
    11fe:	8a 0f       	add	r24, r26
    1200:	9b 1f       	adc	r25, r27
    1202:	dc 01       	movw	r26, r24
    1204:	aa 0f       	add	r26, r26
    1206:	bb 1f       	adc	r27, r27
    1208:	a5 59       	subi	r26, 0x95	; 149
    120a:	be 4f       	sbci	r27, 0xFE	; 254
    120c:	81 91       	ld	r24, Z+
    120e:	8d 93       	st	X+, r24
			sensorConfig[1]=DATA_OUTPUT_REGISTER; //Start with X MSB register
			TWI_Start_Transceiver_With_Data(sensorConfig,8); // 2 + 6 bytes to be read
			vTaskDelay(1);
			TWI_Get_Data_From_Transceiver(sensorConfig,8);// get the data from the i2c buffer into sensorconfig array
			
			for (uint8_t i =0;i<6;i++){
    1210:	e0 17       	cp	r30, r16
    1212:	f1 07       	cpc	r31, r17
    1214:	d9 f7       	brne	.-10     	; 0x120c <xSensorTask+0x14a>
				sensorData[(messages*NUMBER_OF_BYTES_TO_READ)+i]=sensorConfig[i+2];
			}
			messages++;
    1216:	d3 94       	inc	r13
			if (messages>=NUMBER_OF_MEASURES){
    1218:	87 e0       	ldi	r24, 0x07	; 7
    121a:	8d 15       	cp	r24, r13
    121c:	88 f4       	brcc	.+34     	; 0x1240 <xSensorTask+0x17e>
				messages=0;
				sensorData[0]=0x10;
    121e:	f7 01       	movw	r30, r14
    1220:	70 82       	st	Z, r7
				pSensorData = sensorData;
    1222:	fa 82       	std	Y+2, r15	; 0x02
    1224:	e9 82       	std	Y+1, r14	; 0x01
				xQueueSend( DataToSend, (void*) &pSensorData, ( TickType_t ) 0 );
    1226:	20 e0       	ldi	r18, 0x00	; 0
    1228:	40 e0       	ldi	r20, 0x00	; 0
    122a:	50 e0       	ldi	r21, 0x00	; 0
    122c:	be 01       	movw	r22, r28
    122e:	6f 5f       	subi	r22, 0xFF	; 255
    1230:	7f 4f       	sbci	r23, 0xFF	; 255
    1232:	80 91 70 08 	lds	r24, 0x0870
    1236:	90 91 71 08 	lds	r25, 0x0871
    123a:	0e 94 b1 0c 	call	0x1962	; 0x1962 <xQueueGenericSend>
			for (uint8_t i =0;i<6;i++){
				sensorData[(messages*NUMBER_OF_BYTES_TO_READ)+i]=sensorConfig[i+2];
			}
			messages++;
			if (messages>=NUMBER_OF_MEASURES){
				messages=0;
    123e:	d1 2c       	mov	r13, r1
				sensorData[0]=0x10;
				pSensorData = sensorData;
				xQueueSend( DataToSend, (void*) &pSensorData, ( TickType_t ) 0 );
			}
			
			sensorConfig[0]=SLAVE_SENSOR_W;
    1240:	9b 82       	std	Y+3, r9	; 0x03
			sensorConfig[1]=MODE_REGISTER;
    1242:	ac 82       	std	Y+4, r10	; 0x04
			sensorConfig[2]=0x01; // single measurement mode
    1244:	bd 82       	std	Y+5, r11	; 0x05
			TWI_Start_Transceiver_With_Data(sensorConfig,3);
    1246:	6c 2d       	mov	r22, r12
    1248:	ce 01       	movw	r24, r28
    124a:	03 96       	adiw	r24, 0x03	; 3
    124c:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
			vTaskDelay(1);
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskDelay>
    1258:	ae cf       	rjmp	.-164    	; 0x11b6 <xSensorTask+0xf4>

0000125a <startSensorTasks>:

QueueHandle_t DataToSend;



void startSensorTasks(UBaseType_t uxPriority){
    125a:	af 92       	push	r10
    125c:	bf 92       	push	r11
    125e:	cf 92       	push	r12
    1260:	df 92       	push	r13
    1262:	ef 92       	push	r14
    1264:	ff 92       	push	r15
    1266:	0f 93       	push	r16
	
	xTaskCreate( xSensorTask,( signed char * ) "Sensor", sensorSTACK_SIZE, NULL, uxPriority, NULL );
    1268:	a1 2c       	mov	r10, r1
    126a:	b1 2c       	mov	r11, r1
    126c:	c1 2c       	mov	r12, r1
    126e:	d1 2c       	mov	r13, r1
    1270:	e1 2c       	mov	r14, r1
    1272:	f1 2c       	mov	r15, r1
    1274:	08 2f       	mov	r16, r24
    1276:	20 e0       	ldi	r18, 0x00	; 0
    1278:	30 e0       	ldi	r19, 0x00	; 0
    127a:	40 e0       	ldi	r20, 0x00	; 0
    127c:	51 e0       	ldi	r21, 0x01	; 1
    127e:	6a e1       	ldi	r22, 0x1A	; 26
    1280:	71 e0       	ldi	r23, 0x01	; 1
    1282:	81 e6       	ldi	r24, 0x61	; 97
    1284:	98 e0       	ldi	r25, 0x08	; 8
    1286:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskGenericCreate>
	
}
    128a:	0f 91       	pop	r16
    128c:	ff 90       	pop	r15
    128e:	ef 90       	pop	r14
    1290:	df 90       	pop	r13
    1292:	cf 90       	pop	r12
    1294:	bf 90       	pop	r11
    1296:	af 90       	pop	r10
    1298:	08 95       	ret

0000129a <__vector_1>:
#ifdef DATA_READY_INTERRUPT


ISR( INT0_vect ) __attribute__ ((hot, flatten));
ISR( INT0_vect )
{
    129a:	1f 92       	push	r1
    129c:	0f 92       	push	r0
    129e:	0f b6       	in	r0, 0x3f	; 63
    12a0:	0f 92       	push	r0
    12a2:	11 24       	eor	r1, r1
    12a4:	2f 93       	push	r18
    12a6:	3f 93       	push	r19
    12a8:	4f 93       	push	r20
    12aa:	5f 93       	push	r21
    12ac:	6f 93       	push	r22
    12ae:	7f 93       	push	r23
    12b0:	8f 93       	push	r24
    12b2:	9f 93       	push	r25
    12b4:	af 93       	push	r26
    12b6:	bf 93       	push	r27
    12b8:	ef 93       	push	r30
    12ba:	ff 93       	push	r31
	xSemaphoreGiveFromISR(dataReadySemaphore,NULL);
    12bc:	60 e0       	ldi	r22, 0x00	; 0
    12be:	70 e0       	ldi	r23, 0x00	; 0
    12c0:	80 91 6e 08 	lds	r24, 0x086E
    12c4:	90 91 6f 08 	lds	r25, 0x086F
    12c8:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <xQueueGiveFromISR>
}
    12cc:	ff 91       	pop	r31
    12ce:	ef 91       	pop	r30
    12d0:	bf 91       	pop	r27
    12d2:	af 91       	pop	r26
    12d4:	9f 91       	pop	r25
    12d6:	8f 91       	pop	r24
    12d8:	7f 91       	pop	r23
    12da:	6f 91       	pop	r22
    12dc:	5f 91       	pop	r21
    12de:	4f 91       	pop	r20
    12e0:	3f 91       	pop	r19
    12e2:	2f 91       	pop	r18
    12e4:	0f 90       	pop	r0
    12e6:	0f be       	out	0x3f, r0	; 63
    12e8:	0f 90       	pop	r0
    12ea:	1f 90       	pop	r1
    12ec:	18 95       	reti

000012ee <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    12ee:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12f0:	03 96       	adiw	r24, 0x03	; 3
    12f2:	92 83       	std	Z+2, r25	; 0x02
    12f4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    12f6:	2f ef       	ldi	r18, 0xFF	; 255
    12f8:	3f ef       	ldi	r19, 0xFF	; 255
    12fa:	34 83       	std	Z+4, r19	; 0x04
    12fc:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12fe:	96 83       	std	Z+6, r25	; 0x06
    1300:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1302:	90 87       	std	Z+8, r25	; 0x08
    1304:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1306:	10 82       	st	Z, r1
    1308:	08 95       	ret

0000130a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    130a:	fc 01       	movw	r30, r24
    130c:	11 86       	std	Z+9, r1	; 0x09
    130e:	10 86       	std	Z+8, r1	; 0x08
    1310:	08 95       	ret

00001312 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1312:	cf 93       	push	r28
    1314:	df 93       	push	r29
    1316:	9c 01       	movw	r18, r24
    1318:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    131a:	dc 01       	movw	r26, r24
    131c:	11 96       	adiw	r26, 0x01	; 1
    131e:	cd 91       	ld	r28, X+
    1320:	dc 91       	ld	r29, X
    1322:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1324:	d3 83       	std	Z+3, r29	; 0x03
    1326:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1328:	8c 81       	ldd	r24, Y+4	; 0x04
    132a:	9d 81       	ldd	r25, Y+5	; 0x05
    132c:	95 83       	std	Z+5, r25	; 0x05
    132e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1330:	8c 81       	ldd	r24, Y+4	; 0x04
    1332:	9d 81       	ldd	r25, Y+5	; 0x05
    1334:	dc 01       	movw	r26, r24
    1336:	13 96       	adiw	r26, 0x03	; 3
    1338:	7c 93       	st	X, r23
    133a:	6e 93       	st	-X, r22
    133c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    133e:	7d 83       	std	Y+5, r23	; 0x05
    1340:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1342:	31 87       	std	Z+9, r19	; 0x09
    1344:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1346:	f9 01       	movw	r30, r18
    1348:	80 81       	ld	r24, Z
    134a:	8f 5f       	subi	r24, 0xFF	; 255
    134c:	80 83       	st	Z, r24
}
    134e:	df 91       	pop	r29
    1350:	cf 91       	pop	r28
    1352:	08 95       	ret

00001354 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1354:	cf 93       	push	r28
    1356:	df 93       	push	r29
    1358:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    135a:	48 81       	ld	r20, Y
    135c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    135e:	4f 3f       	cpi	r20, 0xFF	; 255
    1360:	2f ef       	ldi	r18, 0xFF	; 255
    1362:	52 07       	cpc	r21, r18
    1364:	21 f4       	brne	.+8      	; 0x136e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1366:	fc 01       	movw	r30, r24
    1368:	a7 81       	ldd	r26, Z+7	; 0x07
    136a:	b0 85       	ldd	r27, Z+8	; 0x08
    136c:	0d c0       	rjmp	.+26     	; 0x1388 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    136e:	dc 01       	movw	r26, r24
    1370:	13 96       	adiw	r26, 0x03	; 3
    1372:	12 96       	adiw	r26, 0x02	; 2
    1374:	ed 91       	ld	r30, X+
    1376:	fc 91       	ld	r31, X
    1378:	13 97       	sbiw	r26, 0x03	; 3
    137a:	20 81       	ld	r18, Z
    137c:	31 81       	ldd	r19, Z+1	; 0x01
    137e:	42 17       	cp	r20, r18
    1380:	53 07       	cpc	r21, r19
    1382:	10 f0       	brcs	.+4      	; 0x1388 <vListInsert+0x34>
    1384:	df 01       	movw	r26, r30
    1386:	f5 cf       	rjmp	.-22     	; 0x1372 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1388:	12 96       	adiw	r26, 0x02	; 2
    138a:	ed 91       	ld	r30, X+
    138c:	fc 91       	ld	r31, X
    138e:	13 97       	sbiw	r26, 0x03	; 3
    1390:	fb 83       	std	Y+3, r31	; 0x03
    1392:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1394:	d5 83       	std	Z+5, r29	; 0x05
    1396:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1398:	bd 83       	std	Y+5, r27	; 0x05
    139a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    139c:	13 96       	adiw	r26, 0x03	; 3
    139e:	dc 93       	st	X, r29
    13a0:	ce 93       	st	-X, r28
    13a2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    13a4:	99 87       	std	Y+9, r25	; 0x09
    13a6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    13a8:	fc 01       	movw	r30, r24
    13aa:	20 81       	ld	r18, Z
    13ac:	2f 5f       	subi	r18, 0xFF	; 255
    13ae:	20 83       	st	Z, r18
}
    13b0:	df 91       	pop	r29
    13b2:	cf 91       	pop	r28
    13b4:	08 95       	ret

000013b6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    13b6:	cf 93       	push	r28
    13b8:	df 93       	push	r29
    13ba:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    13bc:	a0 85       	ldd	r26, Z+8	; 0x08
    13be:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    13c0:	c2 81       	ldd	r28, Z+2	; 0x02
    13c2:	d3 81       	ldd	r29, Z+3	; 0x03
    13c4:	84 81       	ldd	r24, Z+4	; 0x04
    13c6:	95 81       	ldd	r25, Z+5	; 0x05
    13c8:	9d 83       	std	Y+5, r25	; 0x05
    13ca:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    13cc:	c4 81       	ldd	r28, Z+4	; 0x04
    13ce:	d5 81       	ldd	r29, Z+5	; 0x05
    13d0:	82 81       	ldd	r24, Z+2	; 0x02
    13d2:	93 81       	ldd	r25, Z+3	; 0x03
    13d4:	9b 83       	std	Y+3, r25	; 0x03
    13d6:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    13d8:	11 96       	adiw	r26, 0x01	; 1
    13da:	cd 91       	ld	r28, X+
    13dc:	dc 91       	ld	r29, X
    13de:	12 97       	sbiw	r26, 0x02	; 2
    13e0:	ce 17       	cp	r28, r30
    13e2:	df 07       	cpc	r29, r31
    13e4:	31 f4       	brne	.+12     	; 0x13f2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    13e6:	8c 81       	ldd	r24, Y+4	; 0x04
    13e8:	9d 81       	ldd	r25, Y+5	; 0x05
    13ea:	12 96       	adiw	r26, 0x02	; 2
    13ec:	9c 93       	st	X, r25
    13ee:	8e 93       	st	-X, r24
    13f0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    13f2:	11 86       	std	Z+9, r1	; 0x09
    13f4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    13f6:	8c 91       	ld	r24, X
    13f8:	81 50       	subi	r24, 0x01	; 1
    13fa:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    13fc:	df 91       	pop	r29
    13fe:	cf 91       	pop	r28
    1400:	08 95       	ret

00001402 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1402:	31 e1       	ldi	r19, 0x11	; 17
    1404:	fc 01       	movw	r30, r24
    1406:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1408:	31 97       	sbiw	r30, 0x01	; 1
    140a:	22 e2       	ldi	r18, 0x22	; 34
    140c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    140e:	31 97       	sbiw	r30, 0x01	; 1
    1410:	a3 e3       	ldi	r26, 0x33	; 51
    1412:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1414:	31 97       	sbiw	r30, 0x01	; 1
    1416:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1418:	31 97       	sbiw	r30, 0x01	; 1
    141a:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    141c:	31 97       	sbiw	r30, 0x01	; 1
    141e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1420:	31 97       	sbiw	r30, 0x01	; 1
    1422:	60 e8       	ldi	r22, 0x80	; 128
    1424:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1426:	31 97       	sbiw	r30, 0x01	; 1
    1428:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    142a:	31 97       	sbiw	r30, 0x01	; 1
    142c:	62 e0       	ldi	r22, 0x02	; 2
    142e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1430:	31 97       	sbiw	r30, 0x01	; 1
    1432:	63 e0       	ldi	r22, 0x03	; 3
    1434:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1436:	31 97       	sbiw	r30, 0x01	; 1
    1438:	64 e0       	ldi	r22, 0x04	; 4
    143a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    143c:	31 97       	sbiw	r30, 0x01	; 1
    143e:	65 e0       	ldi	r22, 0x05	; 5
    1440:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1442:	31 97       	sbiw	r30, 0x01	; 1
    1444:	66 e0       	ldi	r22, 0x06	; 6
    1446:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1448:	31 97       	sbiw	r30, 0x01	; 1
    144a:	67 e0       	ldi	r22, 0x07	; 7
    144c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    144e:	31 97       	sbiw	r30, 0x01	; 1
    1450:	68 e0       	ldi	r22, 0x08	; 8
    1452:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1454:	31 97       	sbiw	r30, 0x01	; 1
    1456:	69 e0       	ldi	r22, 0x09	; 9
    1458:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    145a:	31 97       	sbiw	r30, 0x01	; 1
    145c:	60 e1       	ldi	r22, 0x10	; 16
    145e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1460:	31 97       	sbiw	r30, 0x01	; 1
    1462:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1464:	31 97       	sbiw	r30, 0x01	; 1
    1466:	32 e1       	ldi	r19, 0x12	; 18
    1468:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    146a:	31 97       	sbiw	r30, 0x01	; 1
    146c:	33 e1       	ldi	r19, 0x13	; 19
    146e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1470:	31 97       	sbiw	r30, 0x01	; 1
    1472:	34 e1       	ldi	r19, 0x14	; 20
    1474:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1476:	31 97       	sbiw	r30, 0x01	; 1
    1478:	35 e1       	ldi	r19, 0x15	; 21
    147a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    147c:	31 97       	sbiw	r30, 0x01	; 1
    147e:	36 e1       	ldi	r19, 0x16	; 22
    1480:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1482:	31 97       	sbiw	r30, 0x01	; 1
    1484:	37 e1       	ldi	r19, 0x17	; 23
    1486:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1488:	31 97       	sbiw	r30, 0x01	; 1
    148a:	38 e1       	ldi	r19, 0x18	; 24
    148c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    148e:	31 97       	sbiw	r30, 0x01	; 1
    1490:	39 e1       	ldi	r19, 0x19	; 25
    1492:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1494:	31 97       	sbiw	r30, 0x01	; 1
    1496:	30 e2       	ldi	r19, 0x20	; 32
    1498:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    149a:	31 97       	sbiw	r30, 0x01	; 1
    149c:	31 e2       	ldi	r19, 0x21	; 33
    149e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    14a0:	31 97       	sbiw	r30, 0x01	; 1
    14a2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    14a4:	31 97       	sbiw	r30, 0x01	; 1
    14a6:	23 e2       	ldi	r18, 0x23	; 35
    14a8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    14aa:	31 97       	sbiw	r30, 0x01	; 1
    14ac:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    14ae:	31 97       	sbiw	r30, 0x01	; 1
    14b0:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    14b2:	31 97       	sbiw	r30, 0x01	; 1
    14b4:	26 e2       	ldi	r18, 0x26	; 38
    14b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    14b8:	31 97       	sbiw	r30, 0x01	; 1
    14ba:	27 e2       	ldi	r18, 0x27	; 39
    14bc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    14be:	31 97       	sbiw	r30, 0x01	; 1
    14c0:	28 e2       	ldi	r18, 0x28	; 40
    14c2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    14c4:	31 97       	sbiw	r30, 0x01	; 1
    14c6:	29 e2       	ldi	r18, 0x29	; 41
    14c8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    14ca:	31 97       	sbiw	r30, 0x01	; 1
    14cc:	20 e3       	ldi	r18, 0x30	; 48
    14ce:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    14d0:	31 97       	sbiw	r30, 0x01	; 1
    14d2:	21 e3       	ldi	r18, 0x31	; 49
    14d4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    14d6:	86 97       	sbiw	r24, 0x26	; 38
    14d8:	08 95       	ret

000014da <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    14da:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    14de:	82 e7       	ldi	r24, 0x72	; 114
    14e0:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    14e4:	8b e0       	ldi	r24, 0x0B	; 11
    14e6:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    14ea:	ef e6       	ldi	r30, 0x6F	; 111
    14ec:	f0 e0       	ldi	r31, 0x00	; 0
    14ee:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    14f0:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    14f2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    14f4:	a0 91 ca 07 	lds	r26, 0x07CA
    14f8:	b0 91 cb 07 	lds	r27, 0x07CB
    14fc:	cd 91       	ld	r28, X+
    14fe:	cd bf       	out	0x3d, r28	; 61
    1500:	dd 91       	ld	r29, X+
    1502:	de bf       	out	0x3e, r29	; 62
    1504:	ff 91       	pop	r31
    1506:	ef 91       	pop	r30
    1508:	df 91       	pop	r29
    150a:	cf 91       	pop	r28
    150c:	bf 91       	pop	r27
    150e:	af 91       	pop	r26
    1510:	9f 91       	pop	r25
    1512:	8f 91       	pop	r24
    1514:	7f 91       	pop	r23
    1516:	6f 91       	pop	r22
    1518:	5f 91       	pop	r21
    151a:	4f 91       	pop	r20
    151c:	3f 91       	pop	r19
    151e:	2f 91       	pop	r18
    1520:	1f 91       	pop	r17
    1522:	0f 91       	pop	r16
    1524:	ff 90       	pop	r15
    1526:	ef 90       	pop	r14
    1528:	df 90       	pop	r13
    152a:	cf 90       	pop	r12
    152c:	bf 90       	pop	r11
    152e:	af 90       	pop	r10
    1530:	9f 90       	pop	r9
    1532:	8f 90       	pop	r8
    1534:	7f 90       	pop	r7
    1536:	6f 90       	pop	r6
    1538:	5f 90       	pop	r5
    153a:	4f 90       	pop	r4
    153c:	3f 90       	pop	r3
    153e:	2f 90       	pop	r2
    1540:	1f 90       	pop	r1
    1542:	0f 90       	pop	r0
    1544:	0f be       	out	0x3f, r0	; 63
    1546:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1548:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	08 95       	ret

0000154e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    154e:	0f 92       	push	r0
    1550:	0f b6       	in	r0, 0x3f	; 63
    1552:	f8 94       	cli
    1554:	0f 92       	push	r0
    1556:	1f 92       	push	r1
    1558:	11 24       	eor	r1, r1
    155a:	2f 92       	push	r2
    155c:	3f 92       	push	r3
    155e:	4f 92       	push	r4
    1560:	5f 92       	push	r5
    1562:	6f 92       	push	r6
    1564:	7f 92       	push	r7
    1566:	8f 92       	push	r8
    1568:	9f 92       	push	r9
    156a:	af 92       	push	r10
    156c:	bf 92       	push	r11
    156e:	cf 92       	push	r12
    1570:	df 92       	push	r13
    1572:	ef 92       	push	r14
    1574:	ff 92       	push	r15
    1576:	0f 93       	push	r16
    1578:	1f 93       	push	r17
    157a:	2f 93       	push	r18
    157c:	3f 93       	push	r19
    157e:	4f 93       	push	r20
    1580:	5f 93       	push	r21
    1582:	6f 93       	push	r22
    1584:	7f 93       	push	r23
    1586:	8f 93       	push	r24
    1588:	9f 93       	push	r25
    158a:	af 93       	push	r26
    158c:	bf 93       	push	r27
    158e:	cf 93       	push	r28
    1590:	df 93       	push	r29
    1592:	ef 93       	push	r30
    1594:	ff 93       	push	r31
    1596:	a0 91 ca 07 	lds	r26, 0x07CA
    159a:	b0 91 cb 07 	lds	r27, 0x07CB
    159e:	0d b6       	in	r0, 0x3d	; 61
    15a0:	0d 92       	st	X+, r0
    15a2:	0e b6       	in	r0, 0x3e	; 62
    15a4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    15a6:	0e 94 a4 11 	call	0x2348	; 0x2348 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    15aa:	a0 91 ca 07 	lds	r26, 0x07CA
    15ae:	b0 91 cb 07 	lds	r27, 0x07CB
    15b2:	cd 91       	ld	r28, X+
    15b4:	cd bf       	out	0x3d, r28	; 61
    15b6:	dd 91       	ld	r29, X+
    15b8:	de bf       	out	0x3e, r29	; 62
    15ba:	ff 91       	pop	r31
    15bc:	ef 91       	pop	r30
    15be:	df 91       	pop	r29
    15c0:	cf 91       	pop	r28
    15c2:	bf 91       	pop	r27
    15c4:	af 91       	pop	r26
    15c6:	9f 91       	pop	r25
    15c8:	8f 91       	pop	r24
    15ca:	7f 91       	pop	r23
    15cc:	6f 91       	pop	r22
    15ce:	5f 91       	pop	r21
    15d0:	4f 91       	pop	r20
    15d2:	3f 91       	pop	r19
    15d4:	2f 91       	pop	r18
    15d6:	1f 91       	pop	r17
    15d8:	0f 91       	pop	r16
    15da:	ff 90       	pop	r15
    15dc:	ef 90       	pop	r14
    15de:	df 90       	pop	r13
    15e0:	cf 90       	pop	r12
    15e2:	bf 90       	pop	r11
    15e4:	af 90       	pop	r10
    15e6:	9f 90       	pop	r9
    15e8:	8f 90       	pop	r8
    15ea:	7f 90       	pop	r7
    15ec:	6f 90       	pop	r6
    15ee:	5f 90       	pop	r5
    15f0:	4f 90       	pop	r4
    15f2:	3f 90       	pop	r3
    15f4:	2f 90       	pop	r2
    15f6:	1f 90       	pop	r1
    15f8:	0f 90       	pop	r0
    15fa:	0f be       	out	0x3f, r0	; 63
    15fc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15fe:	08 95       	ret

00001600 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1600:	0f 92       	push	r0
    1602:	0f b6       	in	r0, 0x3f	; 63
    1604:	f8 94       	cli
    1606:	0f 92       	push	r0
    1608:	1f 92       	push	r1
    160a:	11 24       	eor	r1, r1
    160c:	2f 92       	push	r2
    160e:	3f 92       	push	r3
    1610:	4f 92       	push	r4
    1612:	5f 92       	push	r5
    1614:	6f 92       	push	r6
    1616:	7f 92       	push	r7
    1618:	8f 92       	push	r8
    161a:	9f 92       	push	r9
    161c:	af 92       	push	r10
    161e:	bf 92       	push	r11
    1620:	cf 92       	push	r12
    1622:	df 92       	push	r13
    1624:	ef 92       	push	r14
    1626:	ff 92       	push	r15
    1628:	0f 93       	push	r16
    162a:	1f 93       	push	r17
    162c:	2f 93       	push	r18
    162e:	3f 93       	push	r19
    1630:	4f 93       	push	r20
    1632:	5f 93       	push	r21
    1634:	6f 93       	push	r22
    1636:	7f 93       	push	r23
    1638:	8f 93       	push	r24
    163a:	9f 93       	push	r25
    163c:	af 93       	push	r26
    163e:	bf 93       	push	r27
    1640:	cf 93       	push	r28
    1642:	df 93       	push	r29
    1644:	ef 93       	push	r30
    1646:	ff 93       	push	r31
    1648:	a0 91 ca 07 	lds	r26, 0x07CA
    164c:	b0 91 cb 07 	lds	r27, 0x07CB
    1650:	0d b6       	in	r0, 0x3d	; 61
    1652:	0d 92       	st	X+, r0
    1654:	0e b6       	in	r0, 0x3e	; 62
    1656:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1658:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <xTaskIncrementTick>
    165c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    165e:	0e 94 a4 11 	call	0x2348	; 0x2348 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1662:	a0 91 ca 07 	lds	r26, 0x07CA
    1666:	b0 91 cb 07 	lds	r27, 0x07CB
    166a:	cd 91       	ld	r28, X+
    166c:	cd bf       	out	0x3d, r28	; 61
    166e:	dd 91       	ld	r29, X+
    1670:	de bf       	out	0x3e, r29	; 62
    1672:	ff 91       	pop	r31
    1674:	ef 91       	pop	r30
    1676:	df 91       	pop	r29
    1678:	cf 91       	pop	r28
    167a:	bf 91       	pop	r27
    167c:	af 91       	pop	r26
    167e:	9f 91       	pop	r25
    1680:	8f 91       	pop	r24
    1682:	7f 91       	pop	r23
    1684:	6f 91       	pop	r22
    1686:	5f 91       	pop	r21
    1688:	4f 91       	pop	r20
    168a:	3f 91       	pop	r19
    168c:	2f 91       	pop	r18
    168e:	1f 91       	pop	r17
    1690:	0f 91       	pop	r16
    1692:	ff 90       	pop	r15
    1694:	ef 90       	pop	r14
    1696:	df 90       	pop	r13
    1698:	cf 90       	pop	r12
    169a:	bf 90       	pop	r11
    169c:	af 90       	pop	r10
    169e:	9f 90       	pop	r9
    16a0:	8f 90       	pop	r8
    16a2:	7f 90       	pop	r7
    16a4:	6f 90       	pop	r6
    16a6:	5f 90       	pop	r5
    16a8:	4f 90       	pop	r4
    16aa:	3f 90       	pop	r3
    16ac:	2f 90       	pop	r2
    16ae:	1f 90       	pop	r1
    16b0:	0f 90       	pop	r0
    16b2:	0f be       	out	0x3f, r0	; 63
    16b4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    16b6:	08 95       	ret

000016b8 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    16b8:	0e 94 00 0b 	call	0x1600	; 0x1600 <vPortYieldFromTick>
		asm volatile ( "reti" );
    16bc:	18 95       	reti

000016be <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    16be:	cf 93       	push	r28
    16c0:	df 93       	push	r29
    16c2:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    16c4:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    16c8:	80 91 9b 01 	lds	r24, 0x019B
    16cc:	90 91 9c 01 	lds	r25, 0x019C
    16d0:	89 2b       	or	r24, r25
    16d2:	31 f4       	brne	.+12     	; 0x16e0 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    16d4:	80 ea       	ldi	r24, 0xA0	; 160
    16d6:	91 e0       	ldi	r25, 0x01	; 1
    16d8:	90 93 9c 01 	sts	0x019C, r25
    16dc:	80 93 9b 01 	sts	0x019B, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    16e0:	40 91 9d 01 	lds	r20, 0x019D
    16e4:	50 91 9e 01 	lds	r21, 0x019E
    16e8:	9e 01       	movw	r18, r28
    16ea:	24 0f       	add	r18, r20
    16ec:	35 1f       	adc	r19, r21
    16ee:	2b 3d       	cpi	r18, 0xDB	; 219
    16f0:	85 e0       	ldi	r24, 0x05	; 5
    16f2:	38 07       	cpc	r19, r24
    16f4:	70 f4       	brcc	.+28     	; 0x1712 <pvPortMalloc+0x54>
    16f6:	42 17       	cp	r20, r18
    16f8:	53 07       	cpc	r21, r19
    16fa:	70 f4       	brcc	.+28     	; 0x1718 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    16fc:	c0 91 9b 01 	lds	r28, 0x019B
    1700:	d0 91 9c 01 	lds	r29, 0x019C
    1704:	c4 0f       	add	r28, r20
    1706:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
    1708:	30 93 9e 01 	sts	0x019E, r19
    170c:	20 93 9d 01 	sts	0x019D, r18
    1710:	05 c0       	rjmp	.+10     	; 0x171c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1712:	c0 e0       	ldi	r28, 0x00	; 0
    1714:	d0 e0       	ldi	r29, 0x00	; 0
    1716:	02 c0       	rjmp	.+4      	; 0x171c <pvPortMalloc+0x5e>
    1718:	c0 e0       	ldi	r28, 0x00	; 0
    171a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    171c:	0e 94 bf 10 	call	0x217e	; 0x217e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1720:	ce 01       	movw	r24, r28
    1722:	df 91       	pop	r29
    1724:	cf 91       	pop	r28
    1726:	08 95       	ret

00001728 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1728:	08 95       	ret

0000172a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    172a:	1f 93       	push	r17
    172c:	cf 93       	push	r28
    172e:	df 93       	push	r29
    1730:	ec 01       	movw	r28, r24
    1732:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1734:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1736:	88 23       	and	r24, r24
    1738:	e9 f1       	breq	.+122    	; 0x17b4 <prvCopyDataToQueue+0x8a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    173a:	41 11       	cpse	r20, r1
    173c:	17 c0       	rjmp	.+46     	; 0x176c <prvCopyDataToQueue+0x42>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    173e:	48 2f       	mov	r20, r24
    1740:	50 e0       	ldi	r21, 0x00	; 0
    1742:	8c 81       	ldd	r24, Y+4	; 0x04
    1744:	9d 81       	ldd	r25, Y+5	; 0x05
    1746:	0e 94 af 12 	call	0x255e	; 0x255e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    174a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    174c:	8c 81       	ldd	r24, Y+4	; 0x04
    174e:	9d 81       	ldd	r25, Y+5	; 0x05
    1750:	82 0f       	add	r24, r18
    1752:	91 1d       	adc	r25, r1
    1754:	9d 83       	std	Y+5, r25	; 0x05
    1756:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1758:	2a 81       	ldd	r18, Y+2	; 0x02
    175a:	3b 81       	ldd	r19, Y+3	; 0x03
    175c:	82 17       	cp	r24, r18
    175e:	93 07       	cpc	r25, r19
    1760:	48 f1       	brcs	.+82     	; 0x17b4 <prvCopyDataToQueue+0x8a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1762:	88 81       	ld	r24, Y
    1764:	99 81       	ldd	r25, Y+1	; 0x01
    1766:	9d 83       	std	Y+5, r25	; 0x05
    1768:	8c 83       	std	Y+4, r24	; 0x04
    176a:	24 c0       	rjmp	.+72     	; 0x17b4 <prvCopyDataToQueue+0x8a>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    176c:	48 2f       	mov	r20, r24
    176e:	50 e0       	ldi	r21, 0x00	; 0
    1770:	8e 81       	ldd	r24, Y+6	; 0x06
    1772:	9f 81       	ldd	r25, Y+7	; 0x07
    1774:	0e 94 af 12 	call	0x255e	; 0x255e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1778:	2c 8d       	ldd	r18, Y+28	; 0x1c
    177a:	30 e0       	ldi	r19, 0x00	; 0
    177c:	31 95       	neg	r19
    177e:	21 95       	neg	r18
    1780:	31 09       	sbc	r19, r1
    1782:	8e 81       	ldd	r24, Y+6	; 0x06
    1784:	9f 81       	ldd	r25, Y+7	; 0x07
    1786:	82 0f       	add	r24, r18
    1788:	93 1f       	adc	r25, r19
    178a:	9f 83       	std	Y+7, r25	; 0x07
    178c:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    178e:	68 81       	ld	r22, Y
    1790:	79 81       	ldd	r23, Y+1	; 0x01
    1792:	86 17       	cp	r24, r22
    1794:	97 07       	cpc	r25, r23
    1796:	30 f4       	brcc	.+12     	; 0x17a4 <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1798:	8a 81       	ldd	r24, Y+2	; 0x02
    179a:	9b 81       	ldd	r25, Y+3	; 0x03
    179c:	28 0f       	add	r18, r24
    179e:	39 1f       	adc	r19, r25
    17a0:	3f 83       	std	Y+7, r19	; 0x07
    17a2:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    17a4:	12 30       	cpi	r17, 0x02	; 2
    17a6:	31 f4       	brne	.+12     	; 0x17b4 <prvCopyDataToQueue+0x8a>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    17a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17aa:	88 23       	and	r24, r24
    17ac:	19 f0       	breq	.+6      	; 0x17b4 <prvCopyDataToQueue+0x8a>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    17ae:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17b0:	81 50       	subi	r24, 0x01	; 1
    17b2:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    17b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17b6:	8f 5f       	subi	r24, 0xFF	; 255
    17b8:	8a 8f       	std	Y+26, r24	; 0x1a

	return xReturn;
}
    17ba:	80 e0       	ldi	r24, 0x00	; 0
    17bc:	df 91       	pop	r29
    17be:	cf 91       	pop	r28
    17c0:	1f 91       	pop	r17
    17c2:	08 95       	ret

000017c4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    17c4:	fc 01       	movw	r30, r24
    17c6:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    17c8:	44 8d       	ldd	r20, Z+28	; 0x1c
    17ca:	44 23       	and	r20, r20
    17cc:	a1 f0       	breq	.+40     	; 0x17f6 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    17ce:	50 e0       	ldi	r21, 0x00	; 0
    17d0:	26 81       	ldd	r18, Z+6	; 0x06
    17d2:	37 81       	ldd	r19, Z+7	; 0x07
    17d4:	24 0f       	add	r18, r20
    17d6:	35 1f       	adc	r19, r21
    17d8:	37 83       	std	Z+7, r19	; 0x07
    17da:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    17dc:	62 81       	ldd	r22, Z+2	; 0x02
    17de:	73 81       	ldd	r23, Z+3	; 0x03
    17e0:	26 17       	cp	r18, r22
    17e2:	37 07       	cpc	r19, r23
    17e4:	20 f0       	brcs	.+8      	; 0x17ee <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    17e6:	20 81       	ld	r18, Z
    17e8:	31 81       	ldd	r19, Z+1	; 0x01
    17ea:	37 83       	std	Z+7, r19	; 0x07
    17ec:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    17ee:	66 81       	ldd	r22, Z+6	; 0x06
    17f0:	77 81       	ldd	r23, Z+7	; 0x07
    17f2:	0e 94 af 12 	call	0x255e	; 0x255e <memcpy>
    17f6:	08 95       	ret

000017f8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    17f8:	0f 93       	push	r16
    17fa:	1f 93       	push	r17
    17fc:	cf 93       	push	r28
    17fe:	df 93       	push	r29
    1800:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1802:	0f b6       	in	r0, 0x3f	; 63
    1804:	f8 94       	cli
    1806:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1808:	8e 8d       	ldd	r24, Y+30	; 0x1e
    180a:	18 16       	cp	r1, r24
    180c:	b4 f4       	brge	.+44     	; 0x183a <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    180e:	89 89       	ldd	r24, Y+17	; 0x11
    1810:	88 23       	and	r24, r24
    1812:	99 f0       	breq	.+38     	; 0x183a <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1814:	8e 01       	movw	r16, r28
    1816:	0f 5e       	subi	r16, 0xEF	; 239
    1818:	1f 4f       	sbci	r17, 0xFF	; 255
    181a:	03 c0       	rjmp	.+6      	; 0x1822 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    181c:	89 89       	ldd	r24, Y+17	; 0x11
    181e:	88 23       	and	r24, r24
    1820:	61 f0       	breq	.+24     	; 0x183a <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1822:	c8 01       	movw	r24, r16
    1824:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskRemoveFromEventList>
    1828:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    182a:	0e 94 a5 12 	call	0x254a	; 0x254a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    182e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1830:	81 50       	subi	r24, 0x01	; 1
    1832:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1834:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1836:	18 16       	cp	r1, r24
    1838:	8c f3       	brlt	.-30     	; 0x181c <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    183a:	8f ef       	ldi	r24, 0xFF	; 255
    183c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    183e:	0f 90       	pop	r0
    1840:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1842:	0f b6       	in	r0, 0x3f	; 63
    1844:	f8 94       	cli
    1846:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1848:	8d 8d       	ldd	r24, Y+29	; 0x1d
    184a:	18 16       	cp	r1, r24
    184c:	b4 f4       	brge	.+44     	; 0x187a <prvUnlockQueue+0x82>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    184e:	88 85       	ldd	r24, Y+8	; 0x08
    1850:	88 23       	and	r24, r24
    1852:	99 f0       	breq	.+38     	; 0x187a <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1854:	8e 01       	movw	r16, r28
    1856:	08 5f       	subi	r16, 0xF8	; 248
    1858:	1f 4f       	sbci	r17, 0xFF	; 255
    185a:	03 c0       	rjmp	.+6      	; 0x1862 <prvUnlockQueue+0x6a>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    185c:	88 85       	ldd	r24, Y+8	; 0x08
    185e:	88 23       	and	r24, r24
    1860:	61 f0       	breq	.+24     	; 0x187a <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1862:	c8 01       	movw	r24, r16
    1864:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskRemoveFromEventList>
    1868:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    186a:	0e 94 a5 12 	call	0x254a	; 0x254a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    186e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1870:	81 50       	subi	r24, 0x01	; 1
    1872:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1874:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1876:	18 16       	cp	r1, r24
    1878:	8c f3       	brlt	.-30     	; 0x185c <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    187a:	8f ef       	ldi	r24, 0xFF	; 255
    187c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    187e:	0f 90       	pop	r0
    1880:	0f be       	out	0x3f, r0	; 63
}
    1882:	df 91       	pop	r29
    1884:	cf 91       	pop	r28
    1886:	1f 91       	pop	r17
    1888:	0f 91       	pop	r16
    188a:	08 95       	ret

0000188c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    188c:	cf 93       	push	r28
    188e:	df 93       	push	r29
    1890:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1898:	88 81       	ld	r24, Y
    189a:	99 81       	ldd	r25, Y+1	; 0x01
    189c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    189e:	30 e0       	ldi	r19, 0x00	; 0
    18a0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    18a2:	72 9f       	mul	r23, r18
    18a4:	a0 01       	movw	r20, r0
    18a6:	73 9f       	mul	r23, r19
    18a8:	50 0d       	add	r21, r0
    18aa:	11 24       	eor	r1, r1
    18ac:	fc 01       	movw	r30, r24
    18ae:	e4 0f       	add	r30, r20
    18b0:	f5 1f       	adc	r31, r21
    18b2:	fb 83       	std	Y+3, r31	; 0x03
    18b4:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    18b6:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    18b8:	9d 83       	std	Y+5, r25	; 0x05
    18ba:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    18bc:	42 1b       	sub	r20, r18
    18be:	53 0b       	sbc	r21, r19
    18c0:	84 0f       	add	r24, r20
    18c2:	95 1f       	adc	r25, r21
    18c4:	9f 83       	std	Y+7, r25	; 0x07
    18c6:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    18c8:	8f ef       	ldi	r24, 0xFF	; 255
    18ca:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    18cc:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    18ce:	61 11       	cpse	r22, r1
    18d0:	0c c0       	rjmp	.+24     	; 0x18ea <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18d2:	88 85       	ldd	r24, Y+8	; 0x08
    18d4:	88 23       	and	r24, r24
    18d6:	89 f0       	breq	.+34     	; 0x18fa <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    18d8:	ce 01       	movw	r24, r28
    18da:	08 96       	adiw	r24, 0x08	; 8
    18dc:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskRemoveFromEventList>
    18e0:	81 30       	cpi	r24, 0x01	; 1
    18e2:	59 f4       	brne	.+22     	; 0x18fa <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
    18e4:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    18e8:	08 c0       	rjmp	.+16     	; 0x18fa <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    18ea:	ce 01       	movw	r24, r28
    18ec:	08 96       	adiw	r24, 0x08	; 8
    18ee:	0e 94 77 09 	call	0x12ee	; 0x12ee <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    18f2:	ce 01       	movw	r24, r28
    18f4:	41 96       	adiw	r24, 0x11	; 17
    18f6:	0e 94 77 09 	call	0x12ee	; 0x12ee <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    18fa:	0f 90       	pop	r0
    18fc:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    18fe:	81 e0       	ldi	r24, 0x01	; 1
    1900:	df 91       	pop	r29
    1902:	cf 91       	pop	r28
    1904:	08 95       	ret

00001906 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1906:	0f 93       	push	r16
    1908:	1f 93       	push	r17
    190a:	cf 93       	push	r28
    190c:	df 93       	push	r29
    190e:	08 2f       	mov	r16, r24
    1910:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    1912:	66 23       	and	r22, r22
    1914:	c9 f0       	breq	.+50     	; 0x1948 <xQueueGenericCreate+0x42>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1916:	86 9f       	mul	r24, r22
    1918:	c0 01       	movw	r24, r0
    191a:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    191c:	80 96       	adiw	r24, 0x20	; 32
    191e:	0e 94 5f 0b 	call	0x16be	; 0x16be <pvPortMalloc>
    1922:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
    1924:	00 97       	sbiw	r24, 0x00	; 0
    1926:	21 f4       	brne	.+8      	; 0x1930 <xQueueGenericCreate+0x2a>
    1928:	16 c0       	rjmp	.+44     	; 0x1956 <xQueueGenericCreate+0x50>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    192a:	d9 83       	std	Y+1, r29	; 0x01
    192c:	c8 83       	st	Y, r28
    192e:	05 c0       	rjmp	.+10     	; 0x193a <xQueueGenericCreate+0x34>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    1930:	9c 01       	movw	r18, r24
    1932:	21 5e       	subi	r18, 0xE1	; 225
    1934:	3f 4f       	sbci	r19, 0xFF	; 255
    1936:	39 83       	std	Y+1, r19	; 0x01
    1938:	28 83       	st	Y, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    193a:	0b 8f       	std	Y+27, r16	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    193c:	1c 8f       	std	Y+28, r17	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    193e:	61 e0       	ldi	r22, 0x01	; 1
    1940:	ce 01       	movw	r24, r28
    1942:	0e 94 46 0c 	call	0x188c	; 0x188c <xQueueGenericReset>
    1946:	07 c0       	rjmp	.+14     	; 0x1956 <xQueueGenericCreate+0x50>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1948:	8f e1       	ldi	r24, 0x1F	; 31
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	0e 94 5f 0b 	call	0x16be	; 0x16be <pvPortMalloc>
    1950:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
    1952:	00 97       	sbiw	r24, 0x00	; 0
    1954:	51 f7       	brne	.-44     	; 0x192a <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
    1956:	ce 01       	movw	r24, r28
    1958:	df 91       	pop	r29
    195a:	cf 91       	pop	r28
    195c:	1f 91       	pop	r17
    195e:	0f 91       	pop	r16
    1960:	08 95       	ret

00001962 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1962:	9f 92       	push	r9
    1964:	af 92       	push	r10
    1966:	bf 92       	push	r11
    1968:	cf 92       	push	r12
    196a:	df 92       	push	r13
    196c:	ef 92       	push	r14
    196e:	ff 92       	push	r15
    1970:	0f 93       	push	r16
    1972:	1f 93       	push	r17
    1974:	cf 93       	push	r28
    1976:	df 93       	push	r29
    1978:	00 d0       	rcall	.+0      	; 0x197a <xQueueGenericSend+0x18>
    197a:	00 d0       	rcall	.+0      	; 0x197c <xQueueGenericSend+0x1a>
    197c:	1f 92       	push	r1
    197e:	cd b7       	in	r28, 0x3d	; 61
    1980:	de b7       	in	r29, 0x3e	; 62
    1982:	8c 01       	movw	r16, r24
    1984:	6b 01       	movw	r12, r22
    1986:	5d 83       	std	Y+5, r21	; 0x05
    1988:	4c 83       	std	Y+4, r20	; 0x04
    198a:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    198c:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    198e:	99 24       	eor	r9, r9
    1990:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1992:	7c 01       	movw	r14, r24
    1994:	88 e0       	ldi	r24, 0x08	; 8
    1996:	e8 0e       	add	r14, r24
    1998:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    199a:	0f b6       	in	r0, 0x3f	; 63
    199c:	f8 94       	cli
    199e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19a0:	f8 01       	movw	r30, r16
    19a2:	92 8d       	ldd	r25, Z+26	; 0x1a
    19a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    19a6:	98 17       	cp	r25, r24
    19a8:	18 f0       	brcs	.+6      	; 0x19b0 <xQueueGenericSend+0x4e>
    19aa:	f2 e0       	ldi	r31, 0x02	; 2
    19ac:	af 12       	cpse	r10, r31
    19ae:	19 c0       	rjmp	.+50     	; 0x19e2 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19b0:	4a 2d       	mov	r20, r10
    19b2:	b6 01       	movw	r22, r12
    19b4:	c8 01       	movw	r24, r16
    19b6:	0e 94 95 0b 	call	0x172a	; 0x172a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19ba:	f8 01       	movw	r30, r16
    19bc:	91 89       	ldd	r25, Z+17	; 0x11
    19be:	99 23       	and	r25, r25
    19c0:	49 f0       	breq	.+18     	; 0x19d4 <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    19c2:	c8 01       	movw	r24, r16
    19c4:	41 96       	adiw	r24, 0x11	; 17
    19c6:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskRemoveFromEventList>
    19ca:	81 30       	cpi	r24, 0x01	; 1
    19cc:	31 f4       	brne	.+12     	; 0x19da <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    19ce:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    19d2:	03 c0       	rjmp	.+6      	; 0x19da <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    19d4:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    19d6:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    19da:	0f 90       	pop	r0
    19dc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    19de:	81 e0       	ldi	r24, 0x01	; 1
    19e0:	51 c0       	rjmp	.+162    	; 0x1a84 <xQueueGenericSend+0x122>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    19e2:	ec 81       	ldd	r30, Y+4	; 0x04
    19e4:	fd 81       	ldd	r31, Y+5	; 0x05
    19e6:	ef 2b       	or	r30, r31
    19e8:	21 f4       	brne	.+8      	; 0x19f2 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    19ea:	0f 90       	pop	r0
    19ec:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    19ee:	80 e0       	ldi	r24, 0x00	; 0
    19f0:	49 c0       	rjmp	.+146    	; 0x1a84 <xQueueGenericSend+0x122>
				}
				else if( xEntryTimeSet == pdFALSE )
    19f2:	b1 10       	cpse	r11, r1
    19f4:	05 c0       	rjmp	.+10     	; 0x1a00 <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    19f6:	ce 01       	movw	r24, r28
    19f8:	01 96       	adiw	r24, 0x01	; 1
    19fa:	0e 94 67 12 	call	0x24ce	; 0x24ce <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    19fe:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a00:	0f 90       	pop	r0
    1a02:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a04:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a08:	0f b6       	in	r0, 0x3f	; 63
    1a0a:	f8 94       	cli
    1a0c:	0f 92       	push	r0
    1a0e:	f8 01       	movw	r30, r16
    1a10:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a12:	8f 3f       	cpi	r24, 0xFF	; 255
    1a14:	09 f4       	brne	.+2      	; 0x1a18 <xQueueGenericSend+0xb6>
    1a16:	15 8e       	std	Z+29, r1	; 0x1d
    1a18:	f8 01       	movw	r30, r16
    1a1a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a1c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a1e:	09 f4       	brne	.+2      	; 0x1a22 <xQueueGenericSend+0xc0>
    1a20:	16 8e       	std	Z+30, r1	; 0x1e
    1a22:	0f 90       	pop	r0
    1a24:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a26:	be 01       	movw	r22, r28
    1a28:	6c 5f       	subi	r22, 0xFC	; 252
    1a2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a2c:	ce 01       	movw	r24, r28
    1a2e:	01 96       	adiw	r24, 0x01	; 1
    1a30:	0e 94 72 12 	call	0x24e4	; 0x24e4 <xTaskCheckForTimeOut>
    1a34:	81 11       	cpse	r24, r1
    1a36:	20 c0       	rjmp	.+64     	; 0x1a78 <xQueueGenericSend+0x116>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1a38:	0f b6       	in	r0, 0x3f	; 63
    1a3a:	f8 94       	cli
    1a3c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a3e:	f8 01       	movw	r30, r16
    1a40:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a46:	f8 01       	movw	r30, r16
    1a48:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a4a:	98 13       	cpse	r25, r24
    1a4c:	0f c0       	rjmp	.+30     	; 0x1a6c <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a4e:	6c 81       	ldd	r22, Y+4	; 0x04
    1a50:	7d 81       	ldd	r23, Y+5	; 0x05
    1a52:	c7 01       	movw	r24, r14
    1a54:	0e 94 02 12 	call	0x2404	; 0x2404 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1a58:	c8 01       	movw	r24, r16
    1a5a:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1a5e:	0e 94 bf 10 	call	0x217e	; 0x217e <xTaskResumeAll>
    1a62:	81 11       	cpse	r24, r1
    1a64:	9a cf       	rjmp	.-204    	; 0x199a <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1a66:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    1a6a:	97 cf       	rjmp	.-210    	; 0x199a <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1a6c:	c8 01       	movw	r24, r16
    1a6e:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a72:	0e 94 bf 10 	call	0x217e	; 0x217e <xTaskResumeAll>
    1a76:	91 cf       	rjmp	.-222    	; 0x199a <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1a78:	c8 01       	movw	r24, r16
    1a7a:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1a7e:	0e 94 bf 10 	call	0x217e	; 0x217e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1a82:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1a84:	0f 90       	pop	r0
    1a86:	0f 90       	pop	r0
    1a88:	0f 90       	pop	r0
    1a8a:	0f 90       	pop	r0
    1a8c:	0f 90       	pop	r0
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
    1a92:	1f 91       	pop	r17
    1a94:	0f 91       	pop	r16
    1a96:	ff 90       	pop	r15
    1a98:	ef 90       	pop	r14
    1a9a:	df 90       	pop	r13
    1a9c:	cf 90       	pop	r12
    1a9e:	bf 90       	pop	r11
    1aa0:	af 90       	pop	r10
    1aa2:	9f 90       	pop	r9
    1aa4:	08 95       	ret

00001aa6 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1aa6:	cf 93       	push	r28
    1aa8:	df 93       	push	r29
    1aaa:	fc 01       	movw	r30, r24
    1aac:	eb 01       	movw	r28, r22
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1aae:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ab0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ab2:	98 17       	cp	r25, r24
    1ab4:	c8 f4       	brcc	.+50     	; 0x1ae8 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    1ab6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ab8:	8f 5f       	subi	r24, 0xFF	; 255
    1aba:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1abc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1abe:	8f 3f       	cpi	r24, 0xFF	; 255
    1ac0:	71 f4       	brne	.+28     	; 0x1ade <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ac2:	81 89       	ldd	r24, Z+17	; 0x11
    1ac4:	88 23       	and	r24, r24
    1ac6:	91 f0       	breq	.+36     	; 0x1aec <xQueueGiveFromISR+0x46>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ac8:	cf 01       	movw	r24, r30
    1aca:	41 96       	adiw	r24, 0x11	; 17
    1acc:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskRemoveFromEventList>
    1ad0:	88 23       	and	r24, r24
    1ad2:	71 f0       	breq	.+28     	; 0x1af0 <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1ad4:	20 97       	sbiw	r28, 0x00	; 0
    1ad6:	71 f0       	breq	.+28     	; 0x1af4 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
    1ada:	88 83       	st	Y, r24
    1adc:	0c c0       	rjmp	.+24     	; 0x1af6 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1ade:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ae0:	8f 5f       	subi	r24, 0xFF	; 255
    1ae2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1ae4:	81 e0       	ldi	r24, 0x01	; 1
    1ae6:	07 c0       	rjmp	.+14     	; 0x1af6 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
    1aea:	05 c0       	rjmp	.+10     	; 0x1af6 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1aec:	81 e0       	ldi	r24, 0x01	; 1
    1aee:	03 c0       	rjmp	.+6      	; 0x1af6 <xQueueGiveFromISR+0x50>
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	01 c0       	rjmp	.+2      	; 0x1af6 <xQueueGiveFromISR+0x50>
    1af4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1af6:	df 91       	pop	r29
    1af8:	cf 91       	pop	r28
    1afa:	08 95       	ret

00001afc <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1afc:	9f 92       	push	r9
    1afe:	af 92       	push	r10
    1b00:	bf 92       	push	r11
    1b02:	cf 92       	push	r12
    1b04:	df 92       	push	r13
    1b06:	ef 92       	push	r14
    1b08:	ff 92       	push	r15
    1b0a:	0f 93       	push	r16
    1b0c:	1f 93       	push	r17
    1b0e:	cf 93       	push	r28
    1b10:	df 93       	push	r29
    1b12:	00 d0       	rcall	.+0      	; 0x1b14 <xQueueGenericReceive+0x18>
    1b14:	00 d0       	rcall	.+0      	; 0x1b16 <xQueueGenericReceive+0x1a>
    1b16:	1f 92       	push	r1
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
    1b1c:	8c 01       	movw	r16, r24
    1b1e:	6b 01       	movw	r12, r22
    1b20:	5d 83       	std	Y+5, r21	; 0x05
    1b22:	4c 83       	std	Y+4, r20	; 0x04
    1b24:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1b26:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1b28:	99 24       	eor	r9, r9
    1b2a:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b2c:	7c 01       	movw	r14, r24
    1b2e:	81 e1       	ldi	r24, 0x11	; 17
    1b30:	e8 0e       	add	r14, r24
    1b32:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1b34:	0f b6       	in	r0, 0x3f	; 63
    1b36:	f8 94       	cli
    1b38:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b3a:	f8 01       	movw	r30, r16
    1b3c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b3e:	88 23       	and	r24, r24
    1b40:	49 f1       	breq	.+82     	; 0x1b94 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1b42:	e6 80       	ldd	r14, Z+6	; 0x06
    1b44:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b46:	b6 01       	movw	r22, r12
    1b48:	c8 01       	movw	r24, r16
    1b4a:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1b4e:	b1 10       	cpse	r11, r1
    1b50:	10 c0       	rjmp	.+32     	; 0x1b72 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1b52:	f8 01       	movw	r30, r16
    1b54:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b56:	81 50       	subi	r24, 0x01	; 1
    1b58:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b5a:	80 85       	ldd	r24, Z+8	; 0x08
    1b5c:	88 23       	and	r24, r24
    1b5e:	b1 f0       	breq	.+44     	; 0x1b8c <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1b60:	c8 01       	movw	r24, r16
    1b62:	08 96       	adiw	r24, 0x08	; 8
    1b64:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskRemoveFromEventList>
    1b68:	81 30       	cpi	r24, 0x01	; 1
    1b6a:	81 f4       	brne	.+32     	; 0x1b8c <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1b6c:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    1b70:	0d c0       	rjmp	.+26     	; 0x1b8c <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1b72:	f8 01       	movw	r30, r16
    1b74:	f7 82       	std	Z+7, r15	; 0x07
    1b76:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b78:	81 89       	ldd	r24, Z+17	; 0x11
    1b7a:	88 23       	and	r24, r24
    1b7c:	39 f0       	breq	.+14     	; 0x1b8c <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b7e:	c8 01       	movw	r24, r16
    1b80:	41 96       	adiw	r24, 0x11	; 17
    1b82:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskRemoveFromEventList>
    1b86:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1b88:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1b8c:	0f 90       	pop	r0
    1b8e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b90:	81 e0       	ldi	r24, 0x01	; 1
    1b92:	4f c0       	rjmp	.+158    	; 0x1c32 <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b94:	4c 81       	ldd	r20, Y+4	; 0x04
    1b96:	5d 81       	ldd	r21, Y+5	; 0x05
    1b98:	45 2b       	or	r20, r21
    1b9a:	21 f4       	brne	.+8      	; 0x1ba4 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b9c:	0f 90       	pop	r0
    1b9e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ba0:	80 e0       	ldi	r24, 0x00	; 0
    1ba2:	47 c0       	rjmp	.+142    	; 0x1c32 <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ba4:	a1 10       	cpse	r10, r1
    1ba6:	05 c0       	rjmp	.+10     	; 0x1bb2 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ba8:	ce 01       	movw	r24, r28
    1baa:	01 96       	adiw	r24, 0x01	; 1
    1bac:	0e 94 67 12 	call	0x24ce	; 0x24ce <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1bb0:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1bb2:	0f 90       	pop	r0
    1bb4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1bb6:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	0f 92       	push	r0
    1bc0:	f8 01       	movw	r30, r16
    1bc2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1bc4:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc6:	09 f4       	brne	.+2      	; 0x1bca <xQueueGenericReceive+0xce>
    1bc8:	15 8e       	std	Z+29, r1	; 0x1d
    1bca:	f8 01       	movw	r30, r16
    1bcc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bce:	8f 3f       	cpi	r24, 0xFF	; 255
    1bd0:	09 f4       	brne	.+2      	; 0x1bd4 <xQueueGenericReceive+0xd8>
    1bd2:	16 8e       	std	Z+30, r1	; 0x1e
    1bd4:	0f 90       	pop	r0
    1bd6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1bd8:	be 01       	movw	r22, r28
    1bda:	6c 5f       	subi	r22, 0xFC	; 252
    1bdc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bde:	ce 01       	movw	r24, r28
    1be0:	01 96       	adiw	r24, 0x01	; 1
    1be2:	0e 94 72 12 	call	0x24e4	; 0x24e4 <xTaskCheckForTimeOut>
    1be6:	81 11       	cpse	r24, r1
    1be8:	1e c0       	rjmp	.+60     	; 0x1c26 <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1bea:	0f b6       	in	r0, 0x3f	; 63
    1bec:	f8 94       	cli
    1bee:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1bf0:	f8 01       	movw	r30, r16
    1bf2:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1bf4:	0f 90       	pop	r0
    1bf6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bf8:	81 11       	cpse	r24, r1
    1bfa:	0f c0       	rjmp	.+30     	; 0x1c1a <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bfc:	6c 81       	ldd	r22, Y+4	; 0x04
    1bfe:	7d 81       	ldd	r23, Y+5	; 0x05
    1c00:	c7 01       	movw	r24, r14
    1c02:	0e 94 02 12 	call	0x2404	; 0x2404 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c06:	c8 01       	movw	r24, r16
    1c08:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c0c:	0e 94 bf 10 	call	0x217e	; 0x217e <xTaskResumeAll>
    1c10:	81 11       	cpse	r24, r1
    1c12:	90 cf       	rjmp	.-224    	; 0x1b34 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1c14:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    1c18:	8d cf       	rjmp	.-230    	; 0x1b34 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c1a:	c8 01       	movw	r24, r16
    1c1c:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c20:	0e 94 bf 10 	call	0x217e	; 0x217e <xTaskResumeAll>
    1c24:	87 cf       	rjmp	.-242    	; 0x1b34 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1c26:	c8 01       	movw	r24, r16
    1c28:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c2c:	0e 94 bf 10 	call	0x217e	; 0x217e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1c30:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1c32:	0f 90       	pop	r0
    1c34:	0f 90       	pop	r0
    1c36:	0f 90       	pop	r0
    1c38:	0f 90       	pop	r0
    1c3a:	0f 90       	pop	r0
    1c3c:	df 91       	pop	r29
    1c3e:	cf 91       	pop	r28
    1c40:	1f 91       	pop	r17
    1c42:	0f 91       	pop	r16
    1c44:	ff 90       	pop	r15
    1c46:	ef 90       	pop	r14
    1c48:	df 90       	pop	r13
    1c4a:	cf 90       	pop	r12
    1c4c:	bf 90       	pop	r11
    1c4e:	af 90       	pop	r10
    1c50:	9f 90       	pop	r9
    1c52:	08 95       	ret

00001c54 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1c54:	0f 93       	push	r16
    1c56:	1f 93       	push	r17
    1c58:	cf 93       	push	r28
    1c5a:	df 93       	push	r29
    1c5c:	ec 01       	movw	r28, r24
    1c5e:	8a 01       	movw	r16, r20
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c60:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c62:	88 23       	and	r24, r24
    1c64:	f1 f0       	breq	.+60     	; 0x1ca2 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c66:	ce 01       	movw	r24, r28
    1c68:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1c6c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c6e:	81 50       	subi	r24, 0x01	; 1
    1c70:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1c72:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c74:	8f 3f       	cpi	r24, 0xFF	; 255
    1c76:	81 f4       	brne	.+32     	; 0x1c98 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c78:	88 85       	ldd	r24, Y+8	; 0x08
    1c7a:	88 23       	and	r24, r24
    1c7c:	a1 f0       	breq	.+40     	; 0x1ca6 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c7e:	ce 01       	movw	r24, r28
    1c80:	08 96       	adiw	r24, 0x08	; 8
    1c82:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskRemoveFromEventList>
    1c86:	88 23       	and	r24, r24
    1c88:	81 f0       	breq	.+32     	; 0x1caa <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1c8a:	01 15       	cp	r16, r1
    1c8c:	11 05       	cpc	r17, r1
    1c8e:	79 f0       	breq	.+30     	; 0x1cae <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1c90:	81 e0       	ldi	r24, 0x01	; 1
    1c92:	f8 01       	movw	r30, r16
    1c94:	80 83       	st	Z, r24
    1c96:	0c c0       	rjmp	.+24     	; 0x1cb0 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1c98:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c9a:	8f 5f       	subi	r24, 0xFF	; 255
    1c9c:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1c9e:	81 e0       	ldi	r24, 0x01	; 1
    1ca0:	07 c0       	rjmp	.+14     	; 0x1cb0 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1ca2:	80 e0       	ldi	r24, 0x00	; 0
    1ca4:	05 c0       	rjmp	.+10     	; 0x1cb0 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1ca6:	81 e0       	ldi	r24, 0x01	; 1
    1ca8:	03 c0       	rjmp	.+6      	; 0x1cb0 <xQueueReceiveFromISR+0x5c>
    1caa:	81 e0       	ldi	r24, 0x01	; 1
    1cac:	01 c0       	rjmp	.+2      	; 0x1cb0 <xQueueReceiveFromISR+0x5c>
    1cae:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1cb0:	df 91       	pop	r29
    1cb2:	cf 91       	pop	r28
    1cb4:	1f 91       	pop	r17
    1cb6:	0f 91       	pop	r16
    1cb8:	08 95       	ret

00001cba <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1cba:	c6 ea       	ldi	r28, 0xA6	; 166
    1cbc:	d7 e0       	ldi	r29, 0x07	; 7
    1cbe:	88 81       	ld	r24, Y
    1cc0:	82 30       	cpi	r24, 0x02	; 2
    1cc2:	08 f4       	brcc	.+2      	; 0x1cc6 <prvIdleTask+0xc>
    1cc4:	ff cf       	rjmp	.-2      	; 0x1cc4 <prvIdleTask+0xa>
			{
				taskYIELD();
    1cc6:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    1cca:	f9 cf       	rjmp	.-14     	; 0x1cbe <prvIdleTask+0x4>

00001ccc <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    1ccc:	cf 93       	push	r28
    1cce:	df 93       	push	r29
    1cd0:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1cd2:	e0 91 ca 07 	lds	r30, 0x07CA
    1cd6:	f0 91 cb 07 	lds	r31, 0x07CB
    1cda:	93 83       	std	Z+3, r25	; 0x03
    1cdc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1cde:	80 91 84 07 	lds	r24, 0x0784
    1ce2:	90 91 85 07 	lds	r25, 0x0785
    1ce6:	c8 17       	cp	r28, r24
    1ce8:	d9 07       	cpc	r29, r25
    1cea:	68 f4       	brcc	.+26     	; 0x1d06 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1cec:	60 91 ca 07 	lds	r22, 0x07CA
    1cf0:	70 91 cb 07 	lds	r23, 0x07CB
    1cf4:	80 91 90 07 	lds	r24, 0x0790
    1cf8:	90 91 91 07 	lds	r25, 0x0791
    1cfc:	6e 5f       	subi	r22, 0xFE	; 254
    1cfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1d00:	0e 94 aa 09 	call	0x1354	; 0x1354 <vListInsert>
    1d04:	17 c0       	rjmp	.+46     	; 0x1d34 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1d06:	60 91 ca 07 	lds	r22, 0x07CA
    1d0a:	70 91 cb 07 	lds	r23, 0x07CB
    1d0e:	80 91 92 07 	lds	r24, 0x0792
    1d12:	90 91 93 07 	lds	r25, 0x0793
    1d16:	6e 5f       	subi	r22, 0xFE	; 254
    1d18:	7f 4f       	sbci	r23, 0xFF	; 255
    1d1a:	0e 94 aa 09 	call	0x1354	; 0x1354 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1d1e:	80 91 7c 07 	lds	r24, 0x077C
    1d22:	90 91 7d 07 	lds	r25, 0x077D
    1d26:	c8 17       	cp	r28, r24
    1d28:	d9 07       	cpc	r29, r25
    1d2a:	20 f4       	brcc	.+8      	; 0x1d34 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1d2c:	d0 93 7d 07 	sts	0x077D, r29
    1d30:	c0 93 7c 07 	sts	0x077C, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1d34:	df 91       	pop	r29
    1d36:	cf 91       	pop	r28
    1d38:	08 95       	ret

00001d3a <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    1d3a:	4f 92       	push	r4
    1d3c:	5f 92       	push	r5
    1d3e:	6f 92       	push	r6
    1d40:	7f 92       	push	r7
    1d42:	8f 92       	push	r8
    1d44:	9f 92       	push	r9
    1d46:	af 92       	push	r10
    1d48:	bf 92       	push	r11
    1d4a:	cf 92       	push	r12
    1d4c:	df 92       	push	r13
    1d4e:	ef 92       	push	r14
    1d50:	ff 92       	push	r15
    1d52:	0f 93       	push	r16
    1d54:	1f 93       	push	r17
    1d56:	cf 93       	push	r28
    1d58:	df 93       	push	r29
    1d5a:	4c 01       	movw	r8, r24
    1d5c:	5b 01       	movw	r10, r22
    1d5e:	2a 01       	movw	r4, r20
    1d60:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1d62:	c1 14       	cp	r12, r1
    1d64:	d1 04       	cpc	r13, r1
    1d66:	39 f4       	brne	.+14     	; 0x1d76 <xTaskGenericCreate+0x3c>
    1d68:	ca 01       	movw	r24, r20
    1d6a:	0e 94 5f 0b 	call	0x16be	; 0x16be <pvPortMalloc>
    1d6e:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
    1d70:	00 97       	sbiw	r24, 0x00	; 0
    1d72:	09 f4       	brne	.+2      	; 0x1d76 <xTaskGenericCreate+0x3c>
    1d74:	d5 c0       	rjmp	.+426    	; 0x1f20 <xTaskGenericCreate+0x1e6>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    1d76:	86 e2       	ldi	r24, 0x26	; 38
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	0e 94 5f 0b 	call	0x16be	; 0x16be <pvPortMalloc>
    1d7e:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
    1d80:	00 97       	sbiw	r24, 0x00	; 0
    1d82:	71 f0       	breq	.+28     	; 0x1da0 <xTaskGenericCreate+0x66>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    1d84:	d8 8e       	std	Y+24, r13	; 0x18
    1d86:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    1d88:	81 e0       	ldi	r24, 0x01	; 1
    1d8a:	48 1a       	sub	r4, r24
    1d8c:	51 08       	sbc	r5, r1
    1d8e:	c4 0c       	add	r12, r4
    1d90:	d5 1c       	adc	r13, r5
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1d92:	d5 01       	movw	r26, r10
    1d94:	8c 91       	ld	r24, X
    1d96:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1d98:	8c 91       	ld	r24, X
    1d9a:	81 11       	cpse	r24, r1
    1d9c:	05 c0       	rjmp	.+10     	; 0x1da8 <xTaskGenericCreate+0x6e>
    1d9e:	15 c0       	rjmp	.+42     	; 0x1dca <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    1da0:	c6 01       	movw	r24, r12
    1da2:	0e 94 94 0b 	call	0x1728	; 0x1728 <vPortFree>
    1da6:	bc c0       	rjmp	.+376    	; 0x1f20 <xTaskGenericCreate+0x1e6>
    1da8:	ae 01       	movw	r20, r28
    1daa:	46 5e       	subi	r20, 0xE6	; 230
    1dac:	5f 4f       	sbci	r21, 0xFF	; 255
    1dae:	f5 01       	movw	r30, r10
    1db0:	31 96       	adiw	r30, 0x01	; 1
		pxTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1db2:	27 e0       	ldi	r18, 0x07	; 7
    1db4:	cf 01       	movw	r24, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1db6:	31 91       	ld	r19, Z+
    1db8:	da 01       	movw	r26, r20
    1dba:	3d 93       	st	X+, r19
    1dbc:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1dbe:	dc 01       	movw	r26, r24
    1dc0:	8c 91       	ld	r24, X
    1dc2:	88 23       	and	r24, r24
    1dc4:	11 f0       	breq	.+4      	; 0x1dca <xTaskGenericCreate+0x90>
    1dc6:	21 50       	subi	r18, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1dc8:	a9 f7       	brne	.-22     	; 0x1db4 <xTaskGenericCreate+0x7a>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1dca:	18 a2       	std	Y+32, r1	; 0x20
    1dcc:	10 2f       	mov	r17, r16
    1dce:	04 30       	cpi	r16, 0x04	; 4
    1dd0:	08 f0       	brcs	.+2      	; 0x1dd4 <xTaskGenericCreate+0x9a>
    1dd2:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    1dd4:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1dd6:	5e 01       	movw	r10, r28
    1dd8:	b2 e0       	ldi	r27, 0x02	; 2
    1dda:	ab 0e       	add	r10, r27
    1ddc:	b1 1c       	adc	r11, r1
    1dde:	c5 01       	movw	r24, r10
    1de0:	0e 94 85 09 	call	0x130a	; 0x130a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1de4:	ce 01       	movw	r24, r28
    1de6:	0c 96       	adiw	r24, 0x0c	; 12
    1de8:	0e 94 85 09 	call	0x130a	; 0x130a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1dec:	d9 87       	std	Y+9, r29	; 0x09
    1dee:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1df0:	84 e0       	ldi	r24, 0x04	; 4
    1df2:	90 e0       	ldi	r25, 0x00	; 0
    1df4:	81 1b       	sub	r24, r17
    1df6:	91 09       	sbc	r25, r1
    1df8:	9d 87       	std	Y+13, r25	; 0x0d
    1dfa:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1dfc:	db 8b       	std	Y+19, r29	; 0x13
    1dfe:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    1e00:	19 a2       	std	Y+33, r1	; 0x21
    1e02:	1a a2       	std	Y+34, r1	; 0x22
    1e04:	1b a2       	std	Y+35, r1	; 0x23
    1e06:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    1e08:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1e0a:	a3 01       	movw	r20, r6
    1e0c:	b4 01       	movw	r22, r8
    1e0e:	c6 01       	movw	r24, r12
    1e10:	0e 94 01 0a 	call	0x1402	; 0x1402 <pxPortInitialiseStack>
    1e14:	99 83       	std	Y+1, r25	; 0x01
    1e16:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    1e18:	e1 14       	cp	r14, r1
    1e1a:	f1 04       	cpc	r15, r1
    1e1c:	19 f0       	breq	.+6      	; 0x1e24 <xTaskGenericCreate+0xea>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1e1e:	f7 01       	movw	r30, r14
    1e20:	d1 83       	std	Z+1, r29	; 0x01
    1e22:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1e2a:	80 91 86 07 	lds	r24, 0x0786
    1e2e:	8f 5f       	subi	r24, 0xFF	; 255
    1e30:	80 93 86 07 	sts	0x0786, r24
			if( pxCurrentTCB == NULL )
    1e34:	80 91 ca 07 	lds	r24, 0x07CA
    1e38:	90 91 cb 07 	lds	r25, 0x07CB
    1e3c:	89 2b       	or	r24, r25
    1e3e:	89 f5       	brne	.+98     	; 0x1ea2 <xTaskGenericCreate+0x168>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1e40:	d0 93 cb 07 	sts	0x07CB, r29
    1e44:	c0 93 ca 07 	sts	0x07CA, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1e48:	80 91 86 07 	lds	r24, 0x0786
    1e4c:	81 30       	cpi	r24, 0x01	; 1
    1e4e:	c1 f5       	brne	.+112    	; 0x1ec0 <xTaskGenericCreate+0x186>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1e50:	86 ea       	ldi	r24, 0xA6	; 166
    1e52:	97 e0       	ldi	r25, 0x07	; 7
    1e54:	0e 94 77 09 	call	0x12ee	; 0x12ee <vListInitialise>
    1e58:	8f ea       	ldi	r24, 0xAF	; 175
    1e5a:	97 e0       	ldi	r25, 0x07	; 7
    1e5c:	0e 94 77 09 	call	0x12ee	; 0x12ee <vListInitialise>
    1e60:	88 eb       	ldi	r24, 0xB8	; 184
    1e62:	97 e0       	ldi	r25, 0x07	; 7
    1e64:	0e 94 77 09 	call	0x12ee	; 0x12ee <vListInitialise>
    1e68:	81 ec       	ldi	r24, 0xC1	; 193
    1e6a:	97 e0       	ldi	r25, 0x07	; 7
    1e6c:	0e 94 77 09 	call	0x12ee	; 0x12ee <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    1e70:	8d e9       	ldi	r24, 0x9D	; 157
    1e72:	97 e0       	ldi	r25, 0x07	; 7
    1e74:	0e 94 77 09 	call	0x12ee	; 0x12ee <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1e78:	84 e9       	ldi	r24, 0x94	; 148
    1e7a:	97 e0       	ldi	r25, 0x07	; 7
    1e7c:	0e 94 77 09 	call	0x12ee	; 0x12ee <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1e80:	87 e8       	ldi	r24, 0x87	; 135
    1e82:	97 e0       	ldi	r25, 0x07	; 7
    1e84:	0e 94 77 09 	call	0x12ee	; 0x12ee <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1e88:	8d e9       	ldi	r24, 0x9D	; 157
    1e8a:	97 e0       	ldi	r25, 0x07	; 7
    1e8c:	90 93 93 07 	sts	0x0793, r25
    1e90:	80 93 92 07 	sts	0x0792, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1e94:	84 e9       	ldi	r24, 0x94	; 148
    1e96:	97 e0       	ldi	r25, 0x07	; 7
    1e98:	90 93 91 07 	sts	0x0791, r25
    1e9c:	80 93 90 07 	sts	0x0790, r24
    1ea0:	0f c0       	rjmp	.+30     	; 0x1ec0 <xTaskGenericCreate+0x186>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1ea2:	80 91 82 07 	lds	r24, 0x0782
    1ea6:	81 11       	cpse	r24, r1
    1ea8:	0b c0       	rjmp	.+22     	; 0x1ec0 <xTaskGenericCreate+0x186>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1eaa:	e0 91 ca 07 	lds	r30, 0x07CA
    1eae:	f0 91 cb 07 	lds	r31, 0x07CB
    1eb2:	86 89       	ldd	r24, Z+22	; 0x16
    1eb4:	08 17       	cp	r16, r24
    1eb6:	20 f0       	brcs	.+8      	; 0x1ec0 <xTaskGenericCreate+0x186>
					{
						pxCurrentTCB = pxNewTCB;
    1eb8:	d0 93 cb 07 	sts	0x07CB, r29
    1ebc:	c0 93 ca 07 	sts	0x07CA, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    1ec0:	80 91 7e 07 	lds	r24, 0x077E
    1ec4:	8f 5f       	subi	r24, 0xFF	; 255
    1ec6:	80 93 7e 07 	sts	0x077E, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    1eca:	8e 89       	ldd	r24, Y+22	; 0x16
    1ecc:	90 91 83 07 	lds	r25, 0x0783
    1ed0:	98 17       	cp	r25, r24
    1ed2:	10 f4       	brcc	.+4      	; 0x1ed8 <xTaskGenericCreate+0x19e>
    1ed4:	80 93 83 07 	sts	0x0783, r24
    1ed8:	90 e0       	ldi	r25, 0x00	; 0
    1eda:	9c 01       	movw	r18, r24
    1edc:	22 0f       	add	r18, r18
    1ede:	33 1f       	adc	r19, r19
    1ee0:	22 0f       	add	r18, r18
    1ee2:	33 1f       	adc	r19, r19
    1ee4:	22 0f       	add	r18, r18
    1ee6:	33 1f       	adc	r19, r19
    1ee8:	82 0f       	add	r24, r18
    1eea:	93 1f       	adc	r25, r19
    1eec:	b5 01       	movw	r22, r10
    1eee:	8a 55       	subi	r24, 0x5A	; 90
    1ef0:	98 4f       	sbci	r25, 0xF8	; 248
    1ef2:	0e 94 89 09 	call	0x1312	; 0x1312 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1ef6:	0f 90       	pop	r0
    1ef8:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1efa:	80 91 82 07 	lds	r24, 0x0782
    1efe:	88 23       	and	r24, r24
    1f00:	59 f0       	breq	.+22     	; 0x1f18 <xTaskGenericCreate+0x1de>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1f02:	e0 91 ca 07 	lds	r30, 0x07CA
    1f06:	f0 91 cb 07 	lds	r31, 0x07CB
    1f0a:	86 89       	ldd	r24, Z+22	; 0x16
    1f0c:	80 17       	cp	r24, r16
    1f0e:	30 f4       	brcc	.+12     	; 0x1f1c <xTaskGenericCreate+0x1e2>
			{
				taskYIELD_IF_USING_PREEMPTION();
    1f10:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
    1f14:	81 e0       	ldi	r24, 0x01	; 1
    1f16:	05 c0       	rjmp	.+10     	; 0x1f22 <xTaskGenericCreate+0x1e8>
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	03 c0       	rjmp	.+6      	; 0x1f22 <xTaskGenericCreate+0x1e8>
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	01 c0       	rjmp	.+2      	; 0x1f22 <xTaskGenericCreate+0x1e8>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f20:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    1f22:	df 91       	pop	r29
    1f24:	cf 91       	pop	r28
    1f26:	1f 91       	pop	r17
    1f28:	0f 91       	pop	r16
    1f2a:	ff 90       	pop	r15
    1f2c:	ef 90       	pop	r14
    1f2e:	df 90       	pop	r13
    1f30:	cf 90       	pop	r12
    1f32:	bf 90       	pop	r11
    1f34:	af 90       	pop	r10
    1f36:	9f 90       	pop	r9
    1f38:	8f 90       	pop	r8
    1f3a:	7f 90       	pop	r7
    1f3c:	6f 90       	pop	r6
    1f3e:	5f 90       	pop	r5
    1f40:	4f 90       	pop	r4
    1f42:	08 95       	ret

00001f44 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1f44:	af 92       	push	r10
    1f46:	bf 92       	push	r11
    1f48:	cf 92       	push	r12
    1f4a:	df 92       	push	r13
    1f4c:	ef 92       	push	r14
    1f4e:	ff 92       	push	r15
    1f50:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    1f52:	a1 2c       	mov	r10, r1
    1f54:	b1 2c       	mov	r11, r1
    1f56:	c1 2c       	mov	r12, r1
    1f58:	d1 2c       	mov	r13, r1
    1f5a:	e1 2c       	mov	r14, r1
    1f5c:	f1 2c       	mov	r15, r1
    1f5e:	00 e0       	ldi	r16, 0x00	; 0
    1f60:	20 e0       	ldi	r18, 0x00	; 0
    1f62:	30 e0       	ldi	r19, 0x00	; 0
    1f64:	45 e5       	ldi	r20, 0x55	; 85
    1f66:	50 e0       	ldi	r21, 0x00	; 0
    1f68:	61 e2       	ldi	r22, 0x21	; 33
    1f6a:	71 e0       	ldi	r23, 0x01	; 1
    1f6c:	8d e5       	ldi	r24, 0x5D	; 93
    1f6e:	9e e0       	ldi	r25, 0x0E	; 14
    1f70:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1f74:	81 30       	cpi	r24, 0x01	; 1
    1f76:	81 f4       	brne	.+32     	; 0x1f98 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1f78:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1f7a:	8f ef       	ldi	r24, 0xFF	; 255
    1f7c:	9f ef       	ldi	r25, 0xFF	; 255
    1f7e:	90 93 7d 07 	sts	0x077D, r25
    1f82:	80 93 7c 07 	sts	0x077C, r24
		xSchedulerRunning = pdTRUE;
    1f86:	81 e0       	ldi	r24, 0x01	; 1
    1f88:	80 93 82 07 	sts	0x0782, r24
		xTickCount = ( TickType_t ) 0U;
    1f8c:	10 92 85 07 	sts	0x0785, r1
    1f90:	10 92 84 07 	sts	0x0784, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1f94:	0e 94 6d 0a 	call	0x14da	; 0x14da <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    1f98:	0f 91       	pop	r16
    1f9a:	ff 90       	pop	r15
    1f9c:	ef 90       	pop	r14
    1f9e:	df 90       	pop	r13
    1fa0:	cf 90       	pop	r12
    1fa2:	bf 90       	pop	r11
    1fa4:	af 90       	pop	r10
    1fa6:	08 95       	ret

00001fa8 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1fa8:	80 91 7b 07 	lds	r24, 0x077B
    1fac:	8f 5f       	subi	r24, 0xFF	; 255
    1fae:	80 93 7b 07 	sts	0x077B, r24
    1fb2:	08 95       	ret

00001fb4 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1fb4:	0f b6       	in	r0, 0x3f	; 63
    1fb6:	f8 94       	cli
    1fb8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1fba:	80 91 84 07 	lds	r24, 0x0784
    1fbe:	90 91 85 07 	lds	r25, 0x0785
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1fc2:	0f 90       	pop	r0
    1fc4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1fc6:	08 95       	ret

00001fc8 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1fc8:	cf 92       	push	r12
    1fca:	df 92       	push	r13
    1fcc:	ef 92       	push	r14
    1fce:	ff 92       	push	r15
    1fd0:	0f 93       	push	r16
    1fd2:	1f 93       	push	r17
    1fd4:	cf 93       	push	r28
    1fd6:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1fd8:	80 91 7b 07 	lds	r24, 0x077B
    1fdc:	81 11       	cpse	r24, r1
    1fde:	b6 c0       	rjmp	.+364    	; 0x214c <xTaskIncrementTick+0x184>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    1fe0:	80 91 84 07 	lds	r24, 0x0784
    1fe4:	90 91 85 07 	lds	r25, 0x0785
    1fe8:	01 96       	adiw	r24, 0x01	; 1
    1fea:	90 93 85 07 	sts	0x0785, r25
    1fee:	80 93 84 07 	sts	0x0784, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1ff2:	e0 90 84 07 	lds	r14, 0x0784
    1ff6:	f0 90 85 07 	lds	r15, 0x0785

			if( xConstTickCount == ( TickType_t ) 0U )
    1ffa:	e1 14       	cp	r14, r1
    1ffc:	f1 04       	cpc	r15, r1
    1ffe:	99 f5       	brne	.+102    	; 0x2066 <xTaskIncrementTick+0x9e>
			{
				taskSWITCH_DELAYED_LISTS();
    2000:	80 91 92 07 	lds	r24, 0x0792
    2004:	90 91 93 07 	lds	r25, 0x0793
    2008:	20 91 90 07 	lds	r18, 0x0790
    200c:	30 91 91 07 	lds	r19, 0x0791
    2010:	30 93 93 07 	sts	0x0793, r19
    2014:	20 93 92 07 	sts	0x0792, r18
    2018:	90 93 91 07 	sts	0x0791, r25
    201c:	80 93 90 07 	sts	0x0790, r24
    2020:	80 91 7f 07 	lds	r24, 0x077F
    2024:	8f 5f       	subi	r24, 0xFF	; 255
    2026:	80 93 7f 07 	sts	0x077F, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    202a:	e0 91 92 07 	lds	r30, 0x0792
    202e:	f0 91 93 07 	lds	r31, 0x0793
    2032:	80 81       	ld	r24, Z
    2034:	81 11       	cpse	r24, r1
    2036:	07 c0       	rjmp	.+14     	; 0x2046 <xTaskIncrementTick+0x7e>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    2038:	8f ef       	ldi	r24, 0xFF	; 255
    203a:	9f ef       	ldi	r25, 0xFF	; 255
    203c:	90 93 7d 07 	sts	0x077D, r25
    2040:	80 93 7c 07 	sts	0x077C, r24
    2044:	10 c0       	rjmp	.+32     	; 0x2066 <xTaskIncrementTick+0x9e>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2046:	e0 91 92 07 	lds	r30, 0x0792
    204a:	f0 91 93 07 	lds	r31, 0x0793
    204e:	05 80       	ldd	r0, Z+5	; 0x05
    2050:	f6 81       	ldd	r31, Z+6	; 0x06
    2052:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    2054:	06 80       	ldd	r0, Z+6	; 0x06
    2056:	f7 81       	ldd	r31, Z+7	; 0x07
    2058:	e0 2d       	mov	r30, r0
    205a:	82 81       	ldd	r24, Z+2	; 0x02
    205c:	93 81       	ldd	r25, Z+3	; 0x03
    205e:	90 93 7d 07 	sts	0x077D, r25
    2062:	80 93 7c 07 	sts	0x077C, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    2066:	80 91 7c 07 	lds	r24, 0x077C
    206a:	90 91 7d 07 	lds	r25, 0x077D
    206e:	e8 16       	cp	r14, r24
    2070:	f9 06       	cpc	r15, r25
    2072:	08 f4       	brcc	.+2      	; 0x2076 <xTaskIncrementTick+0xae>
    2074:	54 c0       	rjmp	.+168    	; 0x211e <xTaskIncrementTick+0x156>
    2076:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    2078:	cc 24       	eor	r12, r12
    207a:	c3 94       	inc	r12
    207c:	01 c0       	rjmp	.+2      	; 0x2080 <xTaskIncrementTick+0xb8>
    207e:	dc 2c       	mov	r13, r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2080:	e0 91 92 07 	lds	r30, 0x0792
    2084:	f0 91 93 07 	lds	r31, 0x0793
    2088:	80 81       	ld	r24, Z
    208a:	81 11       	cpse	r24, r1
    208c:	07 c0       	rjmp	.+14     	; 0x209c <xTaskIncrementTick+0xd4>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    208e:	8f ef       	ldi	r24, 0xFF	; 255
    2090:	9f ef       	ldi	r25, 0xFF	; 255
    2092:	90 93 7d 07 	sts	0x077D, r25
    2096:	80 93 7c 07 	sts	0x077C, r24
						break;
    209a:	42 c0       	rjmp	.+132    	; 0x2120 <xTaskIncrementTick+0x158>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    209c:	e0 91 92 07 	lds	r30, 0x0792
    20a0:	f0 91 93 07 	lds	r31, 0x0793
    20a4:	05 80       	ldd	r0, Z+5	; 0x05
    20a6:	f6 81       	ldd	r31, Z+6	; 0x06
    20a8:	e0 2d       	mov	r30, r0
    20aa:	c6 81       	ldd	r28, Z+6	; 0x06
    20ac:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    20ae:	2a 81       	ldd	r18, Y+2	; 0x02
    20b0:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    20b2:	e2 16       	cp	r14, r18
    20b4:	f3 06       	cpc	r15, r19
    20b6:	28 f4       	brcc	.+10     	; 0x20c2 <xTaskIncrementTick+0xfa>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    20b8:	30 93 7d 07 	sts	0x077D, r19
    20bc:	20 93 7c 07 	sts	0x077C, r18
							break;
    20c0:	2f c0       	rjmp	.+94     	; 0x2120 <xTaskIncrementTick+0x158>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    20c2:	8e 01       	movw	r16, r28
    20c4:	0e 5f       	subi	r16, 0xFE	; 254
    20c6:	1f 4f       	sbci	r17, 0xFF	; 255
    20c8:	c8 01       	movw	r24, r16
    20ca:	0e 94 db 09 	call	0x13b6	; 0x13b6 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    20ce:	8c 89       	ldd	r24, Y+20	; 0x14
    20d0:	9d 89       	ldd	r25, Y+21	; 0x15
    20d2:	89 2b       	or	r24, r25
    20d4:	21 f0       	breq	.+8      	; 0x20de <xTaskIncrementTick+0x116>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    20d6:	ce 01       	movw	r24, r28
    20d8:	0c 96       	adiw	r24, 0x0c	; 12
    20da:	0e 94 db 09 	call	0x13b6	; 0x13b6 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    20de:	2e 89       	ldd	r18, Y+22	; 0x16
    20e0:	80 91 83 07 	lds	r24, 0x0783
    20e4:	82 17       	cp	r24, r18
    20e6:	10 f4       	brcc	.+4      	; 0x20ec <xTaskIncrementTick+0x124>
    20e8:	20 93 83 07 	sts	0x0783, r18
    20ec:	30 e0       	ldi	r19, 0x00	; 0
    20ee:	c9 01       	movw	r24, r18
    20f0:	88 0f       	add	r24, r24
    20f2:	99 1f       	adc	r25, r25
    20f4:	88 0f       	add	r24, r24
    20f6:	99 1f       	adc	r25, r25
    20f8:	88 0f       	add	r24, r24
    20fa:	99 1f       	adc	r25, r25
    20fc:	82 0f       	add	r24, r18
    20fe:	93 1f       	adc	r25, r19
    2100:	b8 01       	movw	r22, r16
    2102:	8a 55       	subi	r24, 0x5A	; 90
    2104:	98 4f       	sbci	r25, 0xF8	; 248
    2106:	0e 94 89 09 	call	0x1312	; 0x1312 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    210a:	e0 91 ca 07 	lds	r30, 0x07CA
    210e:	f0 91 cb 07 	lds	r31, 0x07CB
    2112:	9e 89       	ldd	r25, Y+22	; 0x16
    2114:	86 89       	ldd	r24, Z+22	; 0x16
    2116:	98 17       	cp	r25, r24
    2118:	08 f0       	brcs	.+2      	; 0x211c <xTaskIncrementTick+0x154>
    211a:	b1 cf       	rjmp	.-158    	; 0x207e <xTaskIncrementTick+0xb6>
    211c:	b1 cf       	rjmp	.-158    	; 0x2080 <xTaskIncrementTick+0xb8>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    211e:	d1 2c       	mov	r13, r1
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2120:	e0 91 ca 07 	lds	r30, 0x07CA
    2124:	f0 91 cb 07 	lds	r31, 0x07CB
    2128:	86 89       	ldd	r24, Z+22	; 0x16
    212a:	90 e0       	ldi	r25, 0x00	; 0
    212c:	fc 01       	movw	r30, r24
    212e:	ee 0f       	add	r30, r30
    2130:	ff 1f       	adc	r31, r31
    2132:	ee 0f       	add	r30, r30
    2134:	ff 1f       	adc	r31, r31
    2136:	ee 0f       	add	r30, r30
    2138:	ff 1f       	adc	r31, r31
    213a:	8e 0f       	add	r24, r30
    213c:	9f 1f       	adc	r25, r31
    213e:	fc 01       	movw	r30, r24
    2140:	ea 55       	subi	r30, 0x5A	; 90
    2142:	f8 4f       	sbci	r31, 0xF8	; 248
    2144:	80 81       	ld	r24, Z
    2146:	82 30       	cpi	r24, 0x02	; 2
    2148:	40 f4       	brcc	.+16     	; 0x215a <xTaskIncrementTick+0x192>
    214a:	09 c0       	rjmp	.+18     	; 0x215e <xTaskIncrementTick+0x196>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    214c:	80 91 81 07 	lds	r24, 0x0781
    2150:	8f 5f       	subi	r24, 0xFF	; 255
    2152:	80 93 81 07 	sts	0x0781, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2156:	d1 2c       	mov	r13, r1
    2158:	02 c0       	rjmp	.+4      	; 0x215e <xTaskIncrementTick+0x196>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    215a:	dd 24       	eor	r13, r13
    215c:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    215e:	80 91 80 07 	lds	r24, 0x0780
    2162:	88 23       	and	r24, r24
    2164:	11 f0       	breq	.+4      	; 0x216a <xTaskIncrementTick+0x1a2>
		{
			xSwitchRequired = pdTRUE;
    2166:	dd 24       	eor	r13, r13
    2168:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    216a:	8d 2d       	mov	r24, r13
    216c:	df 91       	pop	r29
    216e:	cf 91       	pop	r28
    2170:	1f 91       	pop	r17
    2172:	0f 91       	pop	r16
    2174:	ff 90       	pop	r15
    2176:	ef 90       	pop	r14
    2178:	df 90       	pop	r13
    217a:	cf 90       	pop	r12
    217c:	08 95       	ret

0000217e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    217e:	df 92       	push	r13
    2180:	ef 92       	push	r14
    2182:	ff 92       	push	r15
    2184:	0f 93       	push	r16
    2186:	1f 93       	push	r17
    2188:	cf 93       	push	r28
    218a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    218c:	0f b6       	in	r0, 0x3f	; 63
    218e:	f8 94       	cli
    2190:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2192:	80 91 7b 07 	lds	r24, 0x077B
    2196:	81 50       	subi	r24, 0x01	; 1
    2198:	80 93 7b 07 	sts	0x077B, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    219c:	80 91 7b 07 	lds	r24, 0x077B
    21a0:	81 11       	cpse	r24, r1
    21a2:	61 c0       	rjmp	.+194    	; 0x2266 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    21a4:	80 91 86 07 	lds	r24, 0x0786
    21a8:	88 23       	and	r24, r24
    21aa:	09 f4       	brne	.+2      	; 0x21ae <xTaskResumeAll+0x30>
    21ac:	5e c0       	rjmp	.+188    	; 0x226a <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    21ae:	0f 2e       	mov	r0, r31
    21b0:	f7 e8       	ldi	r31, 0x87	; 135
    21b2:	ef 2e       	mov	r14, r31
    21b4:	f7 e0       	ldi	r31, 0x07	; 7
    21b6:	ff 2e       	mov	r15, r31
    21b8:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    21ba:	dd 24       	eor	r13, r13
    21bc:	d3 94       	inc	r13
    21be:	30 c0       	rjmp	.+96     	; 0x2220 <xTaskResumeAll+0xa2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    21c0:	e0 91 8c 07 	lds	r30, 0x078C
    21c4:	f0 91 8d 07 	lds	r31, 0x078D
    21c8:	c6 81       	ldd	r28, Z+6	; 0x06
    21ca:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    21cc:	ce 01       	movw	r24, r28
    21ce:	0c 96       	adiw	r24, 0x0c	; 12
    21d0:	0e 94 db 09 	call	0x13b6	; 0x13b6 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    21d4:	8e 01       	movw	r16, r28
    21d6:	0e 5f       	subi	r16, 0xFE	; 254
    21d8:	1f 4f       	sbci	r17, 0xFF	; 255
    21da:	c8 01       	movw	r24, r16
    21dc:	0e 94 db 09 	call	0x13b6	; 0x13b6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    21e0:	8e 89       	ldd	r24, Y+22	; 0x16
    21e2:	90 91 83 07 	lds	r25, 0x0783
    21e6:	98 17       	cp	r25, r24
    21e8:	10 f4       	brcc	.+4      	; 0x21ee <xTaskResumeAll+0x70>
    21ea:	80 93 83 07 	sts	0x0783, r24
    21ee:	90 e0       	ldi	r25, 0x00	; 0
    21f0:	9c 01       	movw	r18, r24
    21f2:	22 0f       	add	r18, r18
    21f4:	33 1f       	adc	r19, r19
    21f6:	22 0f       	add	r18, r18
    21f8:	33 1f       	adc	r19, r19
    21fa:	22 0f       	add	r18, r18
    21fc:	33 1f       	adc	r19, r19
    21fe:	82 0f       	add	r24, r18
    2200:	93 1f       	adc	r25, r19
    2202:	b8 01       	movw	r22, r16
    2204:	8a 55       	subi	r24, 0x5A	; 90
    2206:	98 4f       	sbci	r25, 0xF8	; 248
    2208:	0e 94 89 09 	call	0x1312	; 0x1312 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    220c:	e0 91 ca 07 	lds	r30, 0x07CA
    2210:	f0 91 cb 07 	lds	r31, 0x07CB
    2214:	9e 89       	ldd	r25, Y+22	; 0x16
    2216:	86 89       	ldd	r24, Z+22	; 0x16
    2218:	98 17       	cp	r25, r24
    221a:	10 f0       	brcs	.+4      	; 0x2220 <xTaskResumeAll+0xa2>
					{
						xYieldPending = pdTRUE;
    221c:	d0 92 80 07 	sts	0x0780, r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2220:	f7 01       	movw	r30, r14
    2222:	80 81       	ld	r24, Z
    2224:	81 11       	cpse	r24, r1
    2226:	cc cf       	rjmp	.-104    	; 0x21c0 <xTaskResumeAll+0x42>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    2228:	80 91 81 07 	lds	r24, 0x0781
    222c:	88 23       	and	r24, r24
    222e:	99 f0       	breq	.+38     	; 0x2256 <xTaskResumeAll+0xd8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    2230:	80 91 81 07 	lds	r24, 0x0781
    2234:	88 23       	and	r24, r24
    2236:	79 f0       	breq	.+30     	; 0x2256 <xTaskResumeAll+0xd8>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    2238:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    223a:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <xTaskIncrementTick>
    223e:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
    2240:	c0 93 80 07 	sts	0x0780, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    2244:	80 91 81 07 	lds	r24, 0x0781
    2248:	81 50       	subi	r24, 0x01	; 1
    224a:	80 93 81 07 	sts	0x0781, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    224e:	80 91 81 07 	lds	r24, 0x0781
    2252:	81 11       	cpse	r24, r1
    2254:	f2 cf       	rjmp	.-28     	; 0x223a <xTaskResumeAll+0xbc>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    2256:	80 91 80 07 	lds	r24, 0x0780
    225a:	81 30       	cpi	r24, 0x01	; 1
    225c:	41 f4       	brne	.+16     	; 0x226e <xTaskResumeAll+0xf0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    225e:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2262:	81 e0       	ldi	r24, 0x01	; 1
    2264:	05 c0       	rjmp	.+10     	; 0x2270 <xTaskResumeAll+0xf2>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    2266:	80 e0       	ldi	r24, 0x00	; 0
    2268:	03 c0       	rjmp	.+6      	; 0x2270 <xTaskResumeAll+0xf2>
    226a:	80 e0       	ldi	r24, 0x00	; 0
    226c:	01 c0       	rjmp	.+2      	; 0x2270 <xTaskResumeAll+0xf2>
    226e:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2270:	0f 90       	pop	r0
    2272:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2274:	df 91       	pop	r29
    2276:	cf 91       	pop	r28
    2278:	1f 91       	pop	r17
    227a:	0f 91       	pop	r16
    227c:	ff 90       	pop	r15
    227e:	ef 90       	pop	r14
    2280:	df 90       	pop	r13
    2282:	08 95       	ret

00002284 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2284:	0f 93       	push	r16
    2286:	1f 93       	push	r17
    2288:	cf 93       	push	r28
    228a:	df 93       	push	r29
    228c:	8c 01       	movw	r16, r24
    228e:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2290:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2294:	80 91 84 07 	lds	r24, 0x0784
    2298:	90 91 85 07 	lds	r25, 0x0785

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    229c:	f8 01       	movw	r30, r16
    229e:	20 81       	ld	r18, Z
    22a0:	31 81       	ldd	r19, Z+1	; 0x01
    22a2:	c2 0f       	add	r28, r18
    22a4:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    22a6:	82 17       	cp	r24, r18
    22a8:	93 07       	cpc	r25, r19
    22aa:	48 f4       	brcc	.+18     	; 0x22be <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    22ac:	c2 17       	cp	r28, r18
    22ae:	d3 07       	cpc	r29, r19
    22b0:	10 f5       	brcc	.+68     	; 0x22f6 <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22b2:	d1 83       	std	Z+1, r29	; 0x01
    22b4:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    22b6:	8c 17       	cp	r24, r28
    22b8:	9d 07       	cpc	r25, r29
    22ba:	90 f4       	brcc	.+36     	; 0x22e0 <vTaskDelayUntil+0x5c>
    22bc:	07 c0       	rjmp	.+14     	; 0x22cc <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    22be:	c2 17       	cp	r28, r18
    22c0:	d3 07       	cpc	r29, r19
    22c2:	a8 f0       	brcs	.+42     	; 0x22ee <vTaskDelayUntil+0x6a>
    22c4:	8c 17       	cp	r24, r28
    22c6:	9d 07       	cpc	r25, r29
    22c8:	90 f0       	brcs	.+36     	; 0x22ee <vTaskDelayUntil+0x6a>
    22ca:	15 c0       	rjmp	.+42     	; 0x22f6 <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    22cc:	80 91 ca 07 	lds	r24, 0x07CA
    22d0:	90 91 cb 07 	lds	r25, 0x07CB
    22d4:	02 96       	adiw	r24, 0x02	; 2
    22d6:	0e 94 db 09 	call	0x13b6	; 0x13b6 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22da:	ce 01       	movw	r24, r28
    22dc:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    22e0:	0e 94 bf 10 	call	0x217e	; 0x217e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    22e4:	81 11       	cpse	r24, r1
    22e6:	0b c0       	rjmp	.+22     	; 0x22fe <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
    22e8:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    22ec:	08 c0       	rjmp	.+16     	; 0x22fe <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22ee:	f8 01       	movw	r30, r16
    22f0:	d1 83       	std	Z+1, r29	; 0x01
    22f2:	c0 83       	st	Z, r28
    22f4:	eb cf       	rjmp	.-42     	; 0x22cc <vTaskDelayUntil+0x48>
    22f6:	f8 01       	movw	r30, r16
    22f8:	d1 83       	std	Z+1, r29	; 0x01
    22fa:	c0 83       	st	Z, r28
    22fc:	f1 cf       	rjmp	.-30     	; 0x22e0 <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    22fe:	df 91       	pop	r29
    2300:	cf 91       	pop	r28
    2302:	1f 91       	pop	r17
    2304:	0f 91       	pop	r16
    2306:	08 95       	ret

00002308 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2308:	cf 93       	push	r28
    230a:	df 93       	push	r29
    230c:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    230e:	00 97       	sbiw	r24, 0x00	; 0
    2310:	b1 f0       	breq	.+44     	; 0x233e <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2312:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2316:	80 91 84 07 	lds	r24, 0x0784
    231a:	90 91 85 07 	lds	r25, 0x0785
    231e:	c8 0f       	add	r28, r24
    2320:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2322:	80 91 ca 07 	lds	r24, 0x07CA
    2326:	90 91 cb 07 	lds	r25, 0x07CB
    232a:	02 96       	adiw	r24, 0x02	; 2
    232c:	0e 94 db 09 	call	0x13b6	; 0x13b6 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2330:	ce 01       	movw	r24, r28
    2332:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2336:	0e 94 bf 10 	call	0x217e	; 0x217e <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    233a:	81 11       	cpse	r24, r1
    233c:	02 c0       	rjmp	.+4      	; 0x2342 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    233e:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2342:	df 91       	pop	r29
    2344:	cf 91       	pop	r28
    2346:	08 95       	ret

00002348 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2348:	80 91 7b 07 	lds	r24, 0x077B
    234c:	88 23       	and	r24, r24
    234e:	21 f0       	breq	.+8      	; 0x2358 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2350:	81 e0       	ldi	r24, 0x01	; 1
    2352:	80 93 80 07 	sts	0x0780, r24
    2356:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    2358:	10 92 80 07 	sts	0x0780, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    235c:	80 91 83 07 	lds	r24, 0x0783
    2360:	90 e0       	ldi	r25, 0x00	; 0
    2362:	fc 01       	movw	r30, r24
    2364:	ee 0f       	add	r30, r30
    2366:	ff 1f       	adc	r31, r31
    2368:	ee 0f       	add	r30, r30
    236a:	ff 1f       	adc	r31, r31
    236c:	ee 0f       	add	r30, r30
    236e:	ff 1f       	adc	r31, r31
    2370:	8e 0f       	add	r24, r30
    2372:	9f 1f       	adc	r25, r31
    2374:	fc 01       	movw	r30, r24
    2376:	ea 55       	subi	r30, 0x5A	; 90
    2378:	f8 4f       	sbci	r31, 0xF8	; 248
    237a:	80 81       	ld	r24, Z
    237c:	81 11       	cpse	r24, r1
    237e:	17 c0       	rjmp	.+46     	; 0x23ae <vTaskSwitchContext+0x66>
    2380:	80 91 83 07 	lds	r24, 0x0783
    2384:	81 50       	subi	r24, 0x01	; 1
    2386:	80 93 83 07 	sts	0x0783, r24
    238a:	80 91 83 07 	lds	r24, 0x0783
    238e:	90 e0       	ldi	r25, 0x00	; 0
    2390:	fc 01       	movw	r30, r24
    2392:	ee 0f       	add	r30, r30
    2394:	ff 1f       	adc	r31, r31
    2396:	ee 0f       	add	r30, r30
    2398:	ff 1f       	adc	r31, r31
    239a:	ee 0f       	add	r30, r30
    239c:	ff 1f       	adc	r31, r31
    239e:	8e 0f       	add	r24, r30
    23a0:	9f 1f       	adc	r25, r31
    23a2:	fc 01       	movw	r30, r24
    23a4:	ea 55       	subi	r30, 0x5A	; 90
    23a6:	f8 4f       	sbci	r31, 0xF8	; 248
    23a8:	80 81       	ld	r24, Z
    23aa:	88 23       	and	r24, r24
    23ac:	49 f3       	breq	.-46     	; 0x2380 <vTaskSwitchContext+0x38>
    23ae:	e0 91 83 07 	lds	r30, 0x0783
    23b2:	f0 e0       	ldi	r31, 0x00	; 0
    23b4:	cf 01       	movw	r24, r30
    23b6:	88 0f       	add	r24, r24
    23b8:	99 1f       	adc	r25, r25
    23ba:	88 0f       	add	r24, r24
    23bc:	99 1f       	adc	r25, r25
    23be:	88 0f       	add	r24, r24
    23c0:	99 1f       	adc	r25, r25
    23c2:	e8 0f       	add	r30, r24
    23c4:	f9 1f       	adc	r31, r25
    23c6:	ea 55       	subi	r30, 0x5A	; 90
    23c8:	f8 4f       	sbci	r31, 0xF8	; 248
    23ca:	a1 81       	ldd	r26, Z+1	; 0x01
    23cc:	b2 81       	ldd	r27, Z+2	; 0x02
    23ce:	12 96       	adiw	r26, 0x02	; 2
    23d0:	0d 90       	ld	r0, X+
    23d2:	bc 91       	ld	r27, X
    23d4:	a0 2d       	mov	r26, r0
    23d6:	b2 83       	std	Z+2, r27	; 0x02
    23d8:	a1 83       	std	Z+1, r26	; 0x01
    23da:	cf 01       	movw	r24, r30
    23dc:	03 96       	adiw	r24, 0x03	; 3
    23de:	a8 17       	cp	r26, r24
    23e0:	b9 07       	cpc	r27, r25
    23e2:	31 f4       	brne	.+12     	; 0x23f0 <vTaskSwitchContext+0xa8>
    23e4:	12 96       	adiw	r26, 0x02	; 2
    23e6:	8d 91       	ld	r24, X+
    23e8:	9c 91       	ld	r25, X
    23ea:	13 97       	sbiw	r26, 0x03	; 3
    23ec:	92 83       	std	Z+2, r25	; 0x02
    23ee:	81 83       	std	Z+1, r24	; 0x01
    23f0:	01 80       	ldd	r0, Z+1	; 0x01
    23f2:	f2 81       	ldd	r31, Z+2	; 0x02
    23f4:	e0 2d       	mov	r30, r0
    23f6:	86 81       	ldd	r24, Z+6	; 0x06
    23f8:	97 81       	ldd	r25, Z+7	; 0x07
    23fa:	90 93 cb 07 	sts	0x07CB, r25
    23fe:	80 93 ca 07 	sts	0x07CA, r24
    2402:	08 95       	ret

00002404 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2404:	cf 93       	push	r28
    2406:	df 93       	push	r29
    2408:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    240a:	60 91 ca 07 	lds	r22, 0x07CA
    240e:	70 91 cb 07 	lds	r23, 0x07CB
    2412:	64 5f       	subi	r22, 0xF4	; 244
    2414:	7f 4f       	sbci	r23, 0xFF	; 255
    2416:	0e 94 aa 09 	call	0x1354	; 0x1354 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    241a:	80 91 ca 07 	lds	r24, 0x07CA
    241e:	90 91 cb 07 	lds	r25, 0x07CB
    2422:	02 96       	adiw	r24, 0x02	; 2
    2424:	0e 94 db 09 	call	0x13b6	; 0x13b6 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    2428:	80 91 84 07 	lds	r24, 0x0784
    242c:	90 91 85 07 	lds	r25, 0x0785
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2430:	8c 0f       	add	r24, r28
    2432:	9d 1f       	adc	r25, r29
    2434:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2438:	df 91       	pop	r29
    243a:	cf 91       	pop	r28
    243c:	08 95       	ret

0000243e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    243e:	0f 93       	push	r16
    2440:	1f 93       	push	r17
    2442:	cf 93       	push	r28
    2444:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2446:	dc 01       	movw	r26, r24
    2448:	15 96       	adiw	r26, 0x05	; 5
    244a:	ed 91       	ld	r30, X+
    244c:	fc 91       	ld	r31, X
    244e:	16 97       	sbiw	r26, 0x06	; 6
    2450:	c6 81       	ldd	r28, Z+6	; 0x06
    2452:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2454:	8e 01       	movw	r16, r28
    2456:	04 5f       	subi	r16, 0xF4	; 244
    2458:	1f 4f       	sbci	r17, 0xFF	; 255
    245a:	c8 01       	movw	r24, r16
    245c:	0e 94 db 09 	call	0x13b6	; 0x13b6 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2460:	80 91 7b 07 	lds	r24, 0x077B
    2464:	81 11       	cpse	r24, r1
    2466:	1c c0       	rjmp	.+56     	; 0x24a0 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2468:	0a 50       	subi	r16, 0x0A	; 10
    246a:	11 09       	sbc	r17, r1
    246c:	c8 01       	movw	r24, r16
    246e:	0e 94 db 09 	call	0x13b6	; 0x13b6 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    2472:	8e 89       	ldd	r24, Y+22	; 0x16
    2474:	90 91 83 07 	lds	r25, 0x0783
    2478:	98 17       	cp	r25, r24
    247a:	10 f4       	brcc	.+4      	; 0x2480 <xTaskRemoveFromEventList+0x42>
    247c:	80 93 83 07 	sts	0x0783, r24
    2480:	90 e0       	ldi	r25, 0x00	; 0
    2482:	9c 01       	movw	r18, r24
    2484:	22 0f       	add	r18, r18
    2486:	33 1f       	adc	r19, r19
    2488:	22 0f       	add	r18, r18
    248a:	33 1f       	adc	r19, r19
    248c:	22 0f       	add	r18, r18
    248e:	33 1f       	adc	r19, r19
    2490:	82 0f       	add	r24, r18
    2492:	93 1f       	adc	r25, r19
    2494:	b8 01       	movw	r22, r16
    2496:	8a 55       	subi	r24, 0x5A	; 90
    2498:	98 4f       	sbci	r25, 0xF8	; 248
    249a:	0e 94 89 09 	call	0x1312	; 0x1312 <vListInsertEnd>
    249e:	05 c0       	rjmp	.+10     	; 0x24aa <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    24a0:	b8 01       	movw	r22, r16
    24a2:	87 e8       	ldi	r24, 0x87	; 135
    24a4:	97 e0       	ldi	r25, 0x07	; 7
    24a6:	0e 94 89 09 	call	0x1312	; 0x1312 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    24aa:	e0 91 ca 07 	lds	r30, 0x07CA
    24ae:	f0 91 cb 07 	lds	r31, 0x07CB
    24b2:	9e 89       	ldd	r25, Y+22	; 0x16
    24b4:	86 89       	ldd	r24, Z+22	; 0x16
    24b6:	89 17       	cp	r24, r25
    24b8:	20 f4       	brcc	.+8      	; 0x24c2 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    24ba:	81 e0       	ldi	r24, 0x01	; 1
    24bc:	80 93 80 07 	sts	0x0780, r24
    24c0:	01 c0       	rjmp	.+2      	; 0x24c4 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    24c2:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    24c4:	df 91       	pop	r29
    24c6:	cf 91       	pop	r28
    24c8:	1f 91       	pop	r17
    24ca:	0f 91       	pop	r16
    24cc:	08 95       	ret

000024ce <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    24ce:	20 91 7f 07 	lds	r18, 0x077F
    24d2:	fc 01       	movw	r30, r24
    24d4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    24d6:	20 91 84 07 	lds	r18, 0x0784
    24da:	30 91 85 07 	lds	r19, 0x0785
    24de:	32 83       	std	Z+2, r19	; 0x02
    24e0:	21 83       	std	Z+1, r18	; 0x01
    24e2:	08 95       	ret

000024e4 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    24e4:	0f b6       	in	r0, 0x3f	; 63
    24e6:	f8 94       	cli
    24e8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    24ea:	20 91 84 07 	lds	r18, 0x0784
    24ee:	30 91 85 07 	lds	r19, 0x0785
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    24f2:	40 91 7f 07 	lds	r20, 0x077F
    24f6:	dc 01       	movw	r26, r24
    24f8:	5c 91       	ld	r21, X
    24fa:	54 17       	cp	r21, r20
    24fc:	39 f0       	breq	.+14     	; 0x250c <xTaskCheckForTimeOut+0x28>
    24fe:	11 96       	adiw	r26, 0x01	; 1
    2500:	4d 91       	ld	r20, X+
    2502:	5c 91       	ld	r21, X
    2504:	12 97       	sbiw	r26, 0x02	; 2
    2506:	24 17       	cp	r18, r20
    2508:	35 07       	cpc	r19, r21
    250a:	c8 f4       	brcc	.+50     	; 0x253e <xTaskCheckForTimeOut+0x5a>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    250c:	dc 01       	movw	r26, r24
    250e:	11 96       	adiw	r26, 0x01	; 1
    2510:	ed 91       	ld	r30, X+
    2512:	fc 91       	ld	r31, X
    2514:	12 97       	sbiw	r26, 0x02	; 2
    2516:	db 01       	movw	r26, r22
    2518:	4d 91       	ld	r20, X+
    251a:	5c 91       	ld	r21, X
    251c:	d9 01       	movw	r26, r18
    251e:	ae 1b       	sub	r26, r30
    2520:	bf 0b       	sbc	r27, r31
    2522:	a4 17       	cp	r26, r20
    2524:	b5 07       	cpc	r27, r21
    2526:	68 f4       	brcc	.+26     	; 0x2542 <xTaskCheckForTimeOut+0x5e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2528:	e2 1b       	sub	r30, r18
    252a:	f3 0b       	sbc	r31, r19
    252c:	4e 0f       	add	r20, r30
    252e:	5f 1f       	adc	r21, r31
    2530:	fb 01       	movw	r30, r22
    2532:	51 83       	std	Z+1, r21	; 0x01
    2534:	40 83       	st	Z, r20
			vTaskSetTimeOutState( pxTimeOut );
    2536:	0e 94 67 12 	call	0x24ce	; 0x24ce <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    253a:	80 e0       	ldi	r24, 0x00	; 0
    253c:	03 c0       	rjmp	.+6      	; 0x2544 <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    253e:	81 e0       	ldi	r24, 0x01	; 1
    2540:	01 c0       	rjmp	.+2      	; 0x2544 <xTaskCheckForTimeOut+0x60>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2542:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2544:	0f 90       	pop	r0
    2546:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2548:	08 95       	ret

0000254a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    254a:	81 e0       	ldi	r24, 0x01	; 1
    254c:	80 93 80 07 	sts	0x0780, r24
    2550:	08 95       	ret

00002552 <__tablejump2__>:
    2552:	ee 0f       	add	r30, r30
    2554:	ff 1f       	adc	r31, r31

00002556 <__tablejump__>:
    2556:	05 90       	lpm	r0, Z+
    2558:	f4 91       	lpm	r31, Z
    255a:	e0 2d       	mov	r30, r0
    255c:	09 94       	ijmp

0000255e <memcpy>:
    255e:	fb 01       	movw	r30, r22
    2560:	dc 01       	movw	r26, r24
    2562:	02 c0       	rjmp	.+4      	; 0x2568 <memcpy+0xa>
    2564:	01 90       	ld	r0, Z+
    2566:	0d 92       	st	X+, r0
    2568:	41 50       	subi	r20, 0x01	; 1
    256a:	50 40       	sbci	r21, 0x00	; 0
    256c:	d8 f7       	brcc	.-10     	; 0x2564 <memcpy+0x6>
    256e:	08 95       	ret

00002570 <_exit>:
    2570:	f8 94       	cli

00002572 <__stop_program>:
    2572:	ff cf       	rjmp	.-2      	; 0x2572 <__stop_program>
