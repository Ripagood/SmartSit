
FreeRTOSatmega328p.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  0000266a  000026fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000266a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000757  00800126  00800126  00002724  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002724  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000520  00000000  00000000  00002754  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00006697  00000000  00000000  00002c74  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000019a4  00000000  00000000  0000930b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000026ee  00000000  00000000  0000acaf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f7c  00000000  00000000  0000d3a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000186c  00000000  00000000  0000e31c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00005945  00000000  00000000  0000fb88  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000480  00000000  00000000  000154cd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
       0:	0c 94 be 01 	jmp	0x37c	; 0x37c <__ctors_end>
       4:	0c 94 5d 09 	jmp	0x12ba	; 0x12ba <__vector_1>
       8:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
       c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      10:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      14:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      18:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
      1c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
      20:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      24:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
      28:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
      2c:	0c 94 6c 0b 	jmp	0x16d8	; 0x16d8 <__vector_11>
      30:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      34:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      38:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
      3c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      40:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      44:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      48:	0c 94 c1 06 	jmp	0xd82	; 0xd82 <__vector_18>
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );

		if( xWaitConditionMet != pdFALSE )
      4c:	0c 94 f1 06 	jmp	0xde2	; 0xde2 <__vector_19>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
      50:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
      54:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      58:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      5c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      60:	0c 94 a2 07 	jmp	0xf44	; 0xf44 <__vector_24>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
      64:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      68:	bc 07       	cpc	r27, r28
      6a:	1d 08       	sbc	r1, r13
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
      6c:	1d 08       	sbc	r1, r13
      6e:	1d 08       	sbc	r1, r13
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
      70:	1d 08       	sbc	r1, r13
      72:	1d 08       	sbc	r1, r13
      74:	1d 08       	sbc	r1, r13
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
      76:	1d 08       	sbc	r1, r13
      78:	bc 07       	cpc	r27, r28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
      7a:	1d 08       	sbc	r1, r13
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
      7c:	1d 08       	sbc	r1, r13
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
      7e:	1d 08       	sbc	r1, r13
      80:	1d 08       	sbc	r1, r13
      82:	1d 08       	sbc	r1, r13
      84:	1d 08       	sbc	r1, r13
      86:	1d 08       	sbc	r1, r13
      88:	be 07       	cpc	r27, r30
      8a:	1d 08       	sbc	r1, r13
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
      8c:	1d 08       	sbc	r1, r13
      8e:	1d 08       	sbc	r1, r13

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
      90:	1d 08       	sbc	r1, r13
      92:	1d 08       	sbc	r1, r13
		{
			portYIELD_WITHIN_API();
      94:	1d 08       	sbc	r1, r13
      96:	1d 08       	sbc	r1, r13

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
      98:	1d 08       	sbc	r1, r13
      9a:	1d 08       	sbc	r1, r13

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
      9c:	1d 08       	sbc	r1, r13
      9e:	1d 08       	sbc	r1, r13
		{
			taskENTER_CRITICAL();
      a0:	1d 08       	sbc	r1, r13
      a2:	1d 08       	sbc	r1, r13
      a4:	1d 08       	sbc	r1, r13
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
      a6:	1d 08       	sbc	r1, r13
      a8:	be 07       	cpc	r27, r30
      aa:	1d 08       	sbc	r1, r13

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
      ac:	1d 08       	sbc	r1, r13
      ae:	1d 08       	sbc	r1, r13
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
      b0:	1d 08       	sbc	r1, r13
      b2:	1d 08       	sbc	r1, r13
      b4:	1d 08       	sbc	r1, r13
      b6:	1d 08       	sbc	r1, r13
      b8:	1d 08       	sbc	r1, r13
      ba:	1d 08       	sbc	r1, r13
      bc:	1d 08       	sbc	r1, r13
      be:	1d 08       	sbc	r1, r13
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
      c0:	1d 08       	sbc	r1, r13
      c2:	1d 08       	sbc	r1, r13
      c4:	1d 08       	sbc	r1, r13
      c6:	1d 08       	sbc	r1, r13
      c8:	16 08       	sbc	r1, r6
      ca:	1d 08       	sbc	r1, r13
      cc:	1d 08       	sbc	r1, r13
      ce:	1d 08       	sbc	r1, r13
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
      d0:	1d 08       	sbc	r1, r13
      d2:	1d 08       	sbc	r1, r13
				{
					if( xClearOnExit != pdFALSE )
      d4:	1d 08       	sbc	r1, r13
      d6:	1d 08       	sbc	r1, r13
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
      d8:	eb 07       	cpc	r30, r27
      da:	1d 08       	sbc	r1, r13
      dc:	1d 08       	sbc	r1, r13
      de:	1d 08       	sbc	r1, r13
      e0:	1d 08       	sbc	r1, r13
      e2:	1d 08       	sbc	r1, r13
      e4:	1d 08       	sbc	r1, r13
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
      e6:	1d 08       	sbc	r1, r13
      e8:	1d 08       	sbc	r1, r13
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
      ea:	1d 08       	sbc	r1, r13
      ec:	1d 08       	sbc	r1, r13
      ee:	1d 08       	sbc	r1, r13
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
      f0:	1d 08       	sbc	r1, r13
      f2:	1d 08       	sbc	r1, r13
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
      f4:	1d 08       	sbc	r1, r13
      f6:	1d 08       	sbc	r1, r13
      f8:	df 07       	cpc	r29, r31
      fa:	1d 08       	sbc	r1, r13
      fc:	1d 08       	sbc	r1, r13
      fe:	1d 08       	sbc	r1, r13
     100:	1d 08       	sbc	r1, r13
     102:	1d 08       	sbc	r1, r13
     104:	1d 08       	sbc	r1, r13
     106:	1d 08       	sbc	r1, r13
     108:	03 08       	sbc	r0, r3

0000010a <__trampolines_end>:
     10a:	05 00       	.word	0x0005	; ????
     10c:	05 00       	.word	0x0005	; ????

0000010e <setServiceACK>:
     10e:	01 02 00 00 08 01                                   ......

00000114 <setService>:
     114:	01 0a 05 08 04 01 00 f9 81 00 00 01 2c              ............,

00000121 <serviceACK>:
     121:	0e 00 05 00                                         ....

00000125 <svcIndication>:
     125:	0e 0c 04 00 00 80 01 03 02 f9 81 00 00 03 e8        ...............

00000134 <operationalEvent>:
     134:	0f 09 02 00 00 00 24 05 00 00 00 00                 ......$.....

00000140 <alarmEvent>:
     140:	0f 09 04 00 00 00 02 04 00 00 00 00                 ............

0000014c <negotiatingEvent>:
     14c:	0f 09 04 00 00 01 00 03 00 00 00 08                 ............

00000158 <moteSearchingEvent>:
     158:	0f 09 04 00 00 00 02 02 00 00 00 08                 ............

00000164 <joinACK>:
     164:	06 00 05 00                                         ....

00000168 <joinCommand>:
     168:	06 00 04                                            ...

0000016b <eventACK>:
     16b:	0f 00 05 00                                         ....

0000016f <bootEvent>:
     16f:	0f 09 08 00 00 00 01 01 00 00 00 00                 ............

0000017b <fcstab>:
     17b:	00 00 89 11 12 23 9b 32 24 46 ad 57 36 65 bf 74     .....#.2$F.W6e.t
     18b:	48 8c c1 9d 5a af d3 be 6c ca e5 db 7e e9 f7 f8     H...Z...l...~...
     19b:	81 10 08 01 93 33 1a 22 a5 56 2c 47 b7 75 3e 64     .....3.".V,G.u>d
     1ab:	c9 9c 40 8d db bf 52 ae ed da 64 cb ff f9 76 e8     ..@...R...d...v.
     1bb:	02 21 8b 30 10 02 99 13 26 67 af 76 34 44 bd 55     .!.0....&g.v4D.U
     1cb:	4a ad c3 bc 58 8e d1 9f 6e eb e7 fa 7c c8 f5 d9     J...X...n...|...
     1db:	83 31 0a 20 91 12 18 03 a7 77 2e 66 b5 54 3c 45     .1. .....w.f.T<E
     1eb:	cb bd 42 ac d9 9e 50 8f ef fb 66 ea fd d8 74 c9     ..B...P...f...t.
     1fb:	04 42 8d 53 16 61 9f 70 20 04 a9 15 32 27 bb 36     .B.S.a.p ...2'.6
     20b:	4c ce c5 df 5e ed d7 fc 68 88 e1 99 7a ab f3 ba     L...^...h...z...
     21b:	85 52 0c 43 97 71 1e 60 a1 14 28 05 b3 37 3a 26     .R.C.q.`..(..7:&
     22b:	cd de 44 cf df fd 56 ec e9 98 60 89 fb bb 72 aa     ..D...V...`...r.
     23b:	06 63 8f 72 14 40 9d 51 22 25 ab 34 30 06 b9 17     .c.r.@.Q"%.40...
     24b:	4e ef c7 fe 5c cc d5 dd 6a a9 e3 b8 78 8a f1 9b     N...\...j...x...
     25b:	87 73 0e 62 95 50 1c 41 a3 35 2a 24 b1 16 38 07     .s.b.P.A.5*$..8.
     26b:	cf ff 46 ee dd dc 54 cd eb b9 62 a8 f9 9a 70 8b     ..F...T...b...p.
     27b:	08 84 81 95 1a a7 93 b6 2c c2 a5 d3 3e e1 b7 f0     ........,...>...
     28b:	40 08 c9 19 52 2b db 3a 64 4e ed 5f 76 6d ff 7c     @...R+.:dN._vm.|
     29b:	89 94 00 85 9b b7 12 a6 ad d2 24 c3 bf f1 36 e0     ..........$...6.
     2ab:	c1 18 48 09 d3 3b 5a 2a e5 5e 6c 4f f7 7d 7e 6c     ..H..;Z*.^lO.}~l
     2bb:	0a a5 83 b4 18 86 91 97 2e e3 a7 f2 3c c0 b5 d1     ............<...
     2cb:	42 29 cb 38 50 0a d9 1b 66 6f ef 7e 74 4c fd 5d     B).8P...fo.~tL.]
     2db:	8b b5 02 a4 99 96 10 87 af f3 26 e2 bd d0 34 c1     ..........&...4.
     2eb:	c3 39 4a 28 d1 1a 58 0b e7 7f 6e 6e f5 5c 7c 4d     .9J(..X...nn.\|M
     2fb:	0c c6 85 d7 1e e5 97 f4 28 80 a1 91 3a a3 b3 b2     ........(...:...
     30b:	44 4a cd 5b 56 69 df 78 60 0c e9 1d 72 2f fb 3e     DJ.[Vi.x`...r/.>
     31b:	8d d6 04 c7 9f f5 16 e4 a9 90 20 81 bb b3 32 a2     .......... ...2.
     32b:	c5 5a 4c 4b d7 79 5e 68 e1 1c 68 0d f3 3f 7a 2e     .ZLK.y^h..h..?z.
     33b:	0e e7 87 f6 1c c4 95 d5 2a a1 a3 b0 38 82 b1 93     ........*...8...
     34b:	46 6b cf 7a 54 48 dd 59 62 2d eb 3c 70 0e f9 1f     Fk.zTH.Yb-.<p...
     35b:	8f f7 06 e6 9d d4 14 c5 ab b1 22 a0 b9 92 30 83     .........."...0.
     36b:	c7 7b 4e 6a d5 58 5c 49 e3 3d 6a 2c f1 1e 78 0f     .{Nj.X\I.=j,..x.
	...

0000037c <__ctors_end>:
     37c:	11 24       	eor	r1, r1
     37e:	1f be       	out	0x3f, r1	; 63
     380:	cf ef       	ldi	r28, 0xFF	; 255
     382:	d8 e0       	ldi	r29, 0x08	; 8
     384:	de bf       	out	0x3e, r29	; 62
     386:	cd bf       	out	0x3d, r28	; 61

00000388 <__do_copy_data>:
     388:	11 e0       	ldi	r17, 0x01	; 1
     38a:	a0 e0       	ldi	r26, 0x00	; 0
     38c:	b1 e0       	ldi	r27, 0x01	; 1
     38e:	ea e6       	ldi	r30, 0x6A	; 106
     390:	f6 e2       	ldi	r31, 0x26	; 38
     392:	02 c0       	rjmp	.+4      	; 0x398 <__do_copy_data+0x10>
     394:	05 90       	lpm	r0, Z+
     396:	0d 92       	st	X+, r0
     398:	a6 32       	cpi	r26, 0x26	; 38
     39a:	b1 07       	cpc	r27, r17
     39c:	d9 f7       	brne	.-10     	; 0x394 <__do_copy_data+0xc>

0000039e <__do_clear_bss>:
     39e:	28 e0       	ldi	r18, 0x08	; 8
     3a0:	a6 e2       	ldi	r26, 0x26	; 38
     3a2:	b1 e0       	ldi	r27, 0x01	; 1
     3a4:	01 c0       	rjmp	.+2      	; 0x3a8 <.do_clear_bss_start>

000003a6 <.do_clear_bss_loop>:
     3a6:	1d 92       	st	X+, r1

000003a8 <.do_clear_bss_start>:
     3a8:	ad 37       	cpi	r26, 0x7D	; 125
     3aa:	b2 07       	cpc	r27, r18
     3ac:	e1 f7       	brne	.-8      	; 0x3a6 <.do_clear_bss_loop>
     3ae:	0e 94 33 08 	call	0x1066	; 0x1066 <main>
     3b2:	0c 94 33 13 	jmp	0x2666	; 0x2666 <_exit>

000003b6 <__bad_interrupt>:
     3b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003ba <xMoteTask>:
	moteReadySemaphore = xSemaphoreCreateBinary();
	xTaskCreate( xMoteTask,( signed char * ) "Mote", comSTACK_SIZE, NULL, uxPriority, NULL );
		
}

void xMoteTask( void* pvParameters){
     3ba:	cf 93       	push	r28
     3bc:	df 93       	push	r29
     3be:	00 d0       	rcall	.+0      	; 0x3c0 <xMoteTask+0x6>
     3c0:	cd b7       	in	r28, 0x3d	; 61
     3c2:	de b7       	in	r29, 0x3e	; 62
	
	
	configureMote();
     3c4:	0e 94 38 07 	call	0xe70	; 0xe70 <configureMote>
	xSemaphoreGive(moteReadySemaphore);
     3c8:	20 e0       	ldi	r18, 0x00	; 0
     3ca:	40 e0       	ldi	r20, 0x00	; 0
     3cc:	50 e0       	ldi	r21, 0x00	; 0
     3ce:	60 e0       	ldi	r22, 0x00	; 0
     3d0:	70 e0       	ldi	r23, 0x00	; 0
     3d2:	80 91 d5 07 	lds	r24, 0x07D5
     3d6:	90 91 d6 07 	lds	r25, 0x07D6
     3da:	0e 94 c1 0c 	call	0x1982	; 0x1982 <xQueueGenericSend>
	for ( ;; )
	{
		//sendMoteData(datos2,sizeof(datos2));
		//vTaskDelayUntil(&xLastWakeTime2,xFrequency2);
		
		if ( xQueueReceive(DataToSend,&(datos),DATA_READY_TO_SEND_BLOCK_TIME)  ) //Block on the DataToSendQueue
     3de:	20 e0       	ldi	r18, 0x00	; 0
     3e0:	4f ef       	ldi	r20, 0xFF	; 255
     3e2:	5f ef       	ldi	r21, 0xFF	; 255
     3e4:	be 01       	movw	r22, r28
     3e6:	6f 5f       	subi	r22, 0xFF	; 255
     3e8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ea:	80 91 79 08 	lds	r24, 0x0879
     3ee:	90 91 7a 08 	lds	r25, 0x087A
     3f2:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     3f6:	88 23       	and	r24, r24
     3f8:	91 f3       	breq	.-28     	; 0x3de <xMoteTask+0x24>
		{
			//The queue is of size 1 and contains the pointer to the data to be sent
			sendMoteData(datos,NUMBER_OF_BYTES_TO_SEND);
     3fa:	60 e3       	ldi	r22, 0x30	; 48
     3fc:	89 81       	ldd	r24, Y+1	; 0x01
     3fe:	9a 81       	ldd	r25, Y+2	; 0x02
     400:	0e 94 32 07 	call	0xe64	; 0xe64 <sendMoteData>
     404:	ec cf       	rjmp	.-40     	; 0x3de <xMoteTask+0x24>

00000406 <startCommTasks>:
static xComPortHandle xPort = NULL;

extern QueueHandle_t DataToSend;
SemaphoreHandle_t moteReadySemaphore; // sync for sensor task

void startCommTasks(UBaseType_t uxPriority){
     406:	af 92       	push	r10
     408:	bf 92       	push	r11
     40a:	cf 92       	push	r12
     40c:	df 92       	push	r13
     40e:	ef 92       	push	r14
     410:	ff 92       	push	r15
     412:	0f 93       	push	r16
     414:	08 2f       	mov	r16, r24
	xSerialPortInitMinimal(BUFFER_LENGTH);
     416:	80 e8       	ldi	r24, 0x80	; 128
     418:	0e 94 77 06 	call	0xcee	; 0xcee <xSerialPortInitMinimal>
	/* The Tx task is spawned with a lower priority than the Rx task. */
	moteReadySemaphore = xSemaphoreCreateBinary();
     41c:	43 e0       	ldi	r20, 0x03	; 3
     41e:	60 e0       	ldi	r22, 0x00	; 0
     420:	81 e0       	ldi	r24, 0x01	; 1
     422:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
     426:	90 93 d6 07 	sts	0x07D6, r25
     42a:	80 93 d5 07 	sts	0x07D5, r24
	xTaskCreate( xMoteTask,( signed char * ) "Mote", comSTACK_SIZE, NULL, uxPriority, NULL );
     42e:	a1 2c       	mov	r10, r1
     430:	b1 2c       	mov	r11, r1
     432:	c1 2c       	mov	r12, r1
     434:	d1 2c       	mov	r13, r1
     436:	e1 2c       	mov	r14, r1
     438:	f1 2c       	mov	r15, r1
     43a:	20 e0       	ldi	r18, 0x00	; 0
     43c:	30 e0       	ldi	r19, 0x00	; 0
     43e:	40 e0       	ldi	r20, 0x00	; 0
     440:	51 e0       	ldi	r21, 0x01	; 1
     442:	61 e0       	ldi	r22, 0x01	; 1
     444:	71 e0       	ldi	r23, 0x01	; 1
     446:	8d ed       	ldi	r24, 0xDD	; 221
     448:	91 e0       	ldi	r25, 0x01	; 1
     44a:	0e 94 cc 0e 	call	0x1d98	; 0x1d98 <xTaskGenericCreate>
		
}
     44e:	0f 91       	pop	r16
     450:	ff 90       	pop	r15
     452:	ef 90       	pop	r14
     454:	df 90       	pop	r13
     456:	cf 90       	pop	r12
     458:	bf 90       	pop	r11
     45a:	af 90       	pop	r10
     45c:	08 95       	ret

0000045e <InterruptReception>:

extern SemaphoreHandle_t frameHandle;



uint8_t InterruptReception (MoteData_p moteData) {
     45e:	0f 93       	push	r16
     460:	1f 93       	push	r17
     462:	cf 93       	push	r28
     464:	df 93       	push	r29
     466:	ec 01       	movw	r28, r24
//Place this function inside your Serial Receipt Interrupt
//Dont read the byte, the function serialMoteReceive will do it

moteData->RXbuffer[moteData->RXindex]=moteData->serialMoteReceive();
     468:	0c 81       	ldd	r16, Y+4	; 0x04
     46a:	10 e0       	ldi	r17, 0x00	; 0
     46c:	ea 81       	ldd	r30, Y+2	; 0x02
     46e:	fb 81       	ldd	r31, Y+3	; 0x03
     470:	09 95       	icall
     472:	fe 01       	movw	r30, r28
     474:	e0 0f       	add	r30, r16
     476:	f1 1f       	adc	r31, r17
     478:	85 83       	std	Z+5, r24	; 0x05
//moteData->RXbuffer[moteData->RXindex]=rxedChar;
	moteData->RXindex++;
     47a:	8c 81       	ldd	r24, Y+4	; 0x04
     47c:	8f 5f       	subi	r24, 0xFF	; 255
     47e:	8c 83       	std	Y+4, r24	; 0x04
	//sei();
	
	//serialPCtx(moteData->RXbuffer[moteData->RXindex-1]);
	
	
	if ((moteData->RXbuffer[moteData->RXindex-1] == 0x7E) && ((moteData->RXindex-1) > 0) )
     480:	ec 81       	ldd	r30, Y+4	; 0x04
     482:	f0 e0       	ldi	r31, 0x00	; 0
     484:	31 97       	sbiw	r30, 0x01	; 1
     486:	ec 0f       	add	r30, r28
     488:	fd 1f       	adc	r31, r29
     48a:	85 81       	ldd	r24, Z+5	; 0x05
     48c:	8e 37       	cpi	r24, 0x7E	; 126
     48e:	f9 f4       	brne	.+62     	; 0x4ce <InterruptReception+0x70>
     490:	8c 81       	ldd	r24, Y+4	; 0x04
     492:	90 e0       	ldi	r25, 0x00	; 0
     494:	01 97       	sbiw	r24, 0x01	; 1
     496:	18 16       	cp	r1, r24
     498:	19 06       	cpc	r1, r25
     49a:	cc f4       	brge	.+50     	; 0x4ce <InterruptReception+0x70>
	{
		//serialPCtxArray(moteData->RXbuffer,moteData->RXindex);
	
		//moteData->RXindex++;
		//serialPCtxArray(moteData->RXbuffer,moteData->RXindex);
	 moteData->decodeResult = hdlc_decode(moteData->hdlcDecoded, moteData->RXbuffer,&moteData->RXindex, sizeof(moteData->hdlcDecoded));
     49c:	20 e2       	ldi	r18, 0x20	; 32
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	ae 01       	movw	r20, r28
     4a2:	4c 5f       	subi	r20, 0xFC	; 252
     4a4:	5f 4f       	sbci	r21, 0xFF	; 255
     4a6:	be 01       	movw	r22, r28
     4a8:	6b 5f       	subi	r22, 0xFB	; 251
     4aa:	7f 4f       	sbci	r23, 0xFF	; 255
     4ac:	ce 01       	movw	r24, r28
     4ae:	8e 58       	subi	r24, 0x8E	; 142
     4b0:	9f 4f       	sbci	r25, 0xFF	; 255
     4b2:	0e 94 1f 05 	call	0xa3e	; 0xa3e <hdlc_decode>
     4b6:	9e 8f       	std	Y+30, r25	; 0x1e
     4b8:	8d 8f       	std	Y+29, r24	; 0x1d
		if (moteData->decodeResult>0)
     4ba:	8d 8d       	ldd	r24, Y+29	; 0x1d
     4bc:	9e 8d       	ldd	r25, Y+30	; 0x1e
     4be:	18 16       	cp	r1, r24
     4c0:	19 06       	cpc	r1, r25
     4c2:	14 f4       	brge	.+4      	; 0x4c8 <InterruptReception+0x6a>
		{
			moteData->validFrame=1;
     4c4:	81 e0       	ldi	r24, 0x01	; 1
     4c6:	8f 8f       	std	Y+31, r24	; 0x1f
			//serialPCtxArray(moteData->hdlcDecoded,moteData->decodeResult);
		}
		moteData->RXindex=0;
     4c8:	1c 82       	std	Y+4, r1	; 0x04
		return moteData->validFrame;
     4ca:	8f 8d       	ldd	r24, Y+31	; 0x1f
     4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <InterruptReception+0x74>
	}else{
		moteData->validFrame=0;
     4ce:	1f 8e       	std	Y+31, r1	; 0x1f
		return moteData->validFrame;}//moteData->RXindex++;}
     4d0:	8f 8d       	ldd	r24, Y+31	; 0x1f


}
     4d2:	df 91       	pop	r29
     4d4:	cf 91       	pop	r28
     4d6:	1f 91       	pop	r17
     4d8:	0f 91       	pop	r16
     4da:	08 95       	ret

000004dc <serialMoteSendArray>:
	}
}



void serialMoteSendArray(uint8_t* datos, uint8_t tam, MoteData_p moteData){
     4dc:	ef 92       	push	r14
     4de:	ff 92       	push	r15
     4e0:	0f 93       	push	r16
     4e2:	1f 93       	push	r17
     4e4:	cf 93       	push	r28
     4e6:	df 93       	push	r29
     4e8:	e6 2e       	mov	r14, r22
     4ea:	8a 01       	movw	r16, r20
	//send many bytes
	for (uint8_t i=0;i<tam;i++)
     4ec:	66 23       	and	r22, r22
     4ee:	59 f0       	breq	.+22     	; 0x506 <serialMoteSendArray+0x2a>
     4f0:	c8 2f       	mov	r28, r24
     4f2:	d9 2f       	mov	r29, r25
     4f4:	f1 2c       	mov	r15, r1
	{
		//serialMoteSend(datos[i]);
		moteData->serialMoteSend(datos[i]);
     4f6:	d8 01       	movw	r26, r16
     4f8:	ed 91       	ld	r30, X+
     4fa:	fc 91       	ld	r31, X
     4fc:	89 91       	ld	r24, Y+
     4fe:	09 95       	icall



void serialMoteSendArray(uint8_t* datos, uint8_t tam, MoteData_p moteData){
	//send many bytes
	for (uint8_t i=0;i<tam;i++)
     500:	f3 94       	inc	r15
     502:	fe 10       	cpse	r15, r14
     504:	f8 cf       	rjmp	.-16     	; 0x4f6 <serialMoteSendArray+0x1a>
	{
		//serialMoteSend(datos[i]);
		moteData->serialMoteSend(datos[i]);
	}
	
}
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	1f 91       	pop	r17
     50c:	0f 91       	pop	r16
     50e:	ff 90       	pop	r15
     510:	ef 90       	pop	r14
     512:	08 95       	ret

00000514 <compareBuffer>:
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     514:	44 23       	and	r20, r20
     516:	89 f0       	breq	.+34     	; 0x53a <compareBuffer+0x26>
     518:	28 2f       	mov	r18, r24
     51a:	e6 2f       	mov	r30, r22
     51c:	f7 2f       	mov	r31, r23
     51e:	a8 2f       	mov	r26, r24
     520:	b9 2f       	mov	r27, r25
	
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     522:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i=0;i<tam;i++)
	{
		//if (datos[i]==datos2[i])
		if (datos[i]==pgm_read_byte(&(datos2[i])))
     524:	8d 91       	ld	r24, X+
     526:	94 91       	lpm	r25, Z
     528:	89 13       	cpse	r24, r25
     52a:	01 c0       	rjmp	.+2      	; 0x52e <compareBuffer+0x1a>
		{
			comparacion++;
     52c:	3f 5f       	subi	r19, 0xFF	; 255
     52e:	31 96       	adiw	r30, 0x01	; 1
     530:	8a 2f       	mov	r24, r26
     532:	82 1b       	sub	r24, r18
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     534:	84 17       	cp	r24, r20
     536:	b0 f3       	brcs	.-20     	; 0x524 <compareBuffer+0x10>
     538:	01 c0       	rjmp	.+2      	; 0x53c <compareBuffer+0x28>
	
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     53a:	30 e0       	ldi	r19, 0x00	; 0
		{
			comparacion++;
		}
	}
	
	if (comparacion>=tam)
     53c:	81 e0       	ldi	r24, 0x01	; 1
     53e:	34 17       	cp	r19, r20
     540:	08 f4       	brcc	.+2      	; 0x544 <compareBuffer+0x30>
     542:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}else return 0;
	
	
	
}
     544:	08 95       	ret

00000546 <MoteInitialization>:
}




void MoteInitialization( MoteData_p moteData){
     546:	ef 92       	push	r14
     548:	ff 92       	push	r15
     54a:	0f 93       	push	r16
     54c:	1f 93       	push	r17
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
     552:	ec 01       	movw	r28, r24

while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     554:	20 e0       	ldi	r18, 0x00	; 0
     556:	4f ef       	ldi	r20, 0xFF	; 255
     558:	5f ef       	ldi	r21, 0xFF	; 255
     55a:	60 e0       	ldi	r22, 0x00	; 0
     55c:	70 e0       	ldi	r23, 0x00	; 0
     55e:	80 91 d7 07 	lds	r24, 0x07D7
     562:	90 91 d8 07 	lds	r25, 0x07D8
     566:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     56a:	81 30       	cpi	r24, 0x01	; 1
     56c:	99 f7       	brne	.-26     	; 0x554 <MoteInitialization+0xe>
	moteData->validFrame=0;
     56e:	1f 8e       	std	Y+31, r1	; 0x1f
	moteData->hdlcDecoded[2]=0x08;
     570:	88 e0       	ldi	r24, 0x08	; 8
     572:	fe 01       	movw	r30, r28
     574:	ec 58       	subi	r30, 0x8C	; 140
     576:	ff 4f       	sbci	r31, 0xFF	; 255
     578:	80 83       	st	Z, r24
	if (compareBuffer(moteData->hdlcDecoded,bootEvent,moteData->decodeResult))
     57a:	4d 8d       	ldd	r20, Y+29	; 0x1d
     57c:	5e 8d       	ldd	r21, Y+30	; 0x1e
     57e:	8e 01       	movw	r16, r28
     580:	0e 58       	subi	r16, 0x8E	; 142
     582:	1f 4f       	sbci	r17, 0xFF	; 255
     584:	6f e6       	ldi	r22, 0x6F	; 111
     586:	71 e0       	ldi	r23, 0x01	; 1
     588:	c8 01       	movw	r24, r16
     58a:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     58e:	88 23       	and	r24, r24
     590:	b1 f0       	breq	.+44     	; 0x5be <MoteInitialization+0x78>
	{
		//serialPCtx(0x00);
		
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     592:	22 e5       	ldi	r18, 0x52	; 82
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	44 e0       	ldi	r20, 0x04	; 4
     598:	50 e0       	ldi	r21, 0x00	; 0
     59a:	6b e6       	ldi	r22, 0x6B	; 107
     59c:	71 e0       	ldi	r23, 0x01	; 1
     59e:	7e 01       	movw	r14, r28
     5a0:	80 e2       	ldi	r24, 0x20	; 32
     5a2:	e8 0e       	add	r14, r24
     5a4:	f1 1c       	adc	r15, r1
     5a6:	c7 01       	movw	r24, r14
     5a8:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     5ac:	fe 01       	movw	r30, r28
     5ae:	ee 56       	subi	r30, 0x6E	; 110
     5b0:	ff 4f       	sbci	r31, 0xFF	; 255
     5b2:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     5b4:	ae 01       	movw	r20, r28
     5b6:	68 2f       	mov	r22, r24
     5b8:	c7 01       	movw	r24, r14
     5ba:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtxArray(moteData->hdlcOutput,moteData->sizeToSend);
	
	}
	//_delay_ms(100);
	moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,joinCommand,sizeof(joinCommand),sizeof(moteData->hdlcOutput));
     5be:	7e 01       	movw	r14, r28
     5c0:	80 e2       	ldi	r24, 0x20	; 32
     5c2:	e8 0e       	add	r14, r24
     5c4:	f1 1c       	adc	r15, r1
     5c6:	22 e5       	ldi	r18, 0x52	; 82
     5c8:	30 e0       	ldi	r19, 0x00	; 0
     5ca:	43 e0       	ldi	r20, 0x03	; 3
     5cc:	50 e0       	ldi	r21, 0x00	; 0
     5ce:	68 e6       	ldi	r22, 0x68	; 104
     5d0:	71 e0       	ldi	r23, 0x01	; 1
     5d2:	c7 01       	movw	r24, r14
     5d4:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     5d8:	fe 01       	movw	r30, r28
     5da:	ee 56       	subi	r30, 0x6E	; 110
     5dc:	ff 4f       	sbci	r31, 0xFF	; 255
     5de:	80 83       	st	Z, r24
	serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     5e0:	ae 01       	movw	r20, r28
     5e2:	68 2f       	mov	r22, r24
     5e4:	c7 01       	movw	r24, r14
     5e6:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     5ea:	20 e0       	ldi	r18, 0x00	; 0
     5ec:	4f ef       	ldi	r20, 0xFF	; 255
     5ee:	5f ef       	ldi	r21, 0xFF	; 255
     5f0:	60 e0       	ldi	r22, 0x00	; 0
     5f2:	70 e0       	ldi	r23, 0x00	; 0
     5f4:	80 91 d7 07 	lds	r24, 0x07D7
     5f8:	90 91 d8 07 	lds	r25, 0x07D8
     5fc:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     600:	81 30       	cpi	r24, 0x01	; 1
     602:	99 f7       	brne	.-26     	; 0x5ea <MoteInitialization+0xa4>
	moteData->validFrame=0;
     604:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,joinACK,moteData->decodeResult))
     606:	4d 8d       	ldd	r20, Y+29	; 0x1d
     608:	5e 8d       	ldd	r21, Y+30	; 0x1e
     60a:	64 e6       	ldi	r22, 0x64	; 100
     60c:	71 e0       	ldi	r23, 0x01	; 1
     60e:	c8 01       	movw	r24, r16
     610:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     614:	88 23       	and	r24, r24
     616:	91 f0       	breq	.+36     	; 0x63c <MoteInitialization+0xf6>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,joinACK,sizeof(joinACK),sizeof(moteData->hdlcOutput));
     618:	22 e5       	ldi	r18, 0x52	; 82
     61a:	30 e0       	ldi	r19, 0x00	; 0
     61c:	44 e0       	ldi	r20, 0x04	; 4
     61e:	50 e0       	ldi	r21, 0x00	; 0
     620:	64 e6       	ldi	r22, 0x64	; 100
     622:	71 e0       	ldi	r23, 0x01	; 1
     624:	c7 01       	movw	r24, r14
     626:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     62a:	fe 01       	movw	r30, r28
     62c:	ee 56       	subi	r30, 0x6E	; 110
     62e:	ff 4f       	sbci	r31, 0xFF	; 255
     630:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     632:	ae 01       	movw	r20, r28
     634:	68 2f       	mov	r22, r24
     636:	c7 01       	movw	r24, r14
     638:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x01);
	}
	
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     63c:	20 e0       	ldi	r18, 0x00	; 0
     63e:	4f ef       	ldi	r20, 0xFF	; 255
     640:	5f ef       	ldi	r21, 0xFF	; 255
     642:	60 e0       	ldi	r22, 0x00	; 0
     644:	70 e0       	ldi	r23, 0x00	; 0
     646:	80 91 d7 07 	lds	r24, 0x07D7
     64a:	90 91 d8 07 	lds	r25, 0x07D8
     64e:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     652:	81 30       	cpi	r24, 0x01	; 1
     654:	99 f7       	brne	.-26     	; 0x63c <MoteInitialization+0xf6>
	moteData->validFrame=0;
     656:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,moteSearchingEvent,moteData->decodeResult))
     658:	4d 8d       	ldd	r20, Y+29	; 0x1d
     65a:	5e 8d       	ldd	r21, Y+30	; 0x1e
     65c:	68 e5       	ldi	r22, 0x58	; 88
     65e:	71 e0       	ldi	r23, 0x01	; 1
     660:	c8 01       	movw	r24, r16
     662:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     666:	88 23       	and	r24, r24
     668:	91 f0       	breq	.+36     	; 0x68e <MoteInitialization+0x148>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     66a:	22 e5       	ldi	r18, 0x52	; 82
     66c:	30 e0       	ldi	r19, 0x00	; 0
     66e:	44 e0       	ldi	r20, 0x04	; 4
     670:	50 e0       	ldi	r21, 0x00	; 0
     672:	6b e6       	ldi	r22, 0x6B	; 107
     674:	71 e0       	ldi	r23, 0x01	; 1
     676:	c7 01       	movw	r24, r14
     678:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     67c:	fe 01       	movw	r30, r28
     67e:	ee 56       	subi	r30, 0x6E	; 110
     680:	ff 4f       	sbci	r31, 0xFF	; 255
     682:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     684:	ae 01       	movw	r20, r28
     686:	68 2f       	mov	r22, r24
     688:	c7 01       	movw	r24, r14
     68a:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x02);
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     68e:	20 e0       	ldi	r18, 0x00	; 0
     690:	4f ef       	ldi	r20, 0xFF	; 255
     692:	5f ef       	ldi	r21, 0xFF	; 255
     694:	60 e0       	ldi	r22, 0x00	; 0
     696:	70 e0       	ldi	r23, 0x00	; 0
     698:	80 91 d7 07 	lds	r24, 0x07D7
     69c:	90 91 d8 07 	lds	r25, 0x07D8
     6a0:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     6a4:	81 30       	cpi	r24, 0x01	; 1
     6a6:	99 f7       	brne	.-26     	; 0x68e <MoteInitialization+0x148>
	moteData->validFrame=0;
     6a8:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,negotiatingEvent,moteData->decodeResult))
     6aa:	4d 8d       	ldd	r20, Y+29	; 0x1d
     6ac:	5e 8d       	ldd	r21, Y+30	; 0x1e
     6ae:	6c e4       	ldi	r22, 0x4C	; 76
     6b0:	71 e0       	ldi	r23, 0x01	; 1
     6b2:	c8 01       	movw	r24, r16
     6b4:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     6b8:	88 23       	and	r24, r24
     6ba:	91 f0       	breq	.+36     	; 0x6e0 <MoteInitialization+0x19a>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     6bc:	22 e5       	ldi	r18, 0x52	; 82
     6be:	30 e0       	ldi	r19, 0x00	; 0
     6c0:	44 e0       	ldi	r20, 0x04	; 4
     6c2:	50 e0       	ldi	r21, 0x00	; 0
     6c4:	6b e6       	ldi	r22, 0x6B	; 107
     6c6:	71 e0       	ldi	r23, 0x01	; 1
     6c8:	c7 01       	movw	r24, r14
     6ca:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     6ce:	fe 01       	movw	r30, r28
     6d0:	ee 56       	subi	r30, 0x6E	; 110
     6d2:	ff 4f       	sbci	r31, 0xFF	; 255
     6d4:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     6d6:	ae 01       	movw	r20, r28
     6d8:	68 2f       	mov	r22, r24
     6da:	c7 01       	movw	r24, r14
     6dc:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x03);
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     6e0:	20 e0       	ldi	r18, 0x00	; 0
     6e2:	4f ef       	ldi	r20, 0xFF	; 255
     6e4:	5f ef       	ldi	r21, 0xFF	; 255
     6e6:	60 e0       	ldi	r22, 0x00	; 0
     6e8:	70 e0       	ldi	r23, 0x00	; 0
     6ea:	80 91 d7 07 	lds	r24, 0x07D7
     6ee:	90 91 d8 07 	lds	r25, 0x07D8
     6f2:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     6f6:	81 30       	cpi	r24, 0x01	; 1
     6f8:	99 f7       	brne	.-26     	; 0x6e0 <MoteInitialization+0x19a>
	moteData->validFrame=0;
     6fa:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,alarmEvent,moteData->decodeResult))
     6fc:	4d 8d       	ldd	r20, Y+29	; 0x1d
     6fe:	5e 8d       	ldd	r21, Y+30	; 0x1e
     700:	60 e4       	ldi	r22, 0x40	; 64
     702:	71 e0       	ldi	r23, 0x01	; 1
     704:	c8 01       	movw	r24, r16
     706:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     70a:	88 23       	and	r24, r24
     70c:	91 f0       	breq	.+36     	; 0x732 <MoteInitialization+0x1ec>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     70e:	22 e5       	ldi	r18, 0x52	; 82
     710:	30 e0       	ldi	r19, 0x00	; 0
     712:	44 e0       	ldi	r20, 0x04	; 4
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	6b e6       	ldi	r22, 0x6B	; 107
     718:	71 e0       	ldi	r23, 0x01	; 1
     71a:	c7 01       	movw	r24, r14
     71c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     720:	fe 01       	movw	r30, r28
     722:	ee 56       	subi	r30, 0x6E	; 110
     724:	ff 4f       	sbci	r31, 0xFF	; 255
     726:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     728:	ae 01       	movw	r20, r28
     72a:	68 2f       	mov	r22, r24
     72c:	c7 01       	movw	r24, r14
     72e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x04);
		
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) !=  pdTRUE);
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	4f ef       	ldi	r20, 0xFF	; 255
     736:	5f ef       	ldi	r21, 0xFF	; 255
     738:	60 e0       	ldi	r22, 0x00	; 0
     73a:	70 e0       	ldi	r23, 0x00	; 0
     73c:	80 91 d7 07 	lds	r24, 0x07D7
     740:	90 91 d8 07 	lds	r25, 0x07D8
     744:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     748:	81 30       	cpi	r24, 0x01	; 1
     74a:	99 f7       	brne	.-26     	; 0x732 <MoteInitialization+0x1ec>
	moteData->validFrame=0;
     74c:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,operationalEvent,moteData->decodeResult))
     74e:	4d 8d       	ldd	r20, Y+29	; 0x1d
     750:	5e 8d       	ldd	r21, Y+30	; 0x1e
     752:	64 e3       	ldi	r22, 0x34	; 52
     754:	71 e0       	ldi	r23, 0x01	; 1
     756:	c8 01       	movw	r24, r16
     758:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     75c:	88 23       	and	r24, r24
     75e:	91 f0       	breq	.+36     	; 0x784 <MoteInitialization+0x23e>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     760:	22 e5       	ldi	r18, 0x52	; 82
     762:	30 e0       	ldi	r19, 0x00	; 0
     764:	44 e0       	ldi	r20, 0x04	; 4
     766:	50 e0       	ldi	r21, 0x00	; 0
     768:	6b e6       	ldi	r22, 0x6B	; 107
     76a:	71 e0       	ldi	r23, 0x01	; 1
     76c:	c7 01       	movw	r24, r14
     76e:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     772:	fe 01       	movw	r30, r28
     774:	ee 56       	subi	r30, 0x6E	; 110
     776:	ff 4f       	sbci	r31, 0xFF	; 255
     778:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     77a:	ae 01       	movw	r20, r28
     77c:	68 2f       	mov	r22, r24
     77e:	c7 01       	movw	r24, r14
     780:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x05);
		
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     784:	20 e0       	ldi	r18, 0x00	; 0
     786:	4f ef       	ldi	r20, 0xFF	; 255
     788:	5f ef       	ldi	r21, 0xFF	; 255
     78a:	60 e0       	ldi	r22, 0x00	; 0
     78c:	70 e0       	ldi	r23, 0x00	; 0
     78e:	80 91 d7 07 	lds	r24, 0x07D7
     792:	90 91 d8 07 	lds	r25, 0x07D8
     796:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     79a:	81 30       	cpi	r24, 0x01	; 1
     79c:	99 f7       	brne	.-26     	; 0x784 <MoteInitialization+0x23e>
	moteData->validFrame=0;
     79e:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,svcIndication,moteData->decodeResult))
     7a0:	4d 8d       	ldd	r20, Y+29	; 0x1d
     7a2:	5e 8d       	ldd	r21, Y+30	; 0x1e
     7a4:	65 e2       	ldi	r22, 0x25	; 37
     7a6:	71 e0       	ldi	r23, 0x01	; 1
     7a8:	c8 01       	movw	r24, r16
     7aa:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     7ae:	88 23       	and	r24, r24
     7b0:	91 f0       	breq	.+36     	; 0x7d6 <MoteInitialization+0x290>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,serviceACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     7b2:	22 e5       	ldi	r18, 0x52	; 82
     7b4:	30 e0       	ldi	r19, 0x00	; 0
     7b6:	44 e0       	ldi	r20, 0x04	; 4
     7b8:	50 e0       	ldi	r21, 0x00	; 0
     7ba:	61 e2       	ldi	r22, 0x21	; 33
     7bc:	71 e0       	ldi	r23, 0x01	; 1
     7be:	c7 01       	movw	r24, r14
     7c0:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     7c4:	fe 01       	movw	r30, r28
     7c6:	ee 56       	subi	r30, 0x6E	; 110
     7c8:	ff 4f       	sbci	r31, 0xFF	; 255
     7ca:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     7cc:	ae 01       	movw	r20, r28
     7ce:	68 2f       	mov	r22, r24
     7d0:	c7 01       	movw	r24, r14
     7d2:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	{
		//return to state machine
	}


}
     7d6:	df 91       	pop	r29
     7d8:	cf 91       	pop	r28
     7da:	1f 91       	pop	r17
     7dc:	0f 91       	pop	r16
     7de:	ff 90       	pop	r15
     7e0:	ef 90       	pop	r14
     7e2:	08 95       	ret

000007e4 <MoteSvcInitialization>:

void MoteSvcInitialization( MoteData_p moteData){
     7e4:	cf 92       	push	r12
     7e6:	df 92       	push	r13
     7e8:	ef 92       	push	r14
     7ea:	ff 92       	push	r15
     7ec:	0f 93       	push	r16
     7ee:	1f 93       	push	r17
     7f0:	cf 93       	push	r28
     7f2:	df 93       	push	r29
     7f4:	ec 01       	movw	r28, r24

// requesting service
	
	moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,setService,sizeof(setService),sizeof(moteData->hdlcOutput));
     7f6:	8c 01       	movw	r16, r24
     7f8:	00 5e       	subi	r16, 0xE0	; 224
     7fa:	1f 4f       	sbci	r17, 0xFF	; 255
     7fc:	22 e5       	ldi	r18, 0x52	; 82
     7fe:	30 e0       	ldi	r19, 0x00	; 0
     800:	4d e0       	ldi	r20, 0x0D	; 13
     802:	50 e0       	ldi	r21, 0x00	; 0
     804:	64 e1       	ldi	r22, 0x14	; 20
     806:	71 e0       	ldi	r23, 0x01	; 1
     808:	c8 01       	movw	r24, r16
     80a:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     80e:	fe 01       	movw	r30, r28
     810:	ee 56       	subi	r30, 0x6E	; 110
     812:	ff 4f       	sbci	r31, 0xFF	; 255
     814:	80 83       	st	Z, r24
	serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     816:	ae 01       	movw	r20, r28
     818:	68 2f       	mov	r22, r24
     81a:	c8 01       	movw	r24, r16
     81c:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     820:	20 e0       	ldi	r18, 0x00	; 0
     822:	4f ef       	ldi	r20, 0xFF	; 255
     824:	5f ef       	ldi	r21, 0xFF	; 255
     826:	60 e0       	ldi	r22, 0x00	; 0
     828:	70 e0       	ldi	r23, 0x00	; 0
     82a:	80 91 d7 07 	lds	r24, 0x07D7
     82e:	90 91 d8 07 	lds	r25, 0x07D8
     832:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     836:	81 30       	cpi	r24, 0x01	; 1
     838:	99 f7       	brne	.-26     	; 0x820 <MoteSvcInitialization+0x3c>
	moteData->validFrame=0;
     83a:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,setServiceACK,moteData->decodeResult))
     83c:	4d 8d       	ldd	r20, Y+29	; 0x1d
     83e:	5e 8d       	ldd	r21, Y+30	; 0x1e
     840:	6e e0       	ldi	r22, 0x0E	; 14
     842:	71 e0       	ldi	r23, 0x01	; 1
     844:	ce 01       	movw	r24, r28
     846:	8e 58       	subi	r24, 0x8E	; 142
     848:	9f 4f       	sbci	r25, 0xFF	; 255
     84a:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
	{
		while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
		moteData->validFrame=0;
		//en este punto esperamos un svcIndication con el tiempo pedido, puede llegar uno de delayed response
		//asi que todos los respondes con el serviceACK y checamos si se nos otorgo el tiempo
			moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,serviceACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     84e:	6e 01       	movw	r12, r28
     850:	82 e9       	ldi	r24, 0x92	; 146
     852:	c8 0e       	add	r12, r24
     854:	d1 1c       	adc	r13, r1
			serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
			
		if (moteData->hdlcDecoded[3]==0x03)//delayed response
     856:	7e 01       	movw	r14, r28
     858:	e5 e7       	ldi	r30, 0x75	; 117
     85a:	ee 0e       	add	r14, r30
     85c:	f1 1c       	adc	r15, r1
	}
	
	uint8_t serviceReady=0;
	while (!serviceReady)
	{
		while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     85e:	20 e0       	ldi	r18, 0x00	; 0
     860:	4f ef       	ldi	r20, 0xFF	; 255
     862:	5f ef       	ldi	r21, 0xFF	; 255
     864:	60 e0       	ldi	r22, 0x00	; 0
     866:	70 e0       	ldi	r23, 0x00	; 0
     868:	80 91 d7 07 	lds	r24, 0x07D7
     86c:	90 91 d8 07 	lds	r25, 0x07D8
     870:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     874:	81 30       	cpi	r24, 0x01	; 1
     876:	99 f7       	brne	.-26     	; 0x85e <MoteSvcInitialization+0x7a>
		moteData->validFrame=0;
     878:	1f 8e       	std	Y+31, r1	; 0x1f
		//en este punto esperamos un svcIndication con el tiempo pedido, puede llegar uno de delayed response
		//asi que todos los respondes con el serviceACK y checamos si se nos otorgo el tiempo
			moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,serviceACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     87a:	22 e5       	ldi	r18, 0x52	; 82
     87c:	30 e0       	ldi	r19, 0x00	; 0
     87e:	44 e0       	ldi	r20, 0x04	; 4
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	61 e2       	ldi	r22, 0x21	; 33
     884:	71 e0       	ldi	r23, 0x01	; 1
     886:	c8 01       	movw	r24, r16
     888:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     88c:	f6 01       	movw	r30, r12
     88e:	80 83       	st	Z, r24
			serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     890:	ae 01       	movw	r20, r28
     892:	68 2f       	mov	r22, r24
     894:	c8 01       	movw	r24, r16
     896:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
			
		if (moteData->hdlcDecoded[3]==0x03)//delayed response
     89a:	f7 01       	movw	r30, r14
     89c:	80 81       	ld	r24, Z
     89e:	83 30       	cpi	r24, 0x03	; 3
     8a0:	f1 f2       	breq	.-68     	; 0x85e <MoteSvcInitialization+0x7a>
		{
			serviceReady=0;
		}
		else{
			if (moteData->hdlcDecoded[3]==0x00)//created
     8a2:	80 81       	ld	r24, Z
     8a4:	81 11       	cpse	r24, r1
     8a6:	db cf       	rjmp	.-74     	; 0x85e <MoteSvcInitialization+0x7a>
				serviceReady=1;
				//serialPCtx(0xF0);
			}
		}
	}
}
     8a8:	df 91       	pop	r29
     8aa:	cf 91       	pop	r28
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	ff 90       	pop	r15
     8b2:	ef 90       	pop	r14
     8b4:	df 90       	pop	r13
     8b6:	cf 90       	pop	r12
     8b8:	08 95       	ret

000008ba <compareBuffer_D>:
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     8ba:	44 23       	and	r20, r20
     8bc:	81 f0       	breq	.+32     	; 0x8de <compareBuffer_D+0x24>
     8be:	28 2f       	mov	r18, r24
     8c0:	a6 2f       	mov	r26, r22
     8c2:	b7 2f       	mov	r27, r23
     8c4:	e8 2f       	mov	r30, r24
     8c6:	f9 2f       	mov	r31, r25
	
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     8c8:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i=0;i<tam;i++)
	{
		//if (datos[i]==datos2[i])
		if (datos[i]==(datos2[i]))
     8ca:	91 91       	ld	r25, Z+
     8cc:	8d 91       	ld	r24, X+
     8ce:	98 13       	cpse	r25, r24
     8d0:	01 c0       	rjmp	.+2      	; 0x8d4 <compareBuffer_D+0x1a>
		{
			comparacion++;
     8d2:	3f 5f       	subi	r19, 0xFF	; 255
     8d4:	8e 2f       	mov	r24, r30
     8d6:	82 1b       	sub	r24, r18
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     8d8:	84 17       	cp	r24, r20
     8da:	b8 f3       	brcs	.-18     	; 0x8ca <compareBuffer_D+0x10>
     8dc:	01 c0       	rjmp	.+2      	; 0x8e0 <compareBuffer_D+0x26>
	
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     8de:	30 e0       	ldi	r19, 0x00	; 0
		{
			comparacion++;
		}
	}
	
	if (comparacion>=tam)
     8e0:	81 e0       	ldi	r24, 0x01	; 1
     8e2:	34 17       	cp	r19, r20
     8e4:	08 f4       	brcc	.+2      	; 0x8e8 <compareBuffer_D+0x2e>
     8e6:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}else return 0;
	
	
	
}
     8e8:	08 95       	ret

000008ea <sendData>:
		moteData->serialMoteSend(datos[i]);
	}
	
}

uint8_t sendData(uint8_t* data, uint8_t tam, uint8_t svcId, MoteData_p moteData){
     8ea:	df 92       	push	r13
     8ec:	ef 92       	push	r14
     8ee:	ff 92       	push	r15
     8f0:	0f 93       	push	r16
     8f2:	1f 93       	push	r17
     8f4:	cf 93       	push	r28
     8f6:	df 93       	push	r29
     8f8:	d6 2e       	mov	r13, r22
     8fa:	14 2f       	mov	r17, r20
     8fc:	e9 01       	movw	r28, r18
	
	
	moteData->sizeToSend=0;
     8fe:	79 01       	movw	r14, r18
     900:	22 e9       	ldi	r18, 0x92	; 146
     902:	e2 0e       	add	r14, r18
     904:	f1 1c       	adc	r15, r1
     906:	f7 01       	movw	r30, r14
     908:	10 82       	st	Z, r1
	uint8_t newTam = 12+tam;
	//uint8_t* arr;
	static uint8_t arr[BUFFER_LENGHT];
	//arr = (uint8_t*)malloc(newTam);
	memcpy(arr,sendComand,11);
     90a:	2b e0       	ldi	r18, 0x0B	; 11
     90c:	e6 e0       	ldi	r30, 0x06	; 6
     90e:	f1 e0       	ldi	r31, 0x01	; 1
     910:	a6 e2       	ldi	r26, 0x26	; 38
     912:	b1 e0       	ldi	r27, 0x01	; 1
     914:	01 90       	ld	r0, Z+
     916:	0d 92       	st	X+, r0
     918:	2a 95       	dec	r18
     91a:	e1 f7       	brne	.-8      	; 0x914 <__stack+0x15>
	arr[1]=newTam-3;//menos el header
     91c:	29 e0       	ldi	r18, 0x09	; 9
     91e:	26 0f       	add	r18, r22
     920:	20 93 27 01 	sts	0x0127, r18
	arr[11]=tam;//tanaio del payload
     924:	60 93 31 01 	sts	0x0131, r22
	memcpy(&arr[12],data,tam);
     928:	46 2f       	mov	r20, r22
     92a:	50 e0       	ldi	r21, 0x00	; 0
     92c:	bc 01       	movw	r22, r24
     92e:	82 e3       	ldi	r24, 0x32	; 50
     930:	91 e0       	ldi	r25, 0x01	; 1
     932:	0e 94 2a 13 	call	0x2654	; 0x2654 <memcpy>
	arr[5]=svcId;
     936:	10 93 2b 01 	sts	0x012B, r17
	moteData->sizeToSend=(int8_t)hdlc_encode_D(moteData->hdlcOutput,arr,newTam,sizeof(moteData->hdlcOutput));
     93a:	8e 01       	movw	r16, r28
     93c:	00 5e       	subi	r16, 0xE0	; 224
     93e:	1f 4f       	sbci	r17, 0xFF	; 255

uint8_t sendData(uint8_t* data, uint8_t tam, uint8_t svcId, MoteData_p moteData){
	
	
	moteData->sizeToSend=0;
	uint8_t newTam = 12+tam;
     940:	4c e0       	ldi	r20, 0x0C	; 12
     942:	4d 0d       	add	r20, r13
	memcpy(arr,sendComand,11);
	arr[1]=newTam-3;//menos el header
	arr[11]=tam;//tanaio del payload
	memcpy(&arr[12],data,tam);
	arr[5]=svcId;
	moteData->sizeToSend=(int8_t)hdlc_encode_D(moteData->hdlcOutput,arr,newTam,sizeof(moteData->hdlcOutput));
     944:	50 e0       	ldi	r21, 0x00	; 0
     946:	22 e5       	ldi	r18, 0x52	; 82
     948:	30 e0       	ldi	r19, 0x00	; 0
     94a:	66 e2       	ldi	r22, 0x26	; 38
     94c:	71 e0       	ldi	r23, 0x01	; 1
     94e:	c8 01       	movw	r24, r16
     950:	0e 94 b0 05 	call	0xb60	; 0xb60 <hdlc_encode_D>
     954:	f7 01       	movw	r30, r14
     956:	80 83       	st	Z, r24
	serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     958:	ae 01       	movw	r20, r28
     95a:	68 2f       	mov	r22, r24
     95c:	c8 01       	movw	r24, r16
     95e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	//free(arr);
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     962:	20 e0       	ldi	r18, 0x00	; 0
     964:	4f ef       	ldi	r20, 0xFF	; 255
     966:	5f ef       	ldi	r21, 0xFF	; 255
     968:	60 e0       	ldi	r22, 0x00	; 0
     96a:	70 e0       	ldi	r23, 0x00	; 0
     96c:	80 91 d7 07 	lds	r24, 0x07D7
     970:	90 91 d8 07 	lds	r25, 0x07D8
     974:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
     978:	81 30       	cpi	r24, 0x01	; 1
     97a:	99 f7       	brne	.-26     	; 0x962 <__stack+0x63>
	moteData->validFrame=0;
     97c:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer_D(moteData->hdlcDecoded,sendACK,moteData->decodeResult))
     97e:	4d 8d       	ldd	r20, Y+29	; 0x1d
     980:	5e 8d       	ldd	r21, Y+30	; 0x1e
     982:	6a e0       	ldi	r22, 0x0A	; 10
     984:	71 e0       	ldi	r23, 0x01	; 1
     986:	ce 01       	movw	r24, r28
     988:	8e 58       	subi	r24, 0x8E	; 142
     98a:	9f 4f       	sbci	r25, 0xFF	; 255
     98c:	0e 94 5d 04 	call	0x8ba	; 0x8ba <compareBuffer_D>
     990:	91 e0       	ldi	r25, 0x01	; 1
     992:	81 11       	cpse	r24, r1
     994:	01 c0       	rjmp	.+2      	; 0x998 <__stack+0x99>
     996:	90 e0       	ldi	r25, 0x00	; 0
	
	
	
	
	
}
     998:	89 2f       	mov	r24, r25
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	1f 91       	pop	r17
     9a0:	0f 91       	pop	r16
     9a2:	ff 90       	pop	r15
     9a4:	ef 90       	pop	r14
     9a6:	df 90       	pop	r13
     9a8:	08 95       	ret

000009aa <fcs_fcs16>:
 */
INT16U fcs_fcs16(INT16U fcs, INT8U data)
{
  // return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff];
   
   return (fcs >> 8) ^ pgm_read_word(&fcstab[(fcs ^ data) & 0xff]);
     9aa:	fc 01       	movw	r30, r24
     9ac:	e6 27       	eor	r30, r22
     9ae:	ff 27       	eor	r31, r31
     9b0:	ee 0f       	add	r30, r30
     9b2:	ff 1f       	adc	r31, r31
     9b4:	e5 58       	subi	r30, 0x85	; 133
     9b6:	fe 4f       	sbci	r31, 0xFE	; 254
     9b8:	25 91       	lpm	r18, Z+
     9ba:	34 91       	lpm	r19, Z
     9bc:	89 2f       	mov	r24, r25
     9be:	99 27       	eor	r25, r25
}
     9c0:	82 27       	eor	r24, r18
     9c2:	93 27       	eor	r25, r19
     9c4:	08 95       	ret

000009c6 <fcs_calcFcs>:
 * @param len - length of buffer
 * 
 * @return INT16U - calculated FCS16
 */
INT16U fcs_calcFcs(INT8U* buf, INT32U len)
{
     9c6:	0f 93       	push	r16
     9c8:	1f 93       	push	r17
     9ca:	cf 93       	push	r28
     9cc:	df 93       	push	r29
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     9ce:	61 15       	cp	r22, r1
     9d0:	71 05       	cpc	r23, r1
     9d2:	79 f0       	breq	.+30     	; 0x9f2 <fcs_calcFcs+0x2c>
     9d4:	ec 01       	movw	r28, r24
     9d6:	8c 01       	movw	r16, r24
     9d8:	06 0f       	add	r16, r22
     9da:	17 1f       	adc	r17, r23
INT16U fcs_calcFcs(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     9dc:	8f ef       	ldi	r24, 0xFF	; 255
     9de:	9f ef       	ldi	r25, 0xFF	; 255
   for (i = 0; i < len; i++) {
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, pgm_read_byte(&buf[i]));
     9e0:	fe 01       	movw	r30, r28
     9e2:	64 91       	lpm	r22, Z
     9e4:	0e 94 d5 04 	call	0x9aa	; 0x9aa <fcs_fcs16>
     9e8:	21 96       	adiw	r28, 0x01	; 1
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     9ea:	c0 17       	cp	r28, r16
     9ec:	d1 07       	cpc	r29, r17
     9ee:	c1 f7       	brne	.-16     	; 0x9e0 <fcs_calcFcs+0x1a>
     9f0:	02 c0       	rjmp	.+4      	; 0x9f6 <fcs_calcFcs+0x30>
INT16U fcs_calcFcs(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     9f2:	8f ef       	ldi	r24, 0xFF	; 255
     9f4:	9f ef       	ldi	r25, 0xFF	; 255
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, pgm_read_byte(&buf[i]));
   }

   return (fcs ^ 0xffff); /* return complement */
}
     9f6:	80 95       	com	r24
     9f8:	90 95       	com	r25
     9fa:	df 91       	pop	r29
     9fc:	cf 91       	pop	r28
     9fe:	1f 91       	pop	r17
     a00:	0f 91       	pop	r16
     a02:	08 95       	ret

00000a04 <fcs_calcFcs_D>:
 * @param len - length of buffer
 * 
 * @return INT16U - calculated FCS16
 */
INT16U fcs_calcFcs_D(INT8U* buf, INT32U len)
{
     a04:	0f 93       	push	r16
     a06:	1f 93       	push	r17
     a08:	cf 93       	push	r28
     a0a:	df 93       	push	r29
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     a0c:	61 15       	cp	r22, r1
     a0e:	71 05       	cpc	r23, r1
     a10:	69 f0       	breq	.+26     	; 0xa2c <fcs_calcFcs_D+0x28>
     a12:	ec 01       	movw	r28, r24
     a14:	8c 01       	movw	r16, r24
     a16:	06 0f       	add	r16, r22
     a18:	17 1f       	adc	r17, r23
INT16U fcs_calcFcs_D(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     a1a:	8f ef       	ldi	r24, 0xFF	; 255
     a1c:	9f ef       	ldi	r25, 0xFF	; 255
   for (i = 0; i < len; i++) {
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, buf[i]);
     a1e:	69 91       	ld	r22, Y+
     a20:	0e 94 d5 04 	call	0x9aa	; 0x9aa <fcs_fcs16>
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     a24:	c0 17       	cp	r28, r16
     a26:	d1 07       	cpc	r29, r17
     a28:	d1 f7       	brne	.-12     	; 0xa1e <fcs_calcFcs_D+0x1a>
     a2a:	02 c0       	rjmp	.+4      	; 0xa30 <fcs_calcFcs_D+0x2c>
INT16U fcs_calcFcs_D(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     a2c:	8f ef       	ldi	r24, 0xFF	; 255
     a2e:	9f ef       	ldi	r25, 0xFF	; 255
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, buf[i]);
   }

   return (fcs ^ 0xffff); /* return complement */
}
     a30:	80 95       	com	r24
     a32:	90 95       	com	r25
     a34:	df 91       	pop	r29
     a36:	cf 91       	pop	r28
     a38:	1f 91       	pop	r17
     a3a:	0f 91       	pop	r16
     a3c:	08 95       	ret

00000a3e <hdlc_decode>:
 * Returns:
 *    > 0: length of decoded data
 *    < 0: error code
 */
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
     a3e:	4f 92       	push	r4
     a40:	5f 92       	push	r5
     a42:	6f 92       	push	r6
     a44:	7f 92       	push	r7
     a46:	8f 92       	push	r8
     a48:	9f 92       	push	r9
     a4a:	af 92       	push	r10
     a4c:	bf 92       	push	r11
     a4e:	cf 92       	push	r12
     a50:	df 92       	push	r13
     a52:	ef 92       	push	r14
     a54:	ff 92       	push	r15
     a56:	0f 93       	push	r16
     a58:	1f 93       	push	r17
     a5a:	cf 93       	push	r28
     a5c:	df 93       	push	r29
     a5e:	4c 01       	movw	r8, r24
     a60:	6a 01       	movw	r12, r20
     a62:	59 01       	movw	r10, r18
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
     a64:	fa 01       	movw	r30, r20
     a66:	80 81       	ld	r24, Z
     a68:	88 23       	and	r24, r24
     a6a:	09 f4       	brne	.+2      	; 0xa6e <hdlc_decode+0x30>
     a6c:	4d c0       	rjmp	.+154    	; 0xb08 <hdlc_decode+0xca>
     a6e:	06 2f       	mov	r16, r22
     a70:	17 2f       	mov	r17, r23
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
     a72:	40 e0       	ldi	r20, 0x00	; 0
{
   INT32U i;
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
     a74:	50 e0       	ldi	r21, 0x00	; 0
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
   INT32U i;
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
   INT8U fOpenFlag = 0;
     a76:	71 2c       	mov	r7, r1
 */
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
   INT32U i;
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
     a78:	8f ef       	ldi	r24, 0xFF	; 255
     a7a:	9f ef       	ldi	r25, 0xFF	; 255
 *    < 0: error code
 */
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
   INT32U i;
   INT32U wIdx = 0;
     a7c:	e1 2c       	mov	r14, r1
     a7e:	f1 2c       	mov	r15, r1
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
     a80:	c0 e0       	ldi	r28, 0x00	; 0
     a82:	d0 e0       	ldi	r29, 0x00	; 0
               return HDLC_ERR_CRC;
            }
         }
      }
      else if (curByte == HDLC_ESCAPE_BYTE) {
         fEscape = 1;
     a84:	66 24       	eor	r6, r6
     a86:	63 94       	inc	r6
            }
            if (wIdx > maxOutLen) {
               return HDLC_ERR_LEN;
            }
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
            wIdx++;
     a88:	51 2c       	mov	r5, r1
      else {
         if (fOpenFlag) {
            fDataStart = 1;
            if (fEscape) {
               fEscape = 0;
               pOut[wIdx] = (curByte ^ 0x20);
     a8a:	68 94       	set
     a8c:	44 24       	eor	r4, r4
     a8e:	45 f8       	bld	r4, 5
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
      curByte = pIn[i];
     a90:	f8 01       	movw	r30, r16
     a92:	21 91       	ld	r18, Z+
     a94:	8f 01       	movw	r16, r30
      if (curByte == HDLC_FRAME_BYTE) {
     a96:	2e 37       	cpi	r18, 0x7E	; 126
     a98:	69 f4       	brne	.+26     	; 0xab4 <hdlc_decode+0x76>
         if (!fOpenFlag) {
     a9a:	77 20       	and	r7, r7
     a9c:	51 f1       	breq	.+84     	; 0xaf2 <hdlc_decode+0xb4>
            fOpenFlag = 1;
         }
         else if (fDataStart) {
     a9e:	55 23       	and	r21, r21
     aa0:	59 f1       	breq	.+86     	; 0xaf8 <hdlc_decode+0xba>
            // output amount of input read
            *inLen = i+1;
     aa2:	cf 5f       	subi	r28, 0xFF	; 255
     aa4:	f6 01       	movw	r30, r12
     aa6:	c0 83       	st	Z, r28
            if (calcCrc == FCS_GOOD_FCS16) {
     aa8:	88 3b       	cpi	r24, 0xB8	; 184
     aaa:	90 4f       	sbci	r25, 0xF0	; 240
     aac:	81 f5       	brne	.+96     	; 0xb0e <hdlc_decode+0xd0>
               // return length excluding CRC bytes
               return (wIdx - 2);
     aae:	c7 01       	movw	r24, r14
     ab0:	02 97       	sbiw	r24, 0x02	; 2
     ab2:	35 c0       	rjmp	.+106    	; 0xb1e <hdlc_decode+0xe0>
            else {
               return HDLC_ERR_CRC;
            }
         }
      }
      else if (curByte == HDLC_ESCAPE_BYTE) {
     ab4:	2d 37       	cpi	r18, 0x7D	; 125
     ab6:	f9 f0       	breq	.+62     	; 0xaf6 <hdlc_decode+0xb8>
         fEscape = 1;
      }
      else {
         if (fOpenFlag) {
     ab8:	77 20       	and	r7, r7
     aba:	f1 f0       	breq	.+60     	; 0xaf8 <hdlc_decode+0xba>
            fDataStart = 1;
            if (fEscape) {
     abc:	44 23       	and	r20, r20
     abe:	31 f0       	breq	.+12     	; 0xacc <hdlc_decode+0x8e>
               fEscape = 0;
               pOut[wIdx] = (curByte ^ 0x20);
     ac0:	f4 01       	movw	r30, r8
     ac2:	ee 0d       	add	r30, r14
     ac4:	ff 1d       	adc	r31, r15
     ac6:	24 25       	eor	r18, r4
     ac8:	20 83       	st	Z, r18
     aca:	04 c0       	rjmp	.+8      	; 0xad4 <hdlc_decode+0x96>
            }
            else {
               pOut[wIdx] = curByte;
     acc:	f4 01       	movw	r30, r8
     ace:	ee 0d       	add	r30, r14
     ad0:	ff 1d       	adc	r31, r15
     ad2:	20 83       	st	Z, r18
            }
            if (wIdx > maxOutLen) {
     ad4:	ae 14       	cp	r10, r14
     ad6:	bf 04       	cpc	r11, r15
     ad8:	e8 f0       	brcs	.+58     	; 0xb14 <hdlc_decode+0xd6>
               return HDLC_ERR_LEN;
            }
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
     ada:	f4 01       	movw	r30, r8
     adc:	ee 0d       	add	r30, r14
     ade:	ff 1d       	adc	r31, r15
     ae0:	60 81       	ld	r22, Z
     ae2:	0e 94 d5 04 	call	0x9aa	; 0x9aa <fcs_fcs16>
            wIdx++;
     ae6:	2f ef       	ldi	r18, 0xFF	; 255
     ae8:	e2 1a       	sub	r14, r18
     aea:	f2 0a       	sbc	r15, r18
     aec:	45 2d       	mov	r20, r5
      else if (curByte == HDLC_ESCAPE_BYTE) {
         fEscape = 1;
      }
      else {
         if (fOpenFlag) {
            fDataStart = 1;
     aee:	56 2d       	mov	r21, r6
     af0:	03 c0       	rjmp	.+6      	; 0xaf8 <hdlc_decode+0xba>
   
   for (i = 0; i < *inLen; i++) {
      curByte = pIn[i];
      if (curByte == HDLC_FRAME_BYTE) {
         if (!fOpenFlag) {
            fOpenFlag = 1;
     af2:	76 2c       	mov	r7, r6
     af4:	01 c0       	rjmp	.+2      	; 0xaf8 <hdlc_decode+0xba>
               return HDLC_ERR_CRC;
            }
         }
      }
      else if (curByte == HDLC_ESCAPE_BYTE) {
         fEscape = 1;
     af6:	46 2d       	mov	r20, r6
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
     af8:	21 96       	adiw	r28, 0x01	; 1
     afa:	f6 01       	movw	r30, r12
     afc:	20 81       	ld	r18, Z
     afe:	30 e0       	ldi	r19, 0x00	; 0
     b00:	c2 17       	cp	r28, r18
     b02:	d3 07       	cpc	r29, r19
     b04:	28 f2       	brcs	.-118    	; 0xa90 <hdlc_decode+0x52>
     b06:	09 c0       	rjmp	.+18     	; 0xb1a <hdlc_decode+0xdc>
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
            wIdx++;
         }
      }
   }
   return HDLC_ERR_FRAME;
     b08:	8e ef       	ldi	r24, 0xFE	; 254
     b0a:	9f ef       	ldi	r25, 0xFF	; 255
     b0c:	08 c0       	rjmp	.+16     	; 0xb1e <hdlc_decode+0xe0>
            if (calcCrc == FCS_GOOD_FCS16) {
               // return length excluding CRC bytes
               return (wIdx - 2);
            }
            else {
               return HDLC_ERR_CRC;
     b0e:	8f ef       	ldi	r24, 0xFF	; 255
     b10:	9f ef       	ldi	r25, 0xFF	; 255
     b12:	05 c0       	rjmp	.+10     	; 0xb1e <hdlc_decode+0xe0>
            }
            else {
               pOut[wIdx] = curByte;
            }
            if (wIdx > maxOutLen) {
               return HDLC_ERR_LEN;
     b14:	8d ef       	ldi	r24, 0xFD	; 253
     b16:	9f ef       	ldi	r25, 0xFF	; 255
     b18:	02 c0       	rjmp	.+4      	; 0xb1e <hdlc_decode+0xe0>
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
            wIdx++;
         }
      }
   }
   return HDLC_ERR_FRAME;
     b1a:	8e ef       	ldi	r24, 0xFE	; 254
     b1c:	9f ef       	ldi	r25, 0xFF	; 255
}
     b1e:	df 91       	pop	r29
     b20:	cf 91       	pop	r28
     b22:	1f 91       	pop	r17
     b24:	0f 91       	pop	r16
     b26:	ff 90       	pop	r15
     b28:	ef 90       	pop	r14
     b2a:	df 90       	pop	r13
     b2c:	cf 90       	pop	r12
     b2e:	bf 90       	pop	r11
     b30:	af 90       	pop	r10
     b32:	9f 90       	pop	r9
     b34:	8f 90       	pop	r8
     b36:	7f 90       	pop	r7
     b38:	6f 90       	pop	r6
     b3a:	5f 90       	pop	r5
     b3c:	4f 90       	pop	r4
     b3e:	08 95       	ret

00000b40 <hdlc_stuffByte>:
 * Returns:
 *    Number of bytes written to destination (1 or 2 if escaped) 
 */
INT8U hdlc_stuffByte(INT8U* pDest, INT8U byte)
{
   if (byte == HDLC_FRAME_BYTE || byte == HDLC_ESCAPE_BYTE) {
     b40:	23 e8       	ldi	r18, 0x83	; 131
     b42:	26 0f       	add	r18, r22
     b44:	22 30       	cpi	r18, 0x02	; 2
     b46:	40 f4       	brcc	.+16     	; 0xb58 <hdlc_stuffByte+0x18>
      *pDest = HDLC_ESCAPE_BYTE;
     b48:	2d e7       	ldi	r18, 0x7D	; 125
     b4a:	fc 01       	movw	r30, r24
     b4c:	20 83       	st	Z, r18
      *(pDest+1) = byte ^ 0x20;
     b4e:	20 e2       	ldi	r18, 0x20	; 32
     b50:	62 27       	eor	r22, r18
     b52:	61 83       	std	Z+1, r22	; 0x01
      return 2;
     b54:	82 e0       	ldi	r24, 0x02	; 2
     b56:	08 95       	ret
   }
   else {
      *pDest = byte;
     b58:	fc 01       	movw	r30, r24
     b5a:	60 83       	st	Z, r22
      return 1;
     b5c:	81 e0       	ldi	r24, 0x01	; 1
   }
}
     b5e:	08 95       	ret

00000b60 <hdlc_encode_D>:
 *    maxOutLen: Max output length  
 * Returns:
 *    Number of bytes written to destination 
 */
INT32S hdlc_encode_D(INT8U* pOut, INT8U* pIn, INT32U inLen, INT32U maxOutLen)
{
     b60:	8f 92       	push	r8
     b62:	9f 92       	push	r9
     b64:	af 92       	push	r10
     b66:	bf 92       	push	r11
     b68:	cf 92       	push	r12
     b6a:	df 92       	push	r13
     b6c:	ef 92       	push	r14
     b6e:	ff 92       	push	r15
     b70:	0f 93       	push	r16
     b72:	1f 93       	push	r17
     b74:	cf 93       	push	r28
     b76:	df 93       	push	r29
     b78:	7c 01       	movw	r14, r24
     b7a:	5b 01       	movw	r10, r22
     b7c:	ea 01       	movw	r28, r20
     b7e:	69 01       	movw	r12, r18
   INT16U wIdx = 0;
   INT16U txFcs = 0;
   INT8U fcsHi, fcsLo;

   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);
     b80:	ba 01       	movw	r22, r20
     b82:	c5 01       	movw	r24, r10
     b84:	0e 94 02 05 	call	0xa04	; 0xa04 <fcs_calcFcs_D>
     b88:	88 2e       	mov	r8, r24
     b8a:	99 2e       	mov	r9, r25

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     b8c:	8e e7       	ldi	r24, 0x7E	; 126
     b8e:	f7 01       	movw	r30, r14
     b90:	80 83       	st	Z, r24
   for (i = 0; i < inLen; i++) {
     b92:	20 97       	sbiw	r28, 0x00	; 0
     b94:	c9 f0       	breq	.+50     	; 0xbc8 <hdlc_encode_D+0x68>
     b96:	85 01       	movw	r16, r10
     b98:	ac 0e       	add	r10, r28
     b9a:	bd 1e       	adc	r11, r29

   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     b9c:	c1 e0       	ldi	r28, 0x01	; 1
     b9e:	d0 e0       	ldi	r29, 0x00	; 0
   for (i = 0; i < inLen; i++) {
      wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  //wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
     ba0:	f4 e0       	ldi	r31, 0x04	; 4
     ba2:	cf 1a       	sub	r12, r31
     ba4:	d1 08       	sbc	r13, r1
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
      wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
     ba6:	f8 01       	movw	r30, r16
     ba8:	61 91       	ld	r22, Z+
     baa:	8f 01       	movw	r16, r30
     bac:	c7 01       	movw	r24, r14
     bae:	8c 0f       	add	r24, r28
     bb0:	9d 1f       	adc	r25, r29
     bb2:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     bb6:	c8 0f       	add	r28, r24
     bb8:	d1 1d       	adc	r29, r1
	  //wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
     bba:	cc 16       	cp	r12, r28
     bbc:	dd 06       	cpc	r13, r29
     bbe:	f0 f0       	brcs	.+60     	; 0xbfc <hdlc_encode_D+0x9c>
   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     bc0:	0a 15       	cp	r16, r10
     bc2:	1b 05       	cpc	r17, r11
     bc4:	81 f7       	brne	.-32     	; 0xba6 <hdlc_encode_D+0x46>
     bc6:	02 c0       	rjmp	.+4      	; 0xbcc <hdlc_encode_D+0x6c>

   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     bc8:	c1 e0       	ldi	r28, 0x01	; 1
     bca:	d0 e0       	ldi	r29, 0x00	; 0
   }
   
   // append CRC
   fcsHi = (txFcs & 0xFF);
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
     bcc:	68 2d       	mov	r22, r8
     bce:	c7 01       	movw	r24, r14
     bd0:	8c 0f       	add	r24, r28
     bd2:	9d 1f       	adc	r25, r29
     bd4:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     bd8:	c8 0f       	add	r28, r24
     bda:	d1 1d       	adc	r29, r1
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
     bdc:	69 2d       	mov	r22, r9
     bde:	c7 01       	movw	r24, r14
     be0:	8c 0f       	add	r24, r28
     be2:	9d 1f       	adc	r25, r29
     be4:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     be8:	c8 0f       	add	r28, r24
     bea:	d1 1d       	adc	r29, r1
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     bec:	f7 01       	movw	r30, r14
     bee:	ec 0f       	add	r30, r28
     bf0:	fd 1f       	adc	r31, r29
     bf2:	8e e7       	ldi	r24, 0x7E	; 126
     bf4:	80 83       	st	Z, r24
     bf6:	ce 01       	movw	r24, r28
     bf8:	01 96       	adiw	r24, 0x01	; 1
   return wIdx;
     bfa:	02 c0       	rjmp	.+4      	; 0xc00 <hdlc_encode_D+0xa0>
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
      wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  //wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
         return HDLC_ERR_LEN; 
     bfc:	8d ef       	ldi	r24, 0xFD	; 253
     bfe:	9f ef       	ldi	r25, 0xFF	; 255
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   return wIdx;
}
     c00:	df 91       	pop	r29
     c02:	cf 91       	pop	r28
     c04:	1f 91       	pop	r17
     c06:	0f 91       	pop	r16
     c08:	ff 90       	pop	r15
     c0a:	ef 90       	pop	r14
     c0c:	df 90       	pop	r13
     c0e:	cf 90       	pop	r12
     c10:	bf 90       	pop	r11
     c12:	af 90       	pop	r10
     c14:	9f 90       	pop	r9
     c16:	8f 90       	pop	r8
     c18:	08 95       	ret

00000c1a <hdlc_encode>:
 *    maxOutLen: Max output length  
 * Returns:
 *    Number of bytes written to destination 
 */
INT32S hdlc_encode(INT8U* pOut, INT8U* pIn, INT32U inLen, INT32U maxOutLen)
{
     c1a:	8f 92       	push	r8
     c1c:	9f 92       	push	r9
     c1e:	af 92       	push	r10
     c20:	bf 92       	push	r11
     c22:	cf 92       	push	r12
     c24:	df 92       	push	r13
     c26:	ef 92       	push	r14
     c28:	ff 92       	push	r15
     c2a:	0f 93       	push	r16
     c2c:	1f 93       	push	r17
     c2e:	cf 93       	push	r28
     c30:	df 93       	push	r29
     c32:	7c 01       	movw	r14, r24
     c34:	5b 01       	movw	r10, r22
     c36:	ea 01       	movw	r28, r20
     c38:	69 01       	movw	r12, r18
   INT16U wIdx = 0;
   INT16U txFcs = 0;
   INT8U fcsHi, fcsLo;

   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);
     c3a:	ba 01       	movw	r22, r20
     c3c:	c5 01       	movw	r24, r10
     c3e:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <fcs_calcFcs>
     c42:	88 2e       	mov	r8, r24
     c44:	99 2e       	mov	r9, r25

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     c46:	8e e7       	ldi	r24, 0x7E	; 126
     c48:	f7 01       	movw	r30, r14
     c4a:	80 83       	st	Z, r24
   for (i = 0; i < inLen; i++) {
     c4c:	20 97       	sbiw	r28, 0x00	; 0
     c4e:	d1 f0       	breq	.+52     	; 0xc84 <hdlc_encode+0x6a>
     c50:	85 01       	movw	r16, r10
     c52:	ac 0e       	add	r10, r28
     c54:	bd 1e       	adc	r11, r29

   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     c56:	c1 e0       	ldi	r28, 0x01	; 1
     c58:	d0 e0       	ldi	r29, 0x00	; 0
   for (i = 0; i < inLen; i++) {
     // wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(&pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
     c5a:	f4 e0       	ldi	r31, 0x04	; 4
     c5c:	cf 1a       	sub	r12, r31
     c5e:	d1 08       	sbc	r13, r1

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     // wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(&pIn[i]));
     c60:	f8 01       	movw	r30, r16
     c62:	64 91       	lpm	r22, Z
     c64:	c7 01       	movw	r24, r14
     c66:	8c 0f       	add	r24, r28
     c68:	9d 1f       	adc	r25, r29
     c6a:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     c6e:	c8 0f       	add	r28, r24
     c70:	d1 1d       	adc	r29, r1
      if (wIdx > (maxOutLen - 4)) {
     c72:	cc 16       	cp	r12, r28
     c74:	dd 06       	cpc	r13, r29
     c76:	00 f1       	brcs	.+64     	; 0xcb8 <hdlc_encode+0x9e>
     c78:	0f 5f       	subi	r16, 0xFF	; 255
     c7a:	1f 4f       	sbci	r17, 0xFF	; 255
   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     c7c:	0a 15       	cp	r16, r10
     c7e:	1b 05       	cpc	r17, r11
     c80:	79 f7       	brne	.-34     	; 0xc60 <hdlc_encode+0x46>
     c82:	02 c0       	rjmp	.+4      	; 0xc88 <hdlc_encode+0x6e>

   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     c84:	c1 e0       	ldi	r28, 0x01	; 1
     c86:	d0 e0       	ldi	r29, 0x00	; 0
   }
   
   // append CRC
   fcsHi = (txFcs & 0xFF);
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
     c88:	68 2d       	mov	r22, r8
     c8a:	c7 01       	movw	r24, r14
     c8c:	8c 0f       	add	r24, r28
     c8e:	9d 1f       	adc	r25, r29
     c90:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     c94:	c8 0f       	add	r28, r24
     c96:	d1 1d       	adc	r29, r1
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
     c98:	69 2d       	mov	r22, r9
     c9a:	c7 01       	movw	r24, r14
     c9c:	8c 0f       	add	r24, r28
     c9e:	9d 1f       	adc	r25, r29
     ca0:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     ca4:	c8 0f       	add	r28, r24
     ca6:	d1 1d       	adc	r29, r1
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     ca8:	f7 01       	movw	r30, r14
     caa:	ec 0f       	add	r30, r28
     cac:	fd 1f       	adc	r31, r29
     cae:	8e e7       	ldi	r24, 0x7E	; 126
     cb0:	80 83       	st	Z, r24
     cb2:	ce 01       	movw	r24, r28
     cb4:	01 96       	adiw	r24, 0x01	; 1
   return wIdx;
     cb6:	02 c0       	rjmp	.+4      	; 0xcbc <hdlc_encode+0xa2>
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     // wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(&pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
         return HDLC_ERR_LEN; 
     cb8:	8d ef       	ldi	r24, 0xFD	; 253
     cba:	9f ef       	ldi	r25, 0xFF	; 255
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   return wIdx;
}
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	1f 91       	pop	r17
     cc2:	0f 91       	pop	r16
     cc4:	ff 90       	pop	r15
     cc6:	ef 90       	pop	r14
     cc8:	df 90       	pop	r13
     cca:	cf 90       	pop	r12
     ccc:	bf 90       	pop	r11
     cce:	af 90       	pop	r10
     cd0:	9f 90       	pop	r9
     cd2:	8f 90       	pop	r8
     cd4:	08 95       	ret

00000cd6 <vLEDInit>:
{

	// Set LED_O as output pin

	//DDR_LED_O |= (1<<BIT_LED_O);
	DDR_LED_O |= 0xFF;
     cd6:	84 b1       	in	r24, 0x04	; 4
     cd8:	8f ef       	ldi	r24, 0xFF	; 255
     cda:	84 b9       	out	0x04, r24	; 4
     cdc:	08 95       	ret

00000cde <vLEDToggle>:

{

	//Toggle LED

	PORT_LED_O ^= (1<<BIT_LED_O);
     cde:	95 b1       	in	r25, 0x05	; 5
     ce0:	81 e0       	ldi	r24, 0x01	; 1
     ce2:	89 27       	eor	r24, r25
     ce4:	85 b9       	out	0x05, r24	; 5
     ce6:	08 95       	ret

00000ce8 <serialMoteReceive>:
	xSerialPutChar(NULL,tx,0x0010);
	
}

int8_t serialMoteReceive(void){
	return UDR0;
     ce8:	80 91 c6 00 	lds	r24, 0x00C6
}
     cec:	08 95       	ret

00000cee <xSerialPortInitMinimal>:



xComPortHandle xSerialPortInitMinimal( unsigned portBASE_TYPE uxQueueLength ){	
	
	portENTER_CRITICAL();
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	0f 92       	push	r0
	/* Create the queues used by the com test task. */
		//xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     cf4:	40 e0       	ldi	r20, 0x00	; 0
     cf6:	61 e0       	ldi	r22, 0x01	; 1
     cf8:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
     cfc:	90 93 67 01 	sts	0x0167, r25
     d00:	80 93 66 01 	sts	0x0166, r24
		UBRR0 = UBRRMOTE;
     d04:	83 e0       	ldi	r24, 0x03	; 3
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	90 93 c5 00 	sts	0x00C5, r25
     d0c:	80 93 c4 00 	sts	0x00C4, r24
		//UCSR0A = (1<<U2X0);
		UCSR0B = (1<<TXEN0)|(1<<RXEN0)|(1<<RXCIE0);                // enable receiver and transmitter
     d10:	88 e9       	ldi	r24, 0x98	; 152
     d12:	80 93 c1 00 	sts	0x00C1, r24
		UCSR0C = (1<<UCSZ00)|(1<<UCSZ01);   // 8bit data format
     d16:	86 e0       	ldi	r24, 0x06	; 6
     d18:	80 93 c2 00 	sts	0x00C2, r24
		//Enable interrupts for  TX later
		
	frameHandle = xSemaphoreCreateBinary();
     d1c:	43 e0       	ldi	r20, 0x03	; 3
     d1e:	60 e0       	ldi	r22, 0x00	; 0
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
     d26:	90 93 d8 07 	sts	0x07D8, r25
     d2a:	80 93 d7 07 	sts	0x07D7, r24

	portEXIT_CRITICAL();
     d2e:	0f 90       	pop	r0
     d30:	0f be       	out	0x3f, r0	; 63

	instead just return NULL. */

	return NULL;

}
     d32:	80 e0       	ldi	r24, 0x00	; 0
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	08 95       	ret

00000d38 <xSerialPutChar>:



signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )

{
     d38:	cf 93       	push	r28
     d3a:	df 93       	push	r29
     d3c:	1f 92       	push	r1
     d3e:	cd b7       	in	r28, 0x3d	; 61
     d40:	de b7       	in	r29, 0x3e	; 62
     d42:	69 83       	std	Y+1, r22	; 0x01



	/* Return false if after the block time there is no room on the Tx queue. */

	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     d44:	20 e0       	ldi	r18, 0x00	; 0
     d46:	be 01       	movw	r22, r28
     d48:	6f 5f       	subi	r22, 0xFF	; 255
     d4a:	7f 4f       	sbci	r23, 0xFF	; 255
     d4c:	80 91 66 01 	lds	r24, 0x0166
     d50:	90 91 67 01 	lds	r25, 0x0167
     d54:	0e 94 c1 0c 	call	0x1982	; 0x1982 <xQueueGenericSend>
     d58:	81 30       	cpi	r24, 0x01	; 1
     d5a:	31 f4       	brne	.+12     	; 0xd68 <xSerialPutChar+0x30>
	



	//vInterruptOn();
	UCSR0B |= (1<<UDRIE0);
     d5c:	e1 ec       	ldi	r30, 0xC1	; 193
     d5e:	f0 e0       	ldi	r31, 0x00	; 0
     d60:	90 81       	ld	r25, Z
     d62:	90 62       	ori	r25, 0x20	; 32
     d64:	90 83       	st	Z, r25
	return pdPASS;
     d66:	01 c0       	rjmp	.+2      	; 0xd6a <xSerialPutChar+0x32>
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )

	{
		

		return pdFAIL;
     d68:	80 e0       	ldi	r24, 0x00	; 0

	//vInterruptOn();
	UCSR0B |= (1<<UDRIE0);
	return pdPASS;

}
     d6a:	0f 90       	pop	r0
     d6c:	df 91       	pop	r29
     d6e:	cf 91       	pop	r28
     d70:	08 95       	ret

00000d72 <serialMoteSend>:

}

void serialMoteSend(int8_t tx){
	
	xSerialPutChar(NULL,tx,0x0010);
     d72:	40 e1       	ldi	r20, 0x10	; 16
     d74:	50 e0       	ldi	r21, 0x00	; 0
     d76:	68 2f       	mov	r22, r24
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	0e 94 9c 06 	call	0xd38	; 0xd38 <xSerialPutChar>
     d80:	08 95       	ret

00000d82 <__vector_18>:

/*-----------------------------------------------------------*/
/*-----------------------------------------------------------*/
ISR( USART_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART_RX_vect )
{
     d82:	1f 92       	push	r1
     d84:	0f 92       	push	r0
     d86:	0f b6       	in	r0, 0x3f	; 63
     d88:	0f 92       	push	r0
     d8a:	11 24       	eor	r1, r1
     d8c:	2f 93       	push	r18
     d8e:	3f 93       	push	r19
     d90:	4f 93       	push	r20
     d92:	5f 93       	push	r21
     d94:	6f 93       	push	r22
     d96:	7f 93       	push	r23
     d98:	8f 93       	push	r24
     d9a:	9f 93       	push	r25
     d9c:	af 93       	push	r26
     d9e:	bf 93       	push	r27
     da0:	ef 93       	push	r30
     da2:	ff 93       	push	r31

	may have a higher priority than the task we have interrupted. */
	//PORTB ^= (1<<PORTB1);
	
	
	if( InterruptReception(&moteData)){//check to see if a valid frame has been received
     da4:	89 ed       	ldi	r24, 0xD9	; 217
     da6:	97 e0       	ldi	r25, 0x07	; 7
     da8:	0e 94 2f 02 	call	0x45e	; 0x45e <InterruptReception>
     dac:	88 23       	and	r24, r24
     dae:	41 f0       	breq	.+16     	; 0xdc0 <__vector_18+0x3e>
		
		xSemaphoreGiveFromISR(frameHandle,NULL);
     db0:	60 e0       	ldi	r22, 0x00	; 0
     db2:	70 e0       	ldi	r23, 0x00	; 0
     db4:	80 91 d7 07 	lds	r24, 0x07D7
     db8:	90 91 d8 07 	lds	r25, 0x07D8
     dbc:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <xQueueGiveFromISR>

		taskYIELD();

	}

}
     dc0:	ff 91       	pop	r31
     dc2:	ef 91       	pop	r30
     dc4:	bf 91       	pop	r27
     dc6:	af 91       	pop	r26
     dc8:	9f 91       	pop	r25
     dca:	8f 91       	pop	r24
     dcc:	7f 91       	pop	r23
     dce:	6f 91       	pop	r22
     dd0:	5f 91       	pop	r21
     dd2:	4f 91       	pop	r20
     dd4:	3f 91       	pop	r19
     dd6:	2f 91       	pop	r18
     dd8:	0f 90       	pop	r0
     dda:	0f be       	out	0x3f, r0	; 63
     ddc:	0f 90       	pop	r0
     dde:	1f 90       	pop	r1
     de0:	18 95       	reti

00000de2 <__vector_19>:

/*-----------------------------------------------------------*/

ISR( USART_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART_UDRE_vect )
{
     de2:	1f 92       	push	r1
     de4:	0f 92       	push	r0
     de6:	0f b6       	in	r0, 0x3f	; 63
     de8:	0f 92       	push	r0
     dea:	11 24       	eor	r1, r1
     dec:	2f 93       	push	r18
     dee:	3f 93       	push	r19
     df0:	4f 93       	push	r20
     df2:	5f 93       	push	r21
     df4:	6f 93       	push	r22
     df6:	7f 93       	push	r23
     df8:	8f 93       	push	r24
     dfa:	9f 93       	push	r25
     dfc:	af 93       	push	r26
     dfe:	bf 93       	push	r27
     e00:	ef 93       	push	r30
     e02:	ff 93       	push	r31
     e04:	cf 93       	push	r28
     e06:	df 93       	push	r29
     e08:	1f 92       	push	r1
     e0a:	cd b7       	in	r28, 0x3d	; 61
     e0c:	de b7       	in	r29, 0x3e	; 62

signed char cChar, cTaskWoken;
PORTB |= (1<<PORTB2);
     e0e:	2a 9a       	sbi	0x05, 2	; 5

	if( xQueueReceiveFromISR( xCharsForTx, &cChar,NULL) == pdTRUE )
     e10:	40 e0       	ldi	r20, 0x00	; 0
     e12:	50 e0       	ldi	r21, 0x00	; 0
     e14:	be 01       	movw	r22, r28
     e16:	6f 5f       	subi	r22, 0xFF	; 255
     e18:	7f 4f       	sbci	r23, 0xFF	; 255
     e1a:	80 91 66 01 	lds	r24, 0x0166
     e1e:	90 91 67 01 	lds	r25, 0x0167
     e22:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <xQueueReceiveFromISR>
     e26:	81 30       	cpi	r24, 0x01	; 1
     e28:	21 f4       	brne	.+8      	; 0xe32 <__vector_19+0x50>
	{
		/* Send the next character queued for Tx. */
    	UDR0 = cChar;
     e2a:	89 81       	ldd	r24, Y+1	; 0x01
     e2c:	80 93 c6 00 	sts	0x00C6, r24
     e30:	05 c0       	rjmp	.+10     	; 0xe3c <__vector_19+0x5a>
	}
	else
	{/* Queue empty, nothing to send. */
	//vInterruptOff();
	UCSR0B &= ~(1<<UDRIE0);		
     e32:	e1 ec       	ldi	r30, 0xC1	; 193
     e34:	f0 e0       	ldi	r31, 0x00	; 0
     e36:	80 81       	ld	r24, Z
     e38:	8f 7d       	andi	r24, 0xDF	; 223
     e3a:	80 83       	st	Z, r24
	}

}
     e3c:	0f 90       	pop	r0
     e3e:	df 91       	pop	r29
     e40:	cf 91       	pop	r28
     e42:	ff 91       	pop	r31
     e44:	ef 91       	pop	r30
     e46:	bf 91       	pop	r27
     e48:	af 91       	pop	r26
     e4a:	9f 91       	pop	r25
     e4c:	8f 91       	pop	r24
     e4e:	7f 91       	pop	r23
     e50:	6f 91       	pop	r22
     e52:	5f 91       	pop	r21
     e54:	4f 91       	pop	r20
     e56:	3f 91       	pop	r19
     e58:	2f 91       	pop	r18
     e5a:	0f 90       	pop	r0
     e5c:	0f be       	out	0x3f, r0	; 63
     e5e:	0f 90       	pop	r0
     e60:	1f 90       	pop	r1
     e62:	18 95       	reti

00000e64 <sendMoteData>:
	return UDR0;
}

uint8_t sendMoteData(uint8_t* data, uint8_t data_size){
	
	return sendData(data,data_size,serviceID,&moteData);
     e64:	29 ed       	ldi	r18, 0xD9	; 217
     e66:	37 e0       	ldi	r19, 0x07	; 7
     e68:	44 e0       	ldi	r20, 0x04	; 4
     e6a:	0e 94 75 04 	call	0x8ea	; 0x8ea <sendData>
	
	
}
     e6e:	08 95       	ret

00000e70 <configureMote>:


void configureMote(void){
	
	
	moteData.serialMoteSend=serialMoteSend; 
     e70:	89 eb       	ldi	r24, 0xB9	; 185
     e72:	96 e0       	ldi	r25, 0x06	; 6
     e74:	90 93 da 07 	sts	0x07DA, r25
     e78:	80 93 d9 07 	sts	0x07D9, r24
	moteData.serialMoteReceive=serialMoteReceive;
     e7c:	84 e7       	ldi	r24, 0x74	; 116
     e7e:	96 e0       	ldi	r25, 0x06	; 6
     e80:	90 93 dc 07 	sts	0x07DC, r25
     e84:	80 93 db 07 	sts	0x07DB, r24
	
	DDRC = (1<<PORTC0)|(1<<PORTC1); // select pc0 and pc1 as outputs
     e88:	83 e0       	ldi	r24, 0x03	; 3
     e8a:	87 b9       	out	0x07, r24	; 7
	//pc0 drives the reset on the whmt, pc1 is the led indication
	
	PORTC = (1<<PORTC2);//Pull up on the button, reset the mote
     e8c:	84 e0       	ldi	r24, 0x04	; 4
     e8e:	88 b9       	out	0x08, r24	; 8
	
	vTaskDelay(200);
     e90:	88 ec       	ldi	r24, 0xC8	; 200
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	0e 94 9b 11 	call	0x2336	; 0x2336 <vTaskDelay>
	
	PORTC |= (1<<PORTC0);// turn on the mote
     e98:	40 9a       	sbi	0x08, 0	; 8
	
	MoteInitialization(&moteData);
     e9a:	89 ed       	ldi	r24, 0xD9	; 217
     e9c:	97 e0       	ldi	r25, 0x07	; 7
     e9e:	0e 94 a3 02 	call	0x546	; 0x546 <MoteInitialization>
	MoteSvcInitialization(&moteData);
     ea2:	89 ed       	ldi	r24, 0xD9	; 217
     ea4:	97 e0       	ldi	r25, 0x07	; 7
     ea6:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <MoteSvcInitialization>
	
	PORTC |= (1<<PORTC1); //turn on LED, the Mote is ready to send
     eaa:	41 9a       	sbi	0x08, 1	; 8
     eac:	08 95       	ret

00000eae <TWI_Master_Initialise>:
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
	TWSR = 0; //no prescaler
     eae:	10 92 b9 00 	sts	0x00B9, r1
	TWBR = 29;// 100 Khz                             //
     eb2:	8d e1       	ldi	r24, 0x1D	; 29
     eb4:	80 93 b8 00 	sts	0x00B8, r24
     eb8:	08 95       	ret

00000eba <TWI_Start_Transceiver_With_Data>:
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
	//return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
	return twi_done;
     eba:	20 91 6a 01 	lds	r18, 0x016A
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
	unsigned char temp;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     ebe:	21 11       	cpse	r18, r1
     ec0:	fc cf       	rjmp	.-8      	; 0xeba <TWI_Start_Transceiver_With_Data>

	TWI_msgSize = msgSize;                        // Number of data to transmit.
     ec2:	60 93 6c 08 	sts	0x086C, r22
	TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
     ec6:	fc 01       	movw	r30, r24
     ec8:	20 81       	ld	r18, Z
     eca:	20 93 6d 08 	sts	0x086D, r18
	if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
     ece:	20 81       	ld	r18, Z
     ed0:	20 fd       	sbrc	r18, 0
     ed2:	12 c0       	rjmp	.+36     	; 0xef8 <TWI_Start_Transceiver_With_Data+0x3e>
	{
		for ( temp = 1; temp < msgSize; temp++ )
     ed4:	62 30       	cpi	r22, 0x02	; 2
     ed6:	80 f0       	brcs	.+32     	; 0xef8 <TWI_Start_Transceiver_With_Data+0x3e>
     ed8:	31 96       	adiw	r30, 0x01	; 1
     eda:	9c 01       	movw	r18, r24
     edc:	02 96       	adiw	r24, 0x02	; 2
     ede:	62 50       	subi	r22, 0x02	; 2
     ee0:	86 0f       	add	r24, r22
     ee2:	91 1d       	adc	r25, r1
     ee4:	df 01       	movw	r26, r30
     ee6:	a2 1b       	sub	r26, r18
     ee8:	b3 0b       	sbc	r27, r19
		TWI_buf[ temp ] = msg[ temp ];
     eea:	41 91       	ld	r20, Z+
     eec:	a3 59       	subi	r26, 0x93	; 147
     eee:	b7 4f       	sbci	r27, 0xF7	; 247
     ef0:	4c 93       	st	X, r20

	TWI_msgSize = msgSize;                        // Number of data to transmit.
	TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	{
		for ( temp = 1; temp < msgSize; temp++ )
     ef2:	e8 17       	cp	r30, r24
     ef4:	f9 07       	cpc	r31, r25
     ef6:	b1 f7       	brne	.-20     	; 0xee4 <TWI_Start_Transceiver_With_Data+0x2a>
		TWI_buf[ temp ] = msg[ temp ];
	}
	TWI_statusReg.all = 0;
     ef8:	10 92 69 01 	sts	0x0169, r1
	TWI_state         = TWI_NO_STATE ;
     efc:	88 ef       	ldi	r24, 0xF8	; 248
     efe:	80 93 00 01 	sts	0x0100, r24
	TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     f02:	85 ea       	ldi	r24, 0xA5	; 165
     f04:	80 93 bc 00 	sts	0x00BC, r24
	(1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
	(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
	(0<<TWWC);                             //
	twi_done=1;
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	80 93 6a 01 	sts	0x016A, r24
     f0e:	08 95       	ret

00000f10 <TWI_Get_Data_From_Transceiver>:
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
	//return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
	return twi_done;
     f10:	20 91 6a 01 	lds	r18, 0x016A
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
	unsigned char i;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     f14:	21 11       	cpse	r18, r1
     f16:	fc cf       	rjmp	.-8      	; 0xf10 <TWI_Get_Data_From_Transceiver>

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.
     f18:	20 91 69 01 	lds	r18, 0x0169
     f1c:	20 ff       	sbrs	r18, 0
     f1e:	0e c0       	rjmp	.+28     	; 0xf3c <TWI_Get_Data_From_Transceiver+0x2c>
	{
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     f20:	66 23       	and	r22, r22
     f22:	61 f0       	breq	.+24     	; 0xf3c <TWI_Get_Data_From_Transceiver+0x2c>
     f24:	e8 2f       	mov	r30, r24
     f26:	f9 2f       	mov	r31, r25
     f28:	80 e0       	ldi	r24, 0x00	; 0
     f2a:	90 e0       	ldi	r25, 0x00	; 0
		{
			msg[ i ] = TWI_buf[ i ];
     f2c:	dc 01       	movw	r26, r24
     f2e:	a3 59       	subi	r26, 0x93	; 147
     f30:	b7 4f       	sbci	r27, 0xF7	; 247
     f32:	2c 91       	ld	r18, X
     f34:	21 93       	st	Z+, r18
     f36:	01 96       	adiw	r24, 0x01	; 1

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.
	{
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     f38:	86 17       	cp	r24, r22
     f3a:	c0 f3       	brcs	.-16     	; 0xf2c <TWI_Get_Data_From_Transceiver+0x1c>
		{
			msg[ i ] = TWI_buf[ i ];
		}
	}
	return( TWI_statusReg.lastTransOK );
     f3c:	80 91 69 01 	lds	r24, 0x0169
}
     f40:	81 70       	andi	r24, 0x01	; 1
     f42:	08 95       	ret

00000f44 <__vector_24>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR (TWI_vect) __attribute__ ((hot, flatten));
ISR (TWI_vect)
{
     f44:	1f 92       	push	r1
     f46:	0f 92       	push	r0
     f48:	0f b6       	in	r0, 0x3f	; 63
     f4a:	0f 92       	push	r0
     f4c:	11 24       	eor	r1, r1
     f4e:	2f 93       	push	r18
     f50:	3f 93       	push	r19
     f52:	8f 93       	push	r24
     f54:	9f 93       	push	r25
     f56:	af 93       	push	r26
     f58:	bf 93       	push	r27
     f5a:	ef 93       	push	r30
     f5c:	ff 93       	push	r31
	static unsigned char TWI_bufPtr=0;
	
	switch (TWSR)
     f5e:	80 91 b9 00 	lds	r24, 0x00B9
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	fc 01       	movw	r30, r24
     f66:	38 97       	sbiw	r30, 0x08	; 8
     f68:	e1 35       	cpi	r30, 0x51	; 81
     f6a:	f1 05       	cpc	r31, r1
     f6c:	08 f0       	brcs	.+2      	; 0xf70 <__vector_24+0x2c>
     f6e:	65 c0       	rjmp	.+202    	; 0x103a <__vector_24+0xf6>
     f70:	ec 5c       	subi	r30, 0xCC	; 204
     f72:	ff 4f       	sbci	r31, 0xFF	; 255
     f74:	0c 94 24 13 	jmp	0x2648	; 0x2648 <__tablejump2__>
	{
		case TWI_START:             // START has been transmitted
		case TWI_REP_START:         // Repeated START has been transmitted
		TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
     f78:	10 92 68 01 	sts	0x0168, r1
		case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
		case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
		if (TWI_bufPtr < TWI_msgSize)
     f7c:	e0 91 68 01 	lds	r30, 0x0168
     f80:	80 91 6c 08 	lds	r24, 0x086C
     f84:	e8 17       	cp	r30, r24
     f86:	80 f4       	brcc	.+32     	; 0xfa8 <__vector_24+0x64>
		{
			twi_done=1;
     f88:	81 e0       	ldi	r24, 0x01	; 1
     f8a:	80 93 6a 01 	sts	0x016A, r24
			TWDR = TWI_buf[TWI_bufPtr++];
     f8e:	8e 0f       	add	r24, r30
     f90:	80 93 68 01 	sts	0x0168, r24
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	e3 59       	subi	r30, 0x93	; 147
     f98:	f7 4f       	sbci	r31, 0xF7	; 247
     f9a:	80 81       	ld	r24, Z
     f9c:	80 93 bb 00 	sts	0x00BB, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     fa0:	85 e8       	ldi	r24, 0x85	; 133
     fa2:	80 93 bc 00 	sts	0x00BC, r24
     fa6:	52 c0       	rjmp	.+164    	; 0x104c <__vector_24+0x108>
			(1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
			(0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
			TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully.
     fa8:	80 91 69 01 	lds	r24, 0x0169
     fac:	81 60       	ori	r24, 0x01	; 1
     fae:	80 93 69 01 	sts	0x0169, r24
			twi_done=0;
     fb2:	10 92 6a 01 	sts	0x016A, r1
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     fb6:	84 e9       	ldi	r24, 0x94	; 148
     fb8:	80 93 bc 00 	sts	0x00BC, r24
     fbc:	47 c0       	rjmp	.+142    	; 0x104c <__vector_24+0x108>
			(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			(0<<TWWC);                                 //
		}
		break;
		case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
		TWI_buf[TWI_bufPtr++] = TWDR;
     fbe:	e0 91 68 01 	lds	r30, 0x0168
     fc2:	81 e0       	ldi	r24, 0x01	; 1
     fc4:	8e 0f       	add	r24, r30
     fc6:	80 93 68 01 	sts	0x0168, r24
     fca:	f0 e0       	ldi	r31, 0x00	; 0
     fcc:	80 91 bb 00 	lds	r24, 0x00BB
     fd0:	e3 59       	subi	r30, 0x93	; 147
     fd2:	f7 4f       	sbci	r31, 0xF7	; 247
     fd4:	80 83       	st	Z, r24
		case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
		if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
     fd6:	80 91 6c 08 	lds	r24, 0x086C
     fda:	20 91 68 01 	lds	r18, 0x0168
     fde:	30 e0       	ldi	r19, 0x00	; 0
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	01 97       	sbiw	r24, 0x01	; 1
     fe4:	28 17       	cp	r18, r24
     fe6:	39 07       	cpc	r19, r25
     fe8:	3c f4       	brge	.+14     	; 0xff8 <__vector_24+0xb4>
		{
			twi_done =1;
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	80 93 6a 01 	sts	0x016A, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     ff0:	85 ec       	ldi	r24, 0xC5	; 197
     ff2:	80 93 bc 00 	sts	0x00BC, r24
     ff6:	2a c0       	rjmp	.+84     	; 0x104c <__vector_24+0x108>
			(1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
			(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
			(0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			twi_done=1;
     ff8:	81 e0       	ldi	r24, 0x01	; 1
     ffa:	80 93 6a 01 	sts	0x016A, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     ffe:	85 e8       	ldi	r24, 0x85	; 133
    1000:	80 93 bc 00 	sts	0x00BC, r24
    1004:	23 c0       	rjmp	.+70     	; 0x104c <__vector_24+0x108>
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
			(0<<TWWC);                                 //
		}
		break;
		case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
		TWI_buf[TWI_bufPtr] = TWDR;
    1006:	e0 91 68 01 	lds	r30, 0x0168
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	80 91 bb 00 	lds	r24, 0x00BB
    1010:	e3 59       	subi	r30, 0x93	; 147
    1012:	f7 4f       	sbci	r31, 0xF7	; 247
    1014:	80 83       	st	Z, r24
		TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully.
    1016:	80 91 69 01 	lds	r24, 0x0169
    101a:	81 60       	ori	r24, 0x01	; 1
    101c:	80 93 69 01 	sts	0x0169, r24
		twi_done=0;
    1020:	10 92 6a 01 	sts	0x016A, r1
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1024:	84 e9       	ldi	r24, 0x94	; 148
    1026:	80 93 bc 00 	sts	0x00BC, r24
		(0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
		(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
		(0<<TWWC);                                 //
		break;
    102a:	10 c0       	rjmp	.+32     	; 0x104c <__vector_24+0x108>
		case TWI_ARB_LOST:          // Arbitration lost
		twi_done=1;
    102c:	81 e0       	ldi	r24, 0x01	; 1
    102e:	80 93 6a 01 	sts	0x016A, r24
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1032:	85 ea       	ldi	r24, 0xA5	; 165
    1034:	80 93 bc 00 	sts	0x00BC, r24
		(1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
		(0<<TWWC);                                 //
		break;
    1038:	09 c0       	rjmp	.+18     	; 0x104c <__vector_24+0x108>
		case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received
		case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
		//    case TWI_NO_STATE              // No relevant state information available; TWINT
		case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
		default:
		twi_done=0;
    103a:	10 92 6a 01 	sts	0x016A, r1
		TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    103e:	80 91 b9 00 	lds	r24, 0x00B9
    1042:	80 93 00 01 	sts	0x0100, r24
		// Reset TWI Interface
		TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    1046:	84 e0       	ldi	r24, 0x04	; 4
    1048:	80 93 bc 00 	sts	0x00BC, r24
		(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
		(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
		(0<<TWWC);                                 //
	}
}
    104c:	ff 91       	pop	r31
    104e:	ef 91       	pop	r30
    1050:	bf 91       	pop	r27
    1052:	af 91       	pop	r26
    1054:	9f 91       	pop	r25
    1056:	8f 91       	pop	r24
    1058:	3f 91       	pop	r19
    105a:	2f 91       	pop	r18
    105c:	0f 90       	pop	r0
    105e:	0f be       	out	0x3f, r0	; 63
    1060:	0f 90       	pop	r0
    1062:	1f 90       	pop	r1
    1064:	18 95       	reti

00001066 <main>:



portSHORT main(void)
{
	startCommTasks(mainComm_TASK_PRIORITY);
    1066:	82 e0       	ldi	r24, 0x02	; 2
    1068:	0e 94 03 02 	call	0x406	; 0x406 <startCommTasks>
    startSensorTasks( mainSensor_TASK_PRIORITY);
    106c:	82 e0       	ldi	r24, 0x02	; 2
    106e:	0e 94 39 09 	call	0x1272	; 0x1272 <startSensorTasks>
	
	xTaskCreate( vLEDFlashTask, ( signed char * ) "LED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
    1072:	a1 2c       	mov	r10, r1
    1074:	b1 2c       	mov	r11, r1
    1076:	c1 2c       	mov	r12, r1
    1078:	d1 2c       	mov	r13, r1
    107a:	e1 2c       	mov	r14, r1
    107c:	f1 2c       	mov	r15, r1
    107e:	01 e0       	ldi	r16, 0x01	; 1
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	45 e5       	ldi	r20, 0x55	; 85
    1086:	50 e0       	ldi	r21, 0x00	; 0
    1088:	66 e1       	ldi	r22, 0x16	; 22
    108a:	71 e0       	ldi	r23, 0x01	; 1
    108c:	8d e4       	ldi	r24, 0x4D	; 77
    108e:	98 e0       	ldi	r25, 0x08	; 8
    1090:	0e 94 cc 0e 	call	0x1d98	; 0x1d98 <xTaskGenericCreate>

	//start scheduler

	vTaskStartScheduler();
    1094:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <vTaskStartScheduler>
    1098:	ff cf       	rjmp	.-2      	; 0x1098 <main+0x32>

0000109a <vLEDFlashTask>:
#include "FreeRTOS.h"
#include "task.h"
#include "Drivers/LED.h"
#include "mytasks.h"

void vLEDFlashTask( void *pvParameters ){
    109a:	cf 93       	push	r28
    109c:	df 93       	push	r29
    109e:	00 d0       	rcall	.+0      	; 0x10a0 <vLEDFlashTask+0x6>
    10a0:	cd b7       	in	r28, 0x3d	; 61
    10a2:	de b7       	in	r29, 0x3e	; 62

	vLEDInit();
    10a4:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vLEDInit>

	portTickType xLastWakeTime;

	const portTickType xFrequency = 1000;

	xLastWakeTime=xTaskGetTickCount();
    10a8:	0e 94 0d 10 	call	0x201a	; 0x201a <xTaskGetTickCount>
    10ac:	9a 83       	std	Y+2, r25	; 0x02
    10ae:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )	{

		vLEDToggle();
    10b0:	0e 94 6f 06 	call	0xcde	; 0xcde <vLEDToggle>

		vTaskDelayUntil(&xLastWakeTime,xFrequency);
    10b4:	68 ee       	ldi	r22, 0xE8	; 232
    10b6:	73 e0       	ldi	r23, 0x03	; 3
    10b8:	ce 01       	movw	r24, r28
    10ba:	01 96       	adiw	r24, 0x01	; 1
    10bc:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelayUntil>
    10c0:	f7 cf       	rjmp	.-18     	; 0x10b0 <vLEDFlashTask+0x16>

000010c2 <xSensorTask>:
	xSemaphoreGiveFromISR(dataReadySemaphore,NULL);
}



void xSensorTask (void* pvParameters){
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
    10c6:	cd b7       	in	r28, 0x3d	; 61
    10c8:	de b7       	in	r29, 0x3e	; 62
    10ca:	2c 97       	sbiw	r28, 0x0c	; 12
    10cc:	0f b6       	in	r0, 0x3f	; 63
    10ce:	f8 94       	cli
    10d0:	de bf       	out	0x3e, r29	; 62
    10d2:	0f be       	out	0x3f, r0	; 63
    10d4:	cd bf       	out	0x3d, r28	; 61
	static uint8_t sensorData[NUMBER_OF_BYTES_TO_SEND];
	uint8_t messages=0;
	uint8_t *pSensorData;
	
	
	DataToSend = xQueueCreate(1,sizeof(uint8_t*));
    10d6:	40 e0       	ldi	r20, 0x00	; 0
    10d8:	62 e0       	ldi	r22, 0x02	; 2
    10da:	81 e0       	ldi	r24, 0x01	; 1
    10dc:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    10e0:	90 93 7a 08 	sts	0x087A, r25
    10e4:	80 93 79 08 	sts	0x0879, r24
	//only 1 element in queue, pointer to data
	dataReadySemaphore = xSemaphoreCreateBinary();
    10e8:	43 e0       	ldi	r20, 0x03	; 3
    10ea:	60 e0       	ldi	r22, 0x00	; 0
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    10f2:	90 93 78 08 	sts	0x0878, r25
    10f6:	80 93 77 08 	sts	0x0877, r24
	//create semaphore for dataReady, the sensorTask will block on this semaphore
	while(xSemaphoreTake(moteReadySemaphore,0xFFFF) != pdTRUE);
    10fa:	20 e0       	ldi	r18, 0x00	; 0
    10fc:	4f ef       	ldi	r20, 0xFF	; 255
    10fe:	5f ef       	ldi	r21, 0xFF	; 255
    1100:	60 e0       	ldi	r22, 0x00	; 0
    1102:	70 e0       	ldi	r23, 0x00	; 0
    1104:	80 91 d5 07 	lds	r24, 0x07D5
    1108:	90 91 d6 07 	lds	r25, 0x07D6
    110c:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
    1110:	81 30       	cpi	r24, 0x01	; 1
    1112:	99 f7       	brne	.-26     	; 0x10fa <xSensorTask+0x38>
	//wait a long time for mote to be ready to send
	
	
	DDRD &= ~(1<<PORTD2); // as input
    1114:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<PORTD2); // pull up
    1116:	5a 9a       	sbi	0x0b, 2	; 11
	EIMSK |= (1<<INT0); //enable external Interrupt 0 for Data ready Pin
    1118:	e8 9a       	sbi	0x1d, 0	; 29
	EICRA |= (1<<ISC01);//the falling edge generates the interrupt
    111a:	e9 e6       	ldi	r30, 0x69	; 105
    111c:	f0 e0       	ldi	r31, 0x00	; 0
    111e:	80 81       	ld	r24, Z
    1120:	82 60       	ori	r24, 0x02	; 2
    1122:	80 83       	st	Z, r24
	
	
	TWI_Master_Initialise();
    1124:	0e 94 57 07 	call	0xeae	; 0xeae <TWI_Master_Initialise>
	
	uint8_t sensorConfig[10];
	//(8-average, 15 Hz default, normal measurement)
	sensorConfig[0]=SLAVE_SENSOR_W;
    1128:	1c e3       	ldi	r17, 0x3C	; 60
    112a:	1b 83       	std	Y+3, r17	; 0x03
	sensorConfig[1]=CRA;
    112c:	1c 82       	std	Y+4, r1	; 0x04
	sensorConfig[2]=SENSOR_FREQUENCY;
    112e:	88 e7       	ldi	r24, 0x78	; 120
    1130:	8d 83       	std	Y+5, r24	; 0x05
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
    1132:	63 e0       	ldi	r22, 0x03	; 3
    1134:	ce 01       	movw	r24, r28
    1136:	03 96       	adiw	r24, 0x03	; 3
    1138:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
	vTaskDelay(100);
    113c:	84 e6       	ldi	r24, 0x64	; 100
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	0e 94 9b 11 	call	0x2336	; 0x2336 <vTaskDelay>
	sensorConfig[0]=SLAVE_SENSOR_W;
    1144:	1b 83       	std	Y+3, r17	; 0x03
	sensorConfig[1]=CRB;
    1146:	81 e0       	ldi	r24, 0x01	; 1
    1148:	8c 83       	std	Y+4, r24	; 0x04
	sensorConfig[2]= SENSOR_GAIN; //(Gain=5, or any  other desired gain
    114a:	80 ea       	ldi	r24, 0xA0	; 160
    114c:	8d 83       	std	Y+5, r24	; 0x05
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
    114e:	63 e0       	ldi	r22, 0x03	; 3
    1150:	ce 01       	movw	r24, r28
    1152:	03 96       	adiw	r24, 0x03	; 3
    1154:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
	vTaskDelay(100);
    1158:	84 e6       	ldi	r24, 0x64	; 100
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	0e 94 9b 11 	call	0x2336	; 0x2336 <vTaskDelay>
	sensorConfig[0]=SLAVE_SENSOR_W;
    1160:	1b 83       	std	Y+3, r17	; 0x03
	sensorConfig[1]=MODE_REGISTER;
    1162:	82 e0       	ldi	r24, 0x02	; 2
    1164:	8c 83       	std	Y+4, r24	; 0x04
	sensorConfig[2]=MEASUREMENT_MODE; // single measurement mode or continous
    1166:	1d 82       	std	Y+5, r1	; 0x05
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
    1168:	63 e0       	ldi	r22, 0x03	; 3
    116a:	ce 01       	movw	r24, r28
    116c:	03 96       	adiw	r24, 0x03	; 3
    116e:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
	vTaskDelay(100);
    1172:	84 e6       	ldi	r24, 0x64	; 100
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	0e 94 9b 11 	call	0x2336	; 0x2336 <vTaskDelay>
	uint16_t messagesSent=0;
	#endif
	


	PORTC &= ~(1<<PORTC1); // TURN OFF THE LED
    117a:	41 98       	cbi	0x08, 1	; 8
	sensorConfig[1]=MODE_REGISTER;
	sensorConfig[2]=MEASUREMENT_MODE; // single measurement mode or continous
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
	vTaskDelay(100);
	#ifdef SEND_DEFINED_NUMBER
	uint16_t messagesSent=0;
    117c:	e1 2c       	mov	r14, r1
    117e:	f1 2c       	mov	r15, r1


void xSensorTask (void* pvParameters){
	
	static uint8_t sensorData[NUMBER_OF_BYTES_TO_SEND];
	uint8_t messages=0;
    1180:	b1 2c       	mov	r11, r1
		
		
			if (xSemaphoreTake(dataReadySemaphore,0xFFFF))//Block on sensor interrupt
			{
				
				sensorConfig[0]=SLAVE_SENSOR_R;
    1182:	0f 2e       	mov	r0, r31
    1184:	fd e3       	ldi	r31, 0x3D	; 61
    1186:	7f 2e       	mov	r7, r31
    1188:	f0 2d       	mov	r31, r0
				sensorConfig[1]=DATA_OUTPUT_REGISTER; //Start with X MSB register
    118a:	0f 2e       	mov	r0, r31
    118c:	f3 e0       	ldi	r31, 0x03	; 3
    118e:	af 2e       	mov	r10, r31
    1190:	f0 2d       	mov	r31, r0
    1192:	8e 01       	movw	r16, r28
    1194:	05 5f       	subi	r16, 0xF5	; 245
    1196:	1f 4f       	sbci	r17, 0xFF	; 255
					messagesSent++;
					#endif
					
					messages=0;
					//sensorData[0]=0x10;
					pSensorData = sensorData;//send the messages in a queue to commTask
    1198:	0f 2e       	mov	r0, r31
    119a:	fb e6       	ldi	r31, 0x6B	; 107
    119c:	cf 2e       	mov	r12, r31
    119e:	f1 e0       	ldi	r31, 0x01	; 1
    11a0:	df 2e       	mov	r13, r31
    11a2:	f0 2d       	mov	r31, r0
				    xQueueSend( DataToSend, (void*) &pSensorData, ( TickType_t ) 0 );
					
				}
				//we must setup the sensor for the next measurement in single measurement mode
				sensorConfig[0]=SLAVE_SENSOR_W;
    11a4:	0f 2e       	mov	r0, r31
    11a6:	fc e3       	ldi	r31, 0x3C	; 60
    11a8:	8f 2e       	mov	r8, r31
    11aa:	f0 2d       	mov	r31, r0
				sensorConfig[1]=MODE_REGISTER;
    11ac:	68 94       	set
    11ae:	99 24       	eor	r9, r9
    11b0:	91 f8       	bld	r9, 1
	PORTC &= ~(1<<PORTC1); // TURN OFF THE LED
	
	while(1){
		
		
			if (xSemaphoreTake(dataReadySemaphore,0xFFFF))//Block on sensor interrupt
    11b2:	20 e0       	ldi	r18, 0x00	; 0
    11b4:	4f ef       	ldi	r20, 0xFF	; 255
    11b6:	5f ef       	ldi	r21, 0xFF	; 255
    11b8:	60 e0       	ldi	r22, 0x00	; 0
    11ba:	70 e0       	ldi	r23, 0x00	; 0
    11bc:	80 91 77 08 	lds	r24, 0x0877
    11c0:	90 91 78 08 	lds	r25, 0x0878
    11c4:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueGenericReceive>
    11c8:	88 23       	and	r24, r24
    11ca:	99 f3       	breq	.-26     	; 0x11b2 <xSensorTask+0xf0>
			{
				
				sensorConfig[0]=SLAVE_SENSOR_R;
    11cc:	7b 82       	std	Y+3, r7	; 0x03
				sensorConfig[1]=DATA_OUTPUT_REGISTER; //Start with X MSB register
    11ce:	ac 82       	std	Y+4, r10	; 0x04
				TWI_Start_Transceiver_With_Data(sensorConfig,8); // 2 + 6 bytes to be read
    11d0:	68 e0       	ldi	r22, 0x08	; 8
    11d2:	ce 01       	movw	r24, r28
    11d4:	03 96       	adiw	r24, 0x03	; 3
    11d6:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
				vTaskDelay(1);
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	0e 94 9b 11 	call	0x2336	; 0x2336 <vTaskDelay>
				TWI_Get_Data_From_Transceiver(sensorConfig,8);// get the data from the i2c buffer into sensorconfig array
    11e2:	68 e0       	ldi	r22, 0x08	; 8
    11e4:	ce 01       	movw	r24, r28
    11e6:	03 96       	adiw	r24, 0x03	; 3
    11e8:	0e 94 88 07 	call	0xf10	; 0xf10 <TWI_Get_Data_From_Transceiver>
    11ec:	fe 01       	movw	r30, r28
    11ee:	35 96       	adiw	r30, 0x05	; 5
				
				for (uint8_t i =0;i<6;i++){
					sensorData[(messages*NUMBER_OF_BYTES_TO_READ)+i]=sensorConfig[i+2];
    11f0:	8b 2d       	mov	r24, r11
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	dc 01       	movw	r26, r24
    11f6:	aa 0f       	add	r26, r26
    11f8:	bb 1f       	adc	r27, r27
    11fa:	8a 0f       	add	r24, r26
    11fc:	9b 1f       	adc	r25, r27
    11fe:	dc 01       	movw	r26, r24
    1200:	aa 0f       	add	r26, r26
    1202:	bb 1f       	adc	r27, r27
    1204:	a5 59       	subi	r26, 0x95	; 149
    1206:	be 4f       	sbci	r27, 0xFE	; 254
    1208:	81 91       	ld	r24, Z+
    120a:	8d 93       	st	X+, r24
				sensorConfig[1]=DATA_OUTPUT_REGISTER; //Start with X MSB register
				TWI_Start_Transceiver_With_Data(sensorConfig,8); // 2 + 6 bytes to be read
				vTaskDelay(1);
				TWI_Get_Data_From_Transceiver(sensorConfig,8);// get the data from the i2c buffer into sensorconfig array
				
				for (uint8_t i =0;i<6;i++){
    120c:	e0 17       	cp	r30, r16
    120e:	f1 07       	cpc	r31, r17
    1210:	d9 f7       	brne	.-10     	; 0x1208 <xSensorTask+0x146>
					sensorData[(messages*NUMBER_OF_BYTES_TO_READ)+i]=sensorConfig[i+2];
				}
				messages++;
    1212:	b3 94       	inc	r11
				if (messages>=NUMBER_OF_MEASURES){
    1214:	87 e0       	ldi	r24, 0x07	; 7
    1216:	8b 15       	cp	r24, r11
    1218:	90 f4       	brcc	.+36     	; 0x123e <xSensorTask+0x17c>
					#ifdef SEND_DEFINED_NUMBER
					messagesSent++;
    121a:	8f ef       	ldi	r24, 0xFF	; 255
    121c:	e8 1a       	sub	r14, r24
    121e:	f8 0a       	sbc	r15, r24
					#endif
					
					messages=0;
					//sensorData[0]=0x10;
					pSensorData = sensorData;//send the messages in a queue to commTask
    1220:	da 82       	std	Y+2, r13	; 0x02
    1222:	c9 82       	std	Y+1, r12	; 0x01
				    xQueueSend( DataToSend, (void*) &pSensorData, ( TickType_t ) 0 );
    1224:	20 e0       	ldi	r18, 0x00	; 0
    1226:	40 e0       	ldi	r20, 0x00	; 0
    1228:	50 e0       	ldi	r21, 0x00	; 0
    122a:	be 01       	movw	r22, r28
    122c:	6f 5f       	subi	r22, 0xFF	; 255
    122e:	7f 4f       	sbci	r23, 0xFF	; 255
    1230:	80 91 79 08 	lds	r24, 0x0879
    1234:	90 91 7a 08 	lds	r25, 0x087A
    1238:	0e 94 c1 0c 	call	0x1982	; 0x1982 <xQueueGenericSend>
				if (messages>=NUMBER_OF_MEASURES){
					#ifdef SEND_DEFINED_NUMBER
					messagesSent++;
					#endif
					
					messages=0;
    123c:	b1 2c       	mov	r11, r1
					pSensorData = sensorData;//send the messages in a queue to commTask
				    xQueueSend( DataToSend, (void*) &pSensorData, ( TickType_t ) 0 );
					
				}
				//we must setup the sensor for the next measurement in single measurement mode
				sensorConfig[0]=SLAVE_SENSOR_W;
    123e:	8b 82       	std	Y+3, r8	; 0x03
				sensorConfig[1]=MODE_REGISTER;
    1240:	9c 82       	std	Y+4, r9	; 0x04
				sensorConfig[2]=MEASUREMENT_MODE; // single measurement mode
    1242:	1d 82       	std	Y+5, r1	; 0x05
				TWI_Start_Transceiver_With_Data(sensorConfig,3);
    1244:	6a 2d       	mov	r22, r10
    1246:	ce 01       	movw	r24, r28
    1248:	03 96       	adiw	r24, 0x03	; 3
    124a:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
				vTaskDelay(1);
    124e:	81 e0       	ldi	r24, 0x01	; 1
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	0e 94 9b 11 	call	0x2336	; 0x2336 <vTaskDelay>
				#ifdef SEND_DEFINED_NUMBER
				//USED ONLY FOR TESTING PURPOSES, THIS WILL SUSPEND THE SENSOR TASK!
				if (messagesSent == NUMBER_OF_MESSAGES)
    1256:	88 e8       	ldi	r24, 0x88	; 136
    1258:	e8 16       	cp	r14, r24
    125a:	83 e1       	ldi	r24, 0x13	; 19
    125c:	f8 06       	cpc	r15, r24
    125e:	09 f0       	breq	.+2      	; 0x1262 <xSensorTask+0x1a0>
    1260:	a8 cf       	rjmp	.-176    	; 0x11b2 <xSensorTask+0xf0>
				{
					PORTC |= (1<<PORTC1); //TURN ON THE LED
    1262:	41 9a       	sbi	0x08, 1	; 8
					vTaskSuspend(xSensorHandle);
    1264:	80 91 7b 08 	lds	r24, 0x087B
    1268:	90 91 7c 08 	lds	r25, 0x087C
    126c:	0e 94 19 12 	call	0x2432	; 0x2432 <vTaskSuspend>
    1270:	a0 cf       	rjmp	.-192    	; 0x11b2 <xSensorTask+0xf0>

00001272 <startSensorTasks>:

QueueHandle_t DataToSend;


TaskHandle_t xSensorHandle;
void startSensorTasks(UBaseType_t uxPriority){
    1272:	af 92       	push	r10
    1274:	bf 92       	push	r11
    1276:	cf 92       	push	r12
    1278:	df 92       	push	r13
    127a:	ef 92       	push	r14
    127c:	ff 92       	push	r15
    127e:	0f 93       	push	r16
	
	xTaskCreate( xSensorTask,( signed char * ) "Sensor", sensorSTACK_SIZE, NULL, uxPriority, &xSensorHandle );
    1280:	a1 2c       	mov	r10, r1
    1282:	b1 2c       	mov	r11, r1
    1284:	c1 2c       	mov	r12, r1
    1286:	d1 2c       	mov	r13, r1
    1288:	0f 2e       	mov	r0, r31
    128a:	fb e7       	ldi	r31, 0x7B	; 123
    128c:	ef 2e       	mov	r14, r31
    128e:	f8 e0       	ldi	r31, 0x08	; 8
    1290:	ff 2e       	mov	r15, r31
    1292:	f0 2d       	mov	r31, r0
    1294:	08 2f       	mov	r16, r24
    1296:	20 e0       	ldi	r18, 0x00	; 0
    1298:	30 e0       	ldi	r19, 0x00	; 0
    129a:	40 e0       	ldi	r20, 0x00	; 0
    129c:	51 e0       	ldi	r21, 0x01	; 1
    129e:	6a e1       	ldi	r22, 0x1A	; 26
    12a0:	71 e0       	ldi	r23, 0x01	; 1
    12a2:	81 e6       	ldi	r24, 0x61	; 97
    12a4:	98 e0       	ldi	r25, 0x08	; 8
    12a6:	0e 94 cc 0e 	call	0x1d98	; 0x1d98 <xTaskGenericCreate>
	
}
    12aa:	0f 91       	pop	r16
    12ac:	ff 90       	pop	r15
    12ae:	ef 90       	pop	r14
    12b0:	df 90       	pop	r13
    12b2:	cf 90       	pop	r12
    12b4:	bf 90       	pop	r11
    12b6:	af 90       	pop	r10
    12b8:	08 95       	ret

000012ba <__vector_1>:
#ifdef DATA_READY_INTERRUPT


ISR( INT0_vect ) __attribute__ ((hot, flatten));
ISR( INT0_vect )
{
    12ba:	1f 92       	push	r1
    12bc:	0f 92       	push	r0
    12be:	0f b6       	in	r0, 0x3f	; 63
    12c0:	0f 92       	push	r0
    12c2:	11 24       	eor	r1, r1
    12c4:	2f 93       	push	r18
    12c6:	3f 93       	push	r19
    12c8:	4f 93       	push	r20
    12ca:	5f 93       	push	r21
    12cc:	6f 93       	push	r22
    12ce:	7f 93       	push	r23
    12d0:	8f 93       	push	r24
    12d2:	9f 93       	push	r25
    12d4:	af 93       	push	r26
    12d6:	bf 93       	push	r27
    12d8:	ef 93       	push	r30
    12da:	ff 93       	push	r31
	xSemaphoreGiveFromISR(dataReadySemaphore,NULL);
    12dc:	60 e0       	ldi	r22, 0x00	; 0
    12de:	70 e0       	ldi	r23, 0x00	; 0
    12e0:	80 91 77 08 	lds	r24, 0x0877
    12e4:	90 91 78 08 	lds	r25, 0x0878
    12e8:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <xQueueGiveFromISR>
}
    12ec:	ff 91       	pop	r31
    12ee:	ef 91       	pop	r30
    12f0:	bf 91       	pop	r27
    12f2:	af 91       	pop	r26
    12f4:	9f 91       	pop	r25
    12f6:	8f 91       	pop	r24
    12f8:	7f 91       	pop	r23
    12fa:	6f 91       	pop	r22
    12fc:	5f 91       	pop	r21
    12fe:	4f 91       	pop	r20
    1300:	3f 91       	pop	r19
    1302:	2f 91       	pop	r18
    1304:	0f 90       	pop	r0
    1306:	0f be       	out	0x3f, r0	; 63
    1308:	0f 90       	pop	r0
    130a:	1f 90       	pop	r1
    130c:	18 95       	reti

0000130e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    130e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1310:	03 96       	adiw	r24, 0x03	; 3
    1312:	92 83       	std	Z+2, r25	; 0x02
    1314:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1316:	2f ef       	ldi	r18, 0xFF	; 255
    1318:	3f ef       	ldi	r19, 0xFF	; 255
    131a:	34 83       	std	Z+4, r19	; 0x04
    131c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    131e:	96 83       	std	Z+6, r25	; 0x06
    1320:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1322:	90 87       	std	Z+8, r25	; 0x08
    1324:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1326:	10 82       	st	Z, r1
    1328:	08 95       	ret

0000132a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    132a:	fc 01       	movw	r30, r24
    132c:	11 86       	std	Z+9, r1	; 0x09
    132e:	10 86       	std	Z+8, r1	; 0x08
    1330:	08 95       	ret

00001332 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1332:	cf 93       	push	r28
    1334:	df 93       	push	r29
    1336:	9c 01       	movw	r18, r24
    1338:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    133a:	dc 01       	movw	r26, r24
    133c:	11 96       	adiw	r26, 0x01	; 1
    133e:	cd 91       	ld	r28, X+
    1340:	dc 91       	ld	r29, X
    1342:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1344:	d3 83       	std	Z+3, r29	; 0x03
    1346:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1348:	8c 81       	ldd	r24, Y+4	; 0x04
    134a:	9d 81       	ldd	r25, Y+5	; 0x05
    134c:	95 83       	std	Z+5, r25	; 0x05
    134e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1350:	8c 81       	ldd	r24, Y+4	; 0x04
    1352:	9d 81       	ldd	r25, Y+5	; 0x05
    1354:	dc 01       	movw	r26, r24
    1356:	13 96       	adiw	r26, 0x03	; 3
    1358:	7c 93       	st	X, r23
    135a:	6e 93       	st	-X, r22
    135c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    135e:	7d 83       	std	Y+5, r23	; 0x05
    1360:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1362:	31 87       	std	Z+9, r19	; 0x09
    1364:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1366:	f9 01       	movw	r30, r18
    1368:	80 81       	ld	r24, Z
    136a:	8f 5f       	subi	r24, 0xFF	; 255
    136c:	80 83       	st	Z, r24
}
    136e:	df 91       	pop	r29
    1370:	cf 91       	pop	r28
    1372:	08 95       	ret

00001374 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1374:	cf 93       	push	r28
    1376:	df 93       	push	r29
    1378:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    137a:	48 81       	ld	r20, Y
    137c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    137e:	4f 3f       	cpi	r20, 0xFF	; 255
    1380:	2f ef       	ldi	r18, 0xFF	; 255
    1382:	52 07       	cpc	r21, r18
    1384:	21 f4       	brne	.+8      	; 0x138e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1386:	fc 01       	movw	r30, r24
    1388:	a7 81       	ldd	r26, Z+7	; 0x07
    138a:	b0 85       	ldd	r27, Z+8	; 0x08
    138c:	0d c0       	rjmp	.+26     	; 0x13a8 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    138e:	dc 01       	movw	r26, r24
    1390:	13 96       	adiw	r26, 0x03	; 3
    1392:	12 96       	adiw	r26, 0x02	; 2
    1394:	ed 91       	ld	r30, X+
    1396:	fc 91       	ld	r31, X
    1398:	13 97       	sbiw	r26, 0x03	; 3
    139a:	20 81       	ld	r18, Z
    139c:	31 81       	ldd	r19, Z+1	; 0x01
    139e:	42 17       	cp	r20, r18
    13a0:	53 07       	cpc	r21, r19
    13a2:	10 f0       	brcs	.+4      	; 0x13a8 <vListInsert+0x34>
    13a4:	df 01       	movw	r26, r30
    13a6:	f5 cf       	rjmp	.-22     	; 0x1392 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    13a8:	12 96       	adiw	r26, 0x02	; 2
    13aa:	ed 91       	ld	r30, X+
    13ac:	fc 91       	ld	r31, X
    13ae:	13 97       	sbiw	r26, 0x03	; 3
    13b0:	fb 83       	std	Y+3, r31	; 0x03
    13b2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    13b4:	d5 83       	std	Z+5, r29	; 0x05
    13b6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    13b8:	bd 83       	std	Y+5, r27	; 0x05
    13ba:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    13bc:	13 96       	adiw	r26, 0x03	; 3
    13be:	dc 93       	st	X, r29
    13c0:	ce 93       	st	-X, r28
    13c2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    13c4:	99 87       	std	Y+9, r25	; 0x09
    13c6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    13c8:	fc 01       	movw	r30, r24
    13ca:	20 81       	ld	r18, Z
    13cc:	2f 5f       	subi	r18, 0xFF	; 255
    13ce:	20 83       	st	Z, r18
}
    13d0:	df 91       	pop	r29
    13d2:	cf 91       	pop	r28
    13d4:	08 95       	ret

000013d6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    13d6:	cf 93       	push	r28
    13d8:	df 93       	push	r29
    13da:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    13dc:	a0 85       	ldd	r26, Z+8	; 0x08
    13de:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    13e0:	c2 81       	ldd	r28, Z+2	; 0x02
    13e2:	d3 81       	ldd	r29, Z+3	; 0x03
    13e4:	84 81       	ldd	r24, Z+4	; 0x04
    13e6:	95 81       	ldd	r25, Z+5	; 0x05
    13e8:	9d 83       	std	Y+5, r25	; 0x05
    13ea:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    13ec:	c4 81       	ldd	r28, Z+4	; 0x04
    13ee:	d5 81       	ldd	r29, Z+5	; 0x05
    13f0:	82 81       	ldd	r24, Z+2	; 0x02
    13f2:	93 81       	ldd	r25, Z+3	; 0x03
    13f4:	9b 83       	std	Y+3, r25	; 0x03
    13f6:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    13f8:	11 96       	adiw	r26, 0x01	; 1
    13fa:	cd 91       	ld	r28, X+
    13fc:	dc 91       	ld	r29, X
    13fe:	12 97       	sbiw	r26, 0x02	; 2
    1400:	ce 17       	cp	r28, r30
    1402:	df 07       	cpc	r29, r31
    1404:	31 f4       	brne	.+12     	; 0x1412 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1406:	8c 81       	ldd	r24, Y+4	; 0x04
    1408:	9d 81       	ldd	r25, Y+5	; 0x05
    140a:	12 96       	adiw	r26, 0x02	; 2
    140c:	9c 93       	st	X, r25
    140e:	8e 93       	st	-X, r24
    1410:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1412:	11 86       	std	Z+9, r1	; 0x09
    1414:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1416:	8c 91       	ld	r24, X
    1418:	81 50       	subi	r24, 0x01	; 1
    141a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	08 95       	ret

00001422 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1422:	31 e1       	ldi	r19, 0x11	; 17
    1424:	fc 01       	movw	r30, r24
    1426:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1428:	31 97       	sbiw	r30, 0x01	; 1
    142a:	22 e2       	ldi	r18, 0x22	; 34
    142c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    142e:	31 97       	sbiw	r30, 0x01	; 1
    1430:	a3 e3       	ldi	r26, 0x33	; 51
    1432:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1434:	31 97       	sbiw	r30, 0x01	; 1
    1436:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1438:	31 97       	sbiw	r30, 0x01	; 1
    143a:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    143c:	31 97       	sbiw	r30, 0x01	; 1
    143e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1440:	31 97       	sbiw	r30, 0x01	; 1
    1442:	60 e8       	ldi	r22, 0x80	; 128
    1444:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1446:	31 97       	sbiw	r30, 0x01	; 1
    1448:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    144a:	31 97       	sbiw	r30, 0x01	; 1
    144c:	62 e0       	ldi	r22, 0x02	; 2
    144e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1450:	31 97       	sbiw	r30, 0x01	; 1
    1452:	63 e0       	ldi	r22, 0x03	; 3
    1454:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1456:	31 97       	sbiw	r30, 0x01	; 1
    1458:	64 e0       	ldi	r22, 0x04	; 4
    145a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    145c:	31 97       	sbiw	r30, 0x01	; 1
    145e:	65 e0       	ldi	r22, 0x05	; 5
    1460:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1462:	31 97       	sbiw	r30, 0x01	; 1
    1464:	66 e0       	ldi	r22, 0x06	; 6
    1466:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1468:	31 97       	sbiw	r30, 0x01	; 1
    146a:	67 e0       	ldi	r22, 0x07	; 7
    146c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    146e:	31 97       	sbiw	r30, 0x01	; 1
    1470:	68 e0       	ldi	r22, 0x08	; 8
    1472:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1474:	31 97       	sbiw	r30, 0x01	; 1
    1476:	69 e0       	ldi	r22, 0x09	; 9
    1478:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    147a:	31 97       	sbiw	r30, 0x01	; 1
    147c:	60 e1       	ldi	r22, 0x10	; 16
    147e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1480:	31 97       	sbiw	r30, 0x01	; 1
    1482:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1484:	31 97       	sbiw	r30, 0x01	; 1
    1486:	32 e1       	ldi	r19, 0x12	; 18
    1488:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    148a:	31 97       	sbiw	r30, 0x01	; 1
    148c:	33 e1       	ldi	r19, 0x13	; 19
    148e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1490:	31 97       	sbiw	r30, 0x01	; 1
    1492:	34 e1       	ldi	r19, 0x14	; 20
    1494:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1496:	31 97       	sbiw	r30, 0x01	; 1
    1498:	35 e1       	ldi	r19, 0x15	; 21
    149a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    149c:	31 97       	sbiw	r30, 0x01	; 1
    149e:	36 e1       	ldi	r19, 0x16	; 22
    14a0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    14a2:	31 97       	sbiw	r30, 0x01	; 1
    14a4:	37 e1       	ldi	r19, 0x17	; 23
    14a6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    14a8:	31 97       	sbiw	r30, 0x01	; 1
    14aa:	38 e1       	ldi	r19, 0x18	; 24
    14ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    14ae:	31 97       	sbiw	r30, 0x01	; 1
    14b0:	39 e1       	ldi	r19, 0x19	; 25
    14b2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    14b4:	31 97       	sbiw	r30, 0x01	; 1
    14b6:	30 e2       	ldi	r19, 0x20	; 32
    14b8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    14ba:	31 97       	sbiw	r30, 0x01	; 1
    14bc:	31 e2       	ldi	r19, 0x21	; 33
    14be:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    14c0:	31 97       	sbiw	r30, 0x01	; 1
    14c2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    14c4:	31 97       	sbiw	r30, 0x01	; 1
    14c6:	23 e2       	ldi	r18, 0x23	; 35
    14c8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    14ca:	31 97       	sbiw	r30, 0x01	; 1
    14cc:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    14ce:	31 97       	sbiw	r30, 0x01	; 1
    14d0:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    14d2:	31 97       	sbiw	r30, 0x01	; 1
    14d4:	26 e2       	ldi	r18, 0x26	; 38
    14d6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    14d8:	31 97       	sbiw	r30, 0x01	; 1
    14da:	27 e2       	ldi	r18, 0x27	; 39
    14dc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    14de:	31 97       	sbiw	r30, 0x01	; 1
    14e0:	28 e2       	ldi	r18, 0x28	; 40
    14e2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    14e4:	31 97       	sbiw	r30, 0x01	; 1
    14e6:	29 e2       	ldi	r18, 0x29	; 41
    14e8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    14ea:	31 97       	sbiw	r30, 0x01	; 1
    14ec:	20 e3       	ldi	r18, 0x30	; 48
    14ee:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    14f0:	31 97       	sbiw	r30, 0x01	; 1
    14f2:	21 e3       	ldi	r18, 0x31	; 49
    14f4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    14f6:	86 97       	sbiw	r24, 0x26	; 38
    14f8:	08 95       	ret

000014fa <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    14fa:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    14fe:	82 e7       	ldi	r24, 0x72	; 114
    1500:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1504:	8b e0       	ldi	r24, 0x0B	; 11
    1506:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    150a:	ef e6       	ldi	r30, 0x6F	; 111
    150c:	f0 e0       	ldi	r31, 0x00	; 0
    150e:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1510:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    1512:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1514:	a0 91 d3 07 	lds	r26, 0x07D3
    1518:	b0 91 d4 07 	lds	r27, 0x07D4
    151c:	cd 91       	ld	r28, X+
    151e:	cd bf       	out	0x3d, r28	; 61
    1520:	dd 91       	ld	r29, X+
    1522:	de bf       	out	0x3e, r29	; 62
    1524:	ff 91       	pop	r31
    1526:	ef 91       	pop	r30
    1528:	df 91       	pop	r29
    152a:	cf 91       	pop	r28
    152c:	bf 91       	pop	r27
    152e:	af 91       	pop	r26
    1530:	9f 91       	pop	r25
    1532:	8f 91       	pop	r24
    1534:	7f 91       	pop	r23
    1536:	6f 91       	pop	r22
    1538:	5f 91       	pop	r21
    153a:	4f 91       	pop	r20
    153c:	3f 91       	pop	r19
    153e:	2f 91       	pop	r18
    1540:	1f 91       	pop	r17
    1542:	0f 91       	pop	r16
    1544:	ff 90       	pop	r15
    1546:	ef 90       	pop	r14
    1548:	df 90       	pop	r13
    154a:	cf 90       	pop	r12
    154c:	bf 90       	pop	r11
    154e:	af 90       	pop	r10
    1550:	9f 90       	pop	r9
    1552:	8f 90       	pop	r8
    1554:	7f 90       	pop	r7
    1556:	6f 90       	pop	r6
    1558:	5f 90       	pop	r5
    155a:	4f 90       	pop	r4
    155c:	3f 90       	pop	r3
    155e:	2f 90       	pop	r2
    1560:	1f 90       	pop	r1
    1562:	0f 90       	pop	r0
    1564:	0f be       	out	0x3f, r0	; 63
    1566:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1568:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    156a:	81 e0       	ldi	r24, 0x01	; 1
    156c:	08 95       	ret

0000156e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    156e:	0f 92       	push	r0
    1570:	0f b6       	in	r0, 0x3f	; 63
    1572:	f8 94       	cli
    1574:	0f 92       	push	r0
    1576:	1f 92       	push	r1
    1578:	11 24       	eor	r1, r1
    157a:	2f 92       	push	r2
    157c:	3f 92       	push	r3
    157e:	4f 92       	push	r4
    1580:	5f 92       	push	r5
    1582:	6f 92       	push	r6
    1584:	7f 92       	push	r7
    1586:	8f 92       	push	r8
    1588:	9f 92       	push	r9
    158a:	af 92       	push	r10
    158c:	bf 92       	push	r11
    158e:	cf 92       	push	r12
    1590:	df 92       	push	r13
    1592:	ef 92       	push	r14
    1594:	ff 92       	push	r15
    1596:	0f 93       	push	r16
    1598:	1f 93       	push	r17
    159a:	2f 93       	push	r18
    159c:	3f 93       	push	r19
    159e:	4f 93       	push	r20
    15a0:	5f 93       	push	r21
    15a2:	6f 93       	push	r22
    15a4:	7f 93       	push	r23
    15a6:	8f 93       	push	r24
    15a8:	9f 93       	push	r25
    15aa:	af 93       	push	r26
    15ac:	bf 93       	push	r27
    15ae:	cf 93       	push	r28
    15b0:	df 93       	push	r29
    15b2:	ef 93       	push	r30
    15b4:	ff 93       	push	r31
    15b6:	a0 91 d3 07 	lds	r26, 0x07D3
    15ba:	b0 91 d4 07 	lds	r27, 0x07D4
    15be:	0d b6       	in	r0, 0x3d	; 61
    15c0:	0d 92       	st	X+, r0
    15c2:	0e b6       	in	r0, 0x3e	; 62
    15c4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    15c6:	0e 94 bb 11 	call	0x2376	; 0x2376 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    15ca:	a0 91 d3 07 	lds	r26, 0x07D3
    15ce:	b0 91 d4 07 	lds	r27, 0x07D4
    15d2:	cd 91       	ld	r28, X+
    15d4:	cd bf       	out	0x3d, r28	; 61
    15d6:	dd 91       	ld	r29, X+
    15d8:	de bf       	out	0x3e, r29	; 62
    15da:	ff 91       	pop	r31
    15dc:	ef 91       	pop	r30
    15de:	df 91       	pop	r29
    15e0:	cf 91       	pop	r28
    15e2:	bf 91       	pop	r27
    15e4:	af 91       	pop	r26
    15e6:	9f 91       	pop	r25
    15e8:	8f 91       	pop	r24
    15ea:	7f 91       	pop	r23
    15ec:	6f 91       	pop	r22
    15ee:	5f 91       	pop	r21
    15f0:	4f 91       	pop	r20
    15f2:	3f 91       	pop	r19
    15f4:	2f 91       	pop	r18
    15f6:	1f 91       	pop	r17
    15f8:	0f 91       	pop	r16
    15fa:	ff 90       	pop	r15
    15fc:	ef 90       	pop	r14
    15fe:	df 90       	pop	r13
    1600:	cf 90       	pop	r12
    1602:	bf 90       	pop	r11
    1604:	af 90       	pop	r10
    1606:	9f 90       	pop	r9
    1608:	8f 90       	pop	r8
    160a:	7f 90       	pop	r7
    160c:	6f 90       	pop	r6
    160e:	5f 90       	pop	r5
    1610:	4f 90       	pop	r4
    1612:	3f 90       	pop	r3
    1614:	2f 90       	pop	r2
    1616:	1f 90       	pop	r1
    1618:	0f 90       	pop	r0
    161a:	0f be       	out	0x3f, r0	; 63
    161c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    161e:	08 95       	ret

00001620 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1620:	0f 92       	push	r0
    1622:	0f b6       	in	r0, 0x3f	; 63
    1624:	f8 94       	cli
    1626:	0f 92       	push	r0
    1628:	1f 92       	push	r1
    162a:	11 24       	eor	r1, r1
    162c:	2f 92       	push	r2
    162e:	3f 92       	push	r3
    1630:	4f 92       	push	r4
    1632:	5f 92       	push	r5
    1634:	6f 92       	push	r6
    1636:	7f 92       	push	r7
    1638:	8f 92       	push	r8
    163a:	9f 92       	push	r9
    163c:	af 92       	push	r10
    163e:	bf 92       	push	r11
    1640:	cf 92       	push	r12
    1642:	df 92       	push	r13
    1644:	ef 92       	push	r14
    1646:	ff 92       	push	r15
    1648:	0f 93       	push	r16
    164a:	1f 93       	push	r17
    164c:	2f 93       	push	r18
    164e:	3f 93       	push	r19
    1650:	4f 93       	push	r20
    1652:	5f 93       	push	r21
    1654:	6f 93       	push	r22
    1656:	7f 93       	push	r23
    1658:	8f 93       	push	r24
    165a:	9f 93       	push	r25
    165c:	af 93       	push	r26
    165e:	bf 93       	push	r27
    1660:	cf 93       	push	r28
    1662:	df 93       	push	r29
    1664:	ef 93       	push	r30
    1666:	ff 93       	push	r31
    1668:	a0 91 d3 07 	lds	r26, 0x07D3
    166c:	b0 91 d4 07 	lds	r27, 0x07D4
    1670:	0d b6       	in	r0, 0x3d	; 61
    1672:	0d 92       	st	X+, r0
    1674:	0e b6       	in	r0, 0x3e	; 62
    1676:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1678:	0e 94 17 10 	call	0x202e	; 0x202e <xTaskIncrementTick>
    167c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    167e:	0e 94 bb 11 	call	0x2376	; 0x2376 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1682:	a0 91 d3 07 	lds	r26, 0x07D3
    1686:	b0 91 d4 07 	lds	r27, 0x07D4
    168a:	cd 91       	ld	r28, X+
    168c:	cd bf       	out	0x3d, r28	; 61
    168e:	dd 91       	ld	r29, X+
    1690:	de bf       	out	0x3e, r29	; 62
    1692:	ff 91       	pop	r31
    1694:	ef 91       	pop	r30
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	bf 91       	pop	r27
    169c:	af 91       	pop	r26
    169e:	9f 91       	pop	r25
    16a0:	8f 91       	pop	r24
    16a2:	7f 91       	pop	r23
    16a4:	6f 91       	pop	r22
    16a6:	5f 91       	pop	r21
    16a8:	4f 91       	pop	r20
    16aa:	3f 91       	pop	r19
    16ac:	2f 91       	pop	r18
    16ae:	1f 91       	pop	r17
    16b0:	0f 91       	pop	r16
    16b2:	ff 90       	pop	r15
    16b4:	ef 90       	pop	r14
    16b6:	df 90       	pop	r13
    16b8:	cf 90       	pop	r12
    16ba:	bf 90       	pop	r11
    16bc:	af 90       	pop	r10
    16be:	9f 90       	pop	r9
    16c0:	8f 90       	pop	r8
    16c2:	7f 90       	pop	r7
    16c4:	6f 90       	pop	r6
    16c6:	5f 90       	pop	r5
    16c8:	4f 90       	pop	r4
    16ca:	3f 90       	pop	r3
    16cc:	2f 90       	pop	r2
    16ce:	1f 90       	pop	r1
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    16d6:	08 95       	ret

000016d8 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    16d8:	0e 94 10 0b 	call	0x1620	; 0x1620 <vPortYieldFromTick>
		asm volatile ( "reti" );
    16dc:	18 95       	reti

000016de <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    16de:	cf 93       	push	r28
    16e0:	df 93       	push	r29
    16e2:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    16e4:	0e 94 07 10 	call	0x200e	; 0x200e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    16e8:	80 91 9b 01 	lds	r24, 0x019B
    16ec:	90 91 9c 01 	lds	r25, 0x019C
    16f0:	89 2b       	or	r24, r25
    16f2:	31 f4       	brne	.+12     	; 0x1700 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    16f4:	80 ea       	ldi	r24, 0xA0	; 160
    16f6:	91 e0       	ldi	r25, 0x01	; 1
    16f8:	90 93 9c 01 	sts	0x019C, r25
    16fc:	80 93 9b 01 	sts	0x019B, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1700:	40 91 9d 01 	lds	r20, 0x019D
    1704:	50 91 9e 01 	lds	r21, 0x019E
    1708:	9e 01       	movw	r18, r28
    170a:	24 0f       	add	r18, r20
    170c:	35 1f       	adc	r19, r21
    170e:	2b 3d       	cpi	r18, 0xDB	; 219
    1710:	85 e0       	ldi	r24, 0x05	; 5
    1712:	38 07       	cpc	r19, r24
    1714:	70 f4       	brcc	.+28     	; 0x1732 <pvPortMalloc+0x54>
    1716:	42 17       	cp	r20, r18
    1718:	53 07       	cpc	r21, r19
    171a:	70 f4       	brcc	.+28     	; 0x1738 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    171c:	c0 91 9b 01 	lds	r28, 0x019B
    1720:	d0 91 9c 01 	lds	r29, 0x019C
    1724:	c4 0f       	add	r28, r20
    1726:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
    1728:	30 93 9e 01 	sts	0x019E, r19
    172c:	20 93 9d 01 	sts	0x019D, r18
    1730:	05 c0       	rjmp	.+10     	; 0x173c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1732:	c0 e0       	ldi	r28, 0x00	; 0
    1734:	d0 e0       	ldi	r29, 0x00	; 0
    1736:	02 c0       	rjmp	.+4      	; 0x173c <pvPortMalloc+0x5e>
    1738:	c0 e0       	ldi	r28, 0x00	; 0
    173a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    173c:	0e 94 d6 10 	call	0x21ac	; 0x21ac <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1740:	ce 01       	movw	r24, r28
    1742:	df 91       	pop	r29
    1744:	cf 91       	pop	r28
    1746:	08 95       	ret

00001748 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1748:	08 95       	ret

0000174a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    174a:	1f 93       	push	r17
    174c:	cf 93       	push	r28
    174e:	df 93       	push	r29
    1750:	ec 01       	movw	r28, r24
    1752:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1754:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1756:	88 23       	and	r24, r24
    1758:	e9 f1       	breq	.+122    	; 0x17d4 <prvCopyDataToQueue+0x8a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    175a:	41 11       	cpse	r20, r1
    175c:	17 c0       	rjmp	.+46     	; 0x178c <prvCopyDataToQueue+0x42>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    175e:	48 2f       	mov	r20, r24
    1760:	50 e0       	ldi	r21, 0x00	; 0
    1762:	8c 81       	ldd	r24, Y+4	; 0x04
    1764:	9d 81       	ldd	r25, Y+5	; 0x05
    1766:	0e 94 2a 13 	call	0x2654	; 0x2654 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    176a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    176c:	8c 81       	ldd	r24, Y+4	; 0x04
    176e:	9d 81       	ldd	r25, Y+5	; 0x05
    1770:	82 0f       	add	r24, r18
    1772:	91 1d       	adc	r25, r1
    1774:	9d 83       	std	Y+5, r25	; 0x05
    1776:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1778:	2a 81       	ldd	r18, Y+2	; 0x02
    177a:	3b 81       	ldd	r19, Y+3	; 0x03
    177c:	82 17       	cp	r24, r18
    177e:	93 07       	cpc	r25, r19
    1780:	48 f1       	brcs	.+82     	; 0x17d4 <prvCopyDataToQueue+0x8a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1782:	88 81       	ld	r24, Y
    1784:	99 81       	ldd	r25, Y+1	; 0x01
    1786:	9d 83       	std	Y+5, r25	; 0x05
    1788:	8c 83       	std	Y+4, r24	; 0x04
    178a:	24 c0       	rjmp	.+72     	; 0x17d4 <prvCopyDataToQueue+0x8a>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    178c:	48 2f       	mov	r20, r24
    178e:	50 e0       	ldi	r21, 0x00	; 0
    1790:	8e 81       	ldd	r24, Y+6	; 0x06
    1792:	9f 81       	ldd	r25, Y+7	; 0x07
    1794:	0e 94 2a 13 	call	0x2654	; 0x2654 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1798:	2c 8d       	ldd	r18, Y+28	; 0x1c
    179a:	30 e0       	ldi	r19, 0x00	; 0
    179c:	31 95       	neg	r19
    179e:	21 95       	neg	r18
    17a0:	31 09       	sbc	r19, r1
    17a2:	8e 81       	ldd	r24, Y+6	; 0x06
    17a4:	9f 81       	ldd	r25, Y+7	; 0x07
    17a6:	82 0f       	add	r24, r18
    17a8:	93 1f       	adc	r25, r19
    17aa:	9f 83       	std	Y+7, r25	; 0x07
    17ac:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    17ae:	68 81       	ld	r22, Y
    17b0:	79 81       	ldd	r23, Y+1	; 0x01
    17b2:	86 17       	cp	r24, r22
    17b4:	97 07       	cpc	r25, r23
    17b6:	30 f4       	brcc	.+12     	; 0x17c4 <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    17b8:	8a 81       	ldd	r24, Y+2	; 0x02
    17ba:	9b 81       	ldd	r25, Y+3	; 0x03
    17bc:	28 0f       	add	r18, r24
    17be:	39 1f       	adc	r19, r25
    17c0:	3f 83       	std	Y+7, r19	; 0x07
    17c2:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    17c4:	12 30       	cpi	r17, 0x02	; 2
    17c6:	31 f4       	brne	.+12     	; 0x17d4 <prvCopyDataToQueue+0x8a>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    17c8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17ca:	88 23       	and	r24, r24
    17cc:	19 f0       	breq	.+6      	; 0x17d4 <prvCopyDataToQueue+0x8a>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    17ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17d0:	81 50       	subi	r24, 0x01	; 1
    17d2:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    17d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17d6:	8f 5f       	subi	r24, 0xFF	; 255
    17d8:	8a 8f       	std	Y+26, r24	; 0x1a

	return xReturn;
}
    17da:	80 e0       	ldi	r24, 0x00	; 0
    17dc:	df 91       	pop	r29
    17de:	cf 91       	pop	r28
    17e0:	1f 91       	pop	r17
    17e2:	08 95       	ret

000017e4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    17e4:	fc 01       	movw	r30, r24
    17e6:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    17e8:	44 8d       	ldd	r20, Z+28	; 0x1c
    17ea:	44 23       	and	r20, r20
    17ec:	a1 f0       	breq	.+40     	; 0x1816 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    17ee:	50 e0       	ldi	r21, 0x00	; 0
    17f0:	26 81       	ldd	r18, Z+6	; 0x06
    17f2:	37 81       	ldd	r19, Z+7	; 0x07
    17f4:	24 0f       	add	r18, r20
    17f6:	35 1f       	adc	r19, r21
    17f8:	37 83       	std	Z+7, r19	; 0x07
    17fa:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    17fc:	62 81       	ldd	r22, Z+2	; 0x02
    17fe:	73 81       	ldd	r23, Z+3	; 0x03
    1800:	26 17       	cp	r18, r22
    1802:	37 07       	cpc	r19, r23
    1804:	20 f0       	brcs	.+8      	; 0x180e <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1806:	20 81       	ld	r18, Z
    1808:	31 81       	ldd	r19, Z+1	; 0x01
    180a:	37 83       	std	Z+7, r19	; 0x07
    180c:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    180e:	66 81       	ldd	r22, Z+6	; 0x06
    1810:	77 81       	ldd	r23, Z+7	; 0x07
    1812:	0e 94 2a 13 	call	0x2654	; 0x2654 <memcpy>
    1816:	08 95       	ret

00001818 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1818:	0f 93       	push	r16
    181a:	1f 93       	push	r17
    181c:	cf 93       	push	r28
    181e:	df 93       	push	r29
    1820:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	f8 94       	cli
    1826:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1828:	8e 8d       	ldd	r24, Y+30	; 0x1e
    182a:	18 16       	cp	r1, r24
    182c:	b4 f4       	brge	.+44     	; 0x185a <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    182e:	89 89       	ldd	r24, Y+17	; 0x11
    1830:	88 23       	and	r24, r24
    1832:	99 f0       	breq	.+38     	; 0x185a <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1834:	8e 01       	movw	r16, r28
    1836:	0f 5e       	subi	r16, 0xEF	; 239
    1838:	1f 4f       	sbci	r17, 0xFF	; 255
    183a:	03 c0       	rjmp	.+6      	; 0x1842 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    183c:	89 89       	ldd	r24, Y+17	; 0x11
    183e:	88 23       	and	r24, r24
    1840:	61 f0       	breq	.+24     	; 0x185a <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1842:	c8 01       	movw	r24, r16
    1844:	0e 94 94 12 	call	0x2528	; 0x2528 <xTaskRemoveFromEventList>
    1848:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    184a:	0e 94 20 13 	call	0x2640	; 0x2640 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    184e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1850:	81 50       	subi	r24, 0x01	; 1
    1852:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1854:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1856:	18 16       	cp	r1, r24
    1858:	8c f3       	brlt	.-30     	; 0x183c <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    185a:	8f ef       	ldi	r24, 0xFF	; 255
    185c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    185e:	0f 90       	pop	r0
    1860:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1862:	0f b6       	in	r0, 0x3f	; 63
    1864:	f8 94       	cli
    1866:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1868:	8d 8d       	ldd	r24, Y+29	; 0x1d
    186a:	18 16       	cp	r1, r24
    186c:	b4 f4       	brge	.+44     	; 0x189a <prvUnlockQueue+0x82>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    186e:	88 85       	ldd	r24, Y+8	; 0x08
    1870:	88 23       	and	r24, r24
    1872:	99 f0       	breq	.+38     	; 0x189a <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1874:	8e 01       	movw	r16, r28
    1876:	08 5f       	subi	r16, 0xF8	; 248
    1878:	1f 4f       	sbci	r17, 0xFF	; 255
    187a:	03 c0       	rjmp	.+6      	; 0x1882 <prvUnlockQueue+0x6a>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    187c:	88 85       	ldd	r24, Y+8	; 0x08
    187e:	88 23       	and	r24, r24
    1880:	61 f0       	breq	.+24     	; 0x189a <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1882:	c8 01       	movw	r24, r16
    1884:	0e 94 94 12 	call	0x2528	; 0x2528 <xTaskRemoveFromEventList>
    1888:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    188a:	0e 94 20 13 	call	0x2640	; 0x2640 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    188e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1890:	81 50       	subi	r24, 0x01	; 1
    1892:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1894:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1896:	18 16       	cp	r1, r24
    1898:	8c f3       	brlt	.-30     	; 0x187c <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    189a:	8f ef       	ldi	r24, 0xFF	; 255
    189c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    189e:	0f 90       	pop	r0
    18a0:	0f be       	out	0x3f, r0	; 63
}
    18a2:	df 91       	pop	r29
    18a4:	cf 91       	pop	r28
    18a6:	1f 91       	pop	r17
    18a8:	0f 91       	pop	r16
    18aa:	08 95       	ret

000018ac <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    18ac:	cf 93       	push	r28
    18ae:	df 93       	push	r29
    18b0:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    18b2:	0f b6       	in	r0, 0x3f	; 63
    18b4:	f8 94       	cli
    18b6:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    18b8:	88 81       	ld	r24, Y
    18ba:	99 81       	ldd	r25, Y+1	; 0x01
    18bc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    18be:	30 e0       	ldi	r19, 0x00	; 0
    18c0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    18c2:	72 9f       	mul	r23, r18
    18c4:	a0 01       	movw	r20, r0
    18c6:	73 9f       	mul	r23, r19
    18c8:	50 0d       	add	r21, r0
    18ca:	11 24       	eor	r1, r1
    18cc:	fc 01       	movw	r30, r24
    18ce:	e4 0f       	add	r30, r20
    18d0:	f5 1f       	adc	r31, r21
    18d2:	fb 83       	std	Y+3, r31	; 0x03
    18d4:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    18d6:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    18d8:	9d 83       	std	Y+5, r25	; 0x05
    18da:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    18dc:	42 1b       	sub	r20, r18
    18de:	53 0b       	sbc	r21, r19
    18e0:	84 0f       	add	r24, r20
    18e2:	95 1f       	adc	r25, r21
    18e4:	9f 83       	std	Y+7, r25	; 0x07
    18e6:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    18e8:	8f ef       	ldi	r24, 0xFF	; 255
    18ea:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    18ec:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    18ee:	61 11       	cpse	r22, r1
    18f0:	0c c0       	rjmp	.+24     	; 0x190a <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18f2:	88 85       	ldd	r24, Y+8	; 0x08
    18f4:	88 23       	and	r24, r24
    18f6:	89 f0       	breq	.+34     	; 0x191a <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    18f8:	ce 01       	movw	r24, r28
    18fa:	08 96       	adiw	r24, 0x08	; 8
    18fc:	0e 94 94 12 	call	0x2528	; 0x2528 <xTaskRemoveFromEventList>
    1900:	81 30       	cpi	r24, 0x01	; 1
    1902:	59 f4       	brne	.+22     	; 0x191a <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1904:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
    1908:	08 c0       	rjmp	.+16     	; 0x191a <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    190a:	ce 01       	movw	r24, r28
    190c:	08 96       	adiw	r24, 0x08	; 8
    190e:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1912:	ce 01       	movw	r24, r28
    1914:	41 96       	adiw	r24, 0x11	; 17
    1916:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    191a:	0f 90       	pop	r0
    191c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    191e:	81 e0       	ldi	r24, 0x01	; 1
    1920:	df 91       	pop	r29
    1922:	cf 91       	pop	r28
    1924:	08 95       	ret

00001926 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1926:	0f 93       	push	r16
    1928:	1f 93       	push	r17
    192a:	cf 93       	push	r28
    192c:	df 93       	push	r29
    192e:	08 2f       	mov	r16, r24
    1930:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    1932:	66 23       	and	r22, r22
    1934:	c9 f0       	breq	.+50     	; 0x1968 <xQueueGenericCreate+0x42>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1936:	86 9f       	mul	r24, r22
    1938:	c0 01       	movw	r24, r0
    193a:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    193c:	80 96       	adiw	r24, 0x20	; 32
    193e:	0e 94 6f 0b 	call	0x16de	; 0x16de <pvPortMalloc>
    1942:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
    1944:	00 97       	sbiw	r24, 0x00	; 0
    1946:	21 f4       	brne	.+8      	; 0x1950 <xQueueGenericCreate+0x2a>
    1948:	16 c0       	rjmp	.+44     	; 0x1976 <xQueueGenericCreate+0x50>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    194a:	d9 83       	std	Y+1, r29	; 0x01
    194c:	c8 83       	st	Y, r28
    194e:	05 c0       	rjmp	.+10     	; 0x195a <xQueueGenericCreate+0x34>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    1950:	9c 01       	movw	r18, r24
    1952:	21 5e       	subi	r18, 0xE1	; 225
    1954:	3f 4f       	sbci	r19, 0xFF	; 255
    1956:	39 83       	std	Y+1, r19	; 0x01
    1958:	28 83       	st	Y, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    195a:	0b 8f       	std	Y+27, r16	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    195c:	1c 8f       	std	Y+28, r17	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    195e:	61 e0       	ldi	r22, 0x01	; 1
    1960:	ce 01       	movw	r24, r28
    1962:	0e 94 56 0c 	call	0x18ac	; 0x18ac <xQueueGenericReset>
    1966:	07 c0       	rjmp	.+14     	; 0x1976 <xQueueGenericCreate+0x50>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1968:	8f e1       	ldi	r24, 0x1F	; 31
    196a:	90 e0       	ldi	r25, 0x00	; 0
    196c:	0e 94 6f 0b 	call	0x16de	; 0x16de <pvPortMalloc>
    1970:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
    1972:	00 97       	sbiw	r24, 0x00	; 0
    1974:	51 f7       	brne	.-44     	; 0x194a <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
    1976:	ce 01       	movw	r24, r28
    1978:	df 91       	pop	r29
    197a:	cf 91       	pop	r28
    197c:	1f 91       	pop	r17
    197e:	0f 91       	pop	r16
    1980:	08 95       	ret

00001982 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1982:	9f 92       	push	r9
    1984:	af 92       	push	r10
    1986:	bf 92       	push	r11
    1988:	cf 92       	push	r12
    198a:	df 92       	push	r13
    198c:	ef 92       	push	r14
    198e:	ff 92       	push	r15
    1990:	0f 93       	push	r16
    1992:	1f 93       	push	r17
    1994:	cf 93       	push	r28
    1996:	df 93       	push	r29
    1998:	00 d0       	rcall	.+0      	; 0x199a <xQueueGenericSend+0x18>
    199a:	00 d0       	rcall	.+0      	; 0x199c <xQueueGenericSend+0x1a>
    199c:	1f 92       	push	r1
    199e:	cd b7       	in	r28, 0x3d	; 61
    19a0:	de b7       	in	r29, 0x3e	; 62
    19a2:	8c 01       	movw	r16, r24
    19a4:	6b 01       	movw	r12, r22
    19a6:	5d 83       	std	Y+5, r21	; 0x05
    19a8:	4c 83       	std	Y+4, r20	; 0x04
    19aa:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    19ac:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    19ae:	99 24       	eor	r9, r9
    19b0:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    19b2:	7c 01       	movw	r14, r24
    19b4:	88 e0       	ldi	r24, 0x08	; 8
    19b6:	e8 0e       	add	r14, r24
    19b8:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	f8 94       	cli
    19be:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19c0:	f8 01       	movw	r30, r16
    19c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    19c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    19c6:	98 17       	cp	r25, r24
    19c8:	18 f0       	brcs	.+6      	; 0x19d0 <xQueueGenericSend+0x4e>
    19ca:	f2 e0       	ldi	r31, 0x02	; 2
    19cc:	af 12       	cpse	r10, r31
    19ce:	19 c0       	rjmp	.+50     	; 0x1a02 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19d0:	4a 2d       	mov	r20, r10
    19d2:	b6 01       	movw	r22, r12
    19d4:	c8 01       	movw	r24, r16
    19d6:	0e 94 a5 0b 	call	0x174a	; 0x174a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19da:	f8 01       	movw	r30, r16
    19dc:	91 89       	ldd	r25, Z+17	; 0x11
    19de:	99 23       	and	r25, r25
    19e0:	49 f0       	breq	.+18     	; 0x19f4 <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    19e2:	c8 01       	movw	r24, r16
    19e4:	41 96       	adiw	r24, 0x11	; 17
    19e6:	0e 94 94 12 	call	0x2528	; 0x2528 <xTaskRemoveFromEventList>
    19ea:	81 30       	cpi	r24, 0x01	; 1
    19ec:	31 f4       	brne	.+12     	; 0x19fa <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    19ee:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
    19f2:	03 c0       	rjmp	.+6      	; 0x19fa <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    19f4:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    19f6:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    19fa:	0f 90       	pop	r0
    19fc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	51 c0       	rjmp	.+162    	; 0x1aa4 <xQueueGenericSend+0x122>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a02:	ec 81       	ldd	r30, Y+4	; 0x04
    1a04:	fd 81       	ldd	r31, Y+5	; 0x05
    1a06:	ef 2b       	or	r30, r31
    1a08:	21 f4       	brne	.+8      	; 0x1a12 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a0a:	0f 90       	pop	r0
    1a0c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1a0e:	80 e0       	ldi	r24, 0x00	; 0
    1a10:	49 c0       	rjmp	.+146    	; 0x1aa4 <xQueueGenericSend+0x122>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a12:	b1 10       	cpse	r11, r1
    1a14:	05 c0       	rjmp	.+10     	; 0x1a20 <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a16:	ce 01       	movw	r24, r28
    1a18:	01 96       	adiw	r24, 0x01	; 1
    1a1a:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a1e:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a20:	0f 90       	pop	r0
    1a22:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a24:	0e 94 07 10 	call	0x200e	; 0x200e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a28:	0f b6       	in	r0, 0x3f	; 63
    1a2a:	f8 94       	cli
    1a2c:	0f 92       	push	r0
    1a2e:	f8 01       	movw	r30, r16
    1a30:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a32:	8f 3f       	cpi	r24, 0xFF	; 255
    1a34:	09 f4       	brne	.+2      	; 0x1a38 <xQueueGenericSend+0xb6>
    1a36:	15 8e       	std	Z+29, r1	; 0x1d
    1a38:	f8 01       	movw	r30, r16
    1a3a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a3e:	09 f4       	brne	.+2      	; 0x1a42 <xQueueGenericSend+0xc0>
    1a40:	16 8e       	std	Z+30, r1	; 0x1e
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a46:	be 01       	movw	r22, r28
    1a48:	6c 5f       	subi	r22, 0xFC	; 252
    1a4a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a4c:	ce 01       	movw	r24, r28
    1a4e:	01 96       	adiw	r24, 0x01	; 1
    1a50:	0e 94 e7 12 	call	0x25ce	; 0x25ce <xTaskCheckForTimeOut>
    1a54:	81 11       	cpse	r24, r1
    1a56:	20 c0       	rjmp	.+64     	; 0x1a98 <xQueueGenericSend+0x116>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1a58:	0f b6       	in	r0, 0x3f	; 63
    1a5a:	f8 94       	cli
    1a5c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a5e:	f8 01       	movw	r30, r16
    1a60:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a66:	f8 01       	movw	r30, r16
    1a68:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a6a:	98 13       	cpse	r25, r24
    1a6c:	0f c0       	rjmp	.+30     	; 0x1a8c <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a6e:	6c 81       	ldd	r22, Y+4	; 0x04
    1a70:	7d 81       	ldd	r23, Y+5	; 0x05
    1a72:	c7 01       	movw	r24, r14
    1a74:	0e 94 68 12 	call	0x24d0	; 0x24d0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1a78:	c8 01       	movw	r24, r16
    1a7a:	0e 94 0c 0c 	call	0x1818	; 0x1818 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1a7e:	0e 94 d6 10 	call	0x21ac	; 0x21ac <xTaskResumeAll>
    1a82:	81 11       	cpse	r24, r1
    1a84:	9a cf       	rjmp	.-204    	; 0x19ba <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1a86:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
    1a8a:	97 cf       	rjmp	.-210    	; 0x19ba <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1a8c:	c8 01       	movw	r24, r16
    1a8e:	0e 94 0c 0c 	call	0x1818	; 0x1818 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a92:	0e 94 d6 10 	call	0x21ac	; 0x21ac <xTaskResumeAll>
    1a96:	91 cf       	rjmp	.-222    	; 0x19ba <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1a98:	c8 01       	movw	r24, r16
    1a9a:	0e 94 0c 0c 	call	0x1818	; 0x1818 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1a9e:	0e 94 d6 10 	call	0x21ac	; 0x21ac <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1aa2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1aa4:	0f 90       	pop	r0
    1aa6:	0f 90       	pop	r0
    1aa8:	0f 90       	pop	r0
    1aaa:	0f 90       	pop	r0
    1aac:	0f 90       	pop	r0
    1aae:	df 91       	pop	r29
    1ab0:	cf 91       	pop	r28
    1ab2:	1f 91       	pop	r17
    1ab4:	0f 91       	pop	r16
    1ab6:	ff 90       	pop	r15
    1ab8:	ef 90       	pop	r14
    1aba:	df 90       	pop	r13
    1abc:	cf 90       	pop	r12
    1abe:	bf 90       	pop	r11
    1ac0:	af 90       	pop	r10
    1ac2:	9f 90       	pop	r9
    1ac4:	08 95       	ret

00001ac6 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1ac6:	cf 93       	push	r28
    1ac8:	df 93       	push	r29
    1aca:	fc 01       	movw	r30, r24
    1acc:	eb 01       	movw	r28, r22
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ace:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ad0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ad2:	98 17       	cp	r25, r24
    1ad4:	c8 f4       	brcc	.+50     	; 0x1b08 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    1ad6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ad8:	8f 5f       	subi	r24, 0xFF	; 255
    1ada:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1adc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ade:	8f 3f       	cpi	r24, 0xFF	; 255
    1ae0:	71 f4       	brne	.+28     	; 0x1afe <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ae2:	81 89       	ldd	r24, Z+17	; 0x11
    1ae4:	88 23       	and	r24, r24
    1ae6:	91 f0       	breq	.+36     	; 0x1b0c <xQueueGiveFromISR+0x46>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ae8:	cf 01       	movw	r24, r30
    1aea:	41 96       	adiw	r24, 0x11	; 17
    1aec:	0e 94 94 12 	call	0x2528	; 0x2528 <xTaskRemoveFromEventList>
    1af0:	88 23       	and	r24, r24
    1af2:	71 f0       	breq	.+28     	; 0x1b10 <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1af4:	20 97       	sbiw	r28, 0x00	; 0
    1af6:	71 f0       	breq	.+28     	; 0x1b14 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1af8:	81 e0       	ldi	r24, 0x01	; 1
    1afa:	88 83       	st	Y, r24
    1afc:	0c c0       	rjmp	.+24     	; 0x1b16 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1afe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b00:	8f 5f       	subi	r24, 0xFF	; 255
    1b02:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1b04:	81 e0       	ldi	r24, 0x01	; 1
    1b06:	07 c0       	rjmp	.+14     	; 0x1b16 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b08:	80 e0       	ldi	r24, 0x00	; 0
    1b0a:	05 c0       	rjmp	.+10     	; 0x1b16 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1b0c:	81 e0       	ldi	r24, 0x01	; 1
    1b0e:	03 c0       	rjmp	.+6      	; 0x1b16 <xQueueGiveFromISR+0x50>
    1b10:	81 e0       	ldi	r24, 0x01	; 1
    1b12:	01 c0       	rjmp	.+2      	; 0x1b16 <xQueueGiveFromISR+0x50>
    1b14:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b16:	df 91       	pop	r29
    1b18:	cf 91       	pop	r28
    1b1a:	08 95       	ret

00001b1c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1b1c:	9f 92       	push	r9
    1b1e:	af 92       	push	r10
    1b20:	bf 92       	push	r11
    1b22:	cf 92       	push	r12
    1b24:	df 92       	push	r13
    1b26:	ef 92       	push	r14
    1b28:	ff 92       	push	r15
    1b2a:	0f 93       	push	r16
    1b2c:	1f 93       	push	r17
    1b2e:	cf 93       	push	r28
    1b30:	df 93       	push	r29
    1b32:	00 d0       	rcall	.+0      	; 0x1b34 <xQueueGenericReceive+0x18>
    1b34:	00 d0       	rcall	.+0      	; 0x1b36 <xQueueGenericReceive+0x1a>
    1b36:	1f 92       	push	r1
    1b38:	cd b7       	in	r28, 0x3d	; 61
    1b3a:	de b7       	in	r29, 0x3e	; 62
    1b3c:	8c 01       	movw	r16, r24
    1b3e:	6b 01       	movw	r12, r22
    1b40:	5d 83       	std	Y+5, r21	; 0x05
    1b42:	4c 83       	std	Y+4, r20	; 0x04
    1b44:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1b46:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1b48:	99 24       	eor	r9, r9
    1b4a:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b4c:	7c 01       	movw	r14, r24
    1b4e:	81 e1       	ldi	r24, 0x11	; 17
    1b50:	e8 0e       	add	r14, r24
    1b52:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1b54:	0f b6       	in	r0, 0x3f	; 63
    1b56:	f8 94       	cli
    1b58:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b5a:	f8 01       	movw	r30, r16
    1b5c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b5e:	88 23       	and	r24, r24
    1b60:	49 f1       	breq	.+82     	; 0x1bb4 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1b62:	e6 80       	ldd	r14, Z+6	; 0x06
    1b64:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b66:	b6 01       	movw	r22, r12
    1b68:	c8 01       	movw	r24, r16
    1b6a:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1b6e:	b1 10       	cpse	r11, r1
    1b70:	10 c0       	rjmp	.+32     	; 0x1b92 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1b72:	f8 01       	movw	r30, r16
    1b74:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b76:	81 50       	subi	r24, 0x01	; 1
    1b78:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b7a:	80 85       	ldd	r24, Z+8	; 0x08
    1b7c:	88 23       	and	r24, r24
    1b7e:	b1 f0       	breq	.+44     	; 0x1bac <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1b80:	c8 01       	movw	r24, r16
    1b82:	08 96       	adiw	r24, 0x08	; 8
    1b84:	0e 94 94 12 	call	0x2528	; 0x2528 <xTaskRemoveFromEventList>
    1b88:	81 30       	cpi	r24, 0x01	; 1
    1b8a:	81 f4       	brne	.+32     	; 0x1bac <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1b8c:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
    1b90:	0d c0       	rjmp	.+26     	; 0x1bac <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1b92:	f8 01       	movw	r30, r16
    1b94:	f7 82       	std	Z+7, r15	; 0x07
    1b96:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b98:	81 89       	ldd	r24, Z+17	; 0x11
    1b9a:	88 23       	and	r24, r24
    1b9c:	39 f0       	breq	.+14     	; 0x1bac <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b9e:	c8 01       	movw	r24, r16
    1ba0:	41 96       	adiw	r24, 0x11	; 17
    1ba2:	0e 94 94 12 	call	0x2528	; 0x2528 <xTaskRemoveFromEventList>
    1ba6:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1ba8:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1bac:	0f 90       	pop	r0
    1bae:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1bb0:	81 e0       	ldi	r24, 0x01	; 1
    1bb2:	4f c0       	rjmp	.+158    	; 0x1c52 <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1bb4:	4c 81       	ldd	r20, Y+4	; 0x04
    1bb6:	5d 81       	ldd	r21, Y+5	; 0x05
    1bb8:	45 2b       	or	r20, r21
    1bba:	21 f4       	brne	.+8      	; 0x1bc4 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1bbc:	0f 90       	pop	r0
    1bbe:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1bc0:	80 e0       	ldi	r24, 0x00	; 0
    1bc2:	47 c0       	rjmp	.+142    	; 0x1c52 <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1bc4:	a1 10       	cpse	r10, r1
    1bc6:	05 c0       	rjmp	.+10     	; 0x1bd2 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1bc8:	ce 01       	movw	r24, r28
    1bca:	01 96       	adiw	r24, 0x01	; 1
    1bcc:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1bd0:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1bd2:	0f 90       	pop	r0
    1bd4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1bd6:	0e 94 07 10 	call	0x200e	; 0x200e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	0f 92       	push	r0
    1be0:	f8 01       	movw	r30, r16
    1be2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1be4:	8f 3f       	cpi	r24, 0xFF	; 255
    1be6:	09 f4       	brne	.+2      	; 0x1bea <xQueueGenericReceive+0xce>
    1be8:	15 8e       	std	Z+29, r1	; 0x1d
    1bea:	f8 01       	movw	r30, r16
    1bec:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bee:	8f 3f       	cpi	r24, 0xFF	; 255
    1bf0:	09 f4       	brne	.+2      	; 0x1bf4 <xQueueGenericReceive+0xd8>
    1bf2:	16 8e       	std	Z+30, r1	; 0x1e
    1bf4:	0f 90       	pop	r0
    1bf6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1bf8:	be 01       	movw	r22, r28
    1bfa:	6c 5f       	subi	r22, 0xFC	; 252
    1bfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bfe:	ce 01       	movw	r24, r28
    1c00:	01 96       	adiw	r24, 0x01	; 1
    1c02:	0e 94 e7 12 	call	0x25ce	; 0x25ce <xTaskCheckForTimeOut>
    1c06:	81 11       	cpse	r24, r1
    1c08:	1e c0       	rjmp	.+60     	; 0x1c46 <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1c0a:	0f b6       	in	r0, 0x3f	; 63
    1c0c:	f8 94       	cli
    1c0e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1c10:	f8 01       	movw	r30, r16
    1c12:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1c14:	0f 90       	pop	r0
    1c16:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c18:	81 11       	cpse	r24, r1
    1c1a:	0f c0       	rjmp	.+30     	; 0x1c3a <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c1c:	6c 81       	ldd	r22, Y+4	; 0x04
    1c1e:	7d 81       	ldd	r23, Y+5	; 0x05
    1c20:	c7 01       	movw	r24, r14
    1c22:	0e 94 68 12 	call	0x24d0	; 0x24d0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c26:	c8 01       	movw	r24, r16
    1c28:	0e 94 0c 0c 	call	0x1818	; 0x1818 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c2c:	0e 94 d6 10 	call	0x21ac	; 0x21ac <xTaskResumeAll>
    1c30:	81 11       	cpse	r24, r1
    1c32:	90 cf       	rjmp	.-224    	; 0x1b54 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1c34:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
    1c38:	8d cf       	rjmp	.-230    	; 0x1b54 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c3a:	c8 01       	movw	r24, r16
    1c3c:	0e 94 0c 0c 	call	0x1818	; 0x1818 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c40:	0e 94 d6 10 	call	0x21ac	; 0x21ac <xTaskResumeAll>
    1c44:	87 cf       	rjmp	.-242    	; 0x1b54 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1c46:	c8 01       	movw	r24, r16
    1c48:	0e 94 0c 0c 	call	0x1818	; 0x1818 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c4c:	0e 94 d6 10 	call	0x21ac	; 0x21ac <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1c50:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1c52:	0f 90       	pop	r0
    1c54:	0f 90       	pop	r0
    1c56:	0f 90       	pop	r0
    1c58:	0f 90       	pop	r0
    1c5a:	0f 90       	pop	r0
    1c5c:	df 91       	pop	r29
    1c5e:	cf 91       	pop	r28
    1c60:	1f 91       	pop	r17
    1c62:	0f 91       	pop	r16
    1c64:	ff 90       	pop	r15
    1c66:	ef 90       	pop	r14
    1c68:	df 90       	pop	r13
    1c6a:	cf 90       	pop	r12
    1c6c:	bf 90       	pop	r11
    1c6e:	af 90       	pop	r10
    1c70:	9f 90       	pop	r9
    1c72:	08 95       	ret

00001c74 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1c74:	0f 93       	push	r16
    1c76:	1f 93       	push	r17
    1c78:	cf 93       	push	r28
    1c7a:	df 93       	push	r29
    1c7c:	ec 01       	movw	r28, r24
    1c7e:	8a 01       	movw	r16, r20
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c80:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c82:	88 23       	and	r24, r24
    1c84:	f1 f0       	breq	.+60     	; 0x1cc2 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c86:	ce 01       	movw	r24, r28
    1c88:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1c8c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c8e:	81 50       	subi	r24, 0x01	; 1
    1c90:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1c92:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c94:	8f 3f       	cpi	r24, 0xFF	; 255
    1c96:	81 f4       	brne	.+32     	; 0x1cb8 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c98:	88 85       	ldd	r24, Y+8	; 0x08
    1c9a:	88 23       	and	r24, r24
    1c9c:	a1 f0       	breq	.+40     	; 0x1cc6 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c9e:	ce 01       	movw	r24, r28
    1ca0:	08 96       	adiw	r24, 0x08	; 8
    1ca2:	0e 94 94 12 	call	0x2528	; 0x2528 <xTaskRemoveFromEventList>
    1ca6:	88 23       	and	r24, r24
    1ca8:	81 f0       	breq	.+32     	; 0x1cca <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1caa:	01 15       	cp	r16, r1
    1cac:	11 05       	cpc	r17, r1
    1cae:	79 f0       	breq	.+30     	; 0x1cce <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1cb0:	81 e0       	ldi	r24, 0x01	; 1
    1cb2:	f8 01       	movw	r30, r16
    1cb4:	80 83       	st	Z, r24
    1cb6:	0c c0       	rjmp	.+24     	; 0x1cd0 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1cb8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1cba:	8f 5f       	subi	r24, 0xFF	; 255
    1cbc:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	07 c0       	rjmp	.+14     	; 0x1cd0 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1cc2:	80 e0       	ldi	r24, 0x00	; 0
    1cc4:	05 c0       	rjmp	.+10     	; 0x1cd0 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1cc6:	81 e0       	ldi	r24, 0x01	; 1
    1cc8:	03 c0       	rjmp	.+6      	; 0x1cd0 <xQueueReceiveFromISR+0x5c>
    1cca:	81 e0       	ldi	r24, 0x01	; 1
    1ccc:	01 c0       	rjmp	.+2      	; 0x1cd0 <xQueueReceiveFromISR+0x5c>
    1cce:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1cd0:	df 91       	pop	r29
    1cd2:	cf 91       	pop	r28
    1cd4:	1f 91       	pop	r17
    1cd6:	0f 91       	pop	r16
    1cd8:	08 95       	ret

00001cda <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1cda:	e0 91 9b 07 	lds	r30, 0x079B
    1cde:	f0 91 9c 07 	lds	r31, 0x079C
    1ce2:	80 81       	ld	r24, Z
    1ce4:	81 11       	cpse	r24, r1
    1ce6:	07 c0       	rjmp	.+14     	; 0x1cf6 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1ce8:	8f ef       	ldi	r24, 0xFF	; 255
    1cea:	9f ef       	ldi	r25, 0xFF	; 255
    1cec:	90 93 7d 07 	sts	0x077D, r25
    1cf0:	80 93 7c 07 	sts	0x077C, r24
    1cf4:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1cf6:	e0 91 9b 07 	lds	r30, 0x079B
    1cfa:	f0 91 9c 07 	lds	r31, 0x079C
    1cfe:	05 80       	ldd	r0, Z+5	; 0x05
    1d00:	f6 81       	ldd	r31, Z+6	; 0x06
    1d02:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    1d04:	06 80       	ldd	r0, Z+6	; 0x06
    1d06:	f7 81       	ldd	r31, Z+7	; 0x07
    1d08:	e0 2d       	mov	r30, r0
    1d0a:	82 81       	ldd	r24, Z+2	; 0x02
    1d0c:	93 81       	ldd	r25, Z+3	; 0x03
    1d0e:	90 93 7d 07 	sts	0x077D, r25
    1d12:	80 93 7c 07 	sts	0x077C, r24
    1d16:	08 95       	ret

00001d18 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1d18:	cf ea       	ldi	r28, 0xAF	; 175
    1d1a:	d7 e0       	ldi	r29, 0x07	; 7
    1d1c:	88 81       	ld	r24, Y
    1d1e:	82 30       	cpi	r24, 0x02	; 2
    1d20:	08 f4       	brcc	.+2      	; 0x1d24 <prvIdleTask+0xc>
    1d22:	ff cf       	rjmp	.-2      	; 0x1d22 <prvIdleTask+0xa>
			{
				taskYIELD();
    1d24:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
    1d28:	f9 cf       	rjmp	.-14     	; 0x1d1c <prvIdleTask+0x4>

00001d2a <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    1d2a:	cf 93       	push	r28
    1d2c:	df 93       	push	r29
    1d2e:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1d30:	e0 91 d3 07 	lds	r30, 0x07D3
    1d34:	f0 91 d4 07 	lds	r31, 0x07D4
    1d38:	93 83       	std	Z+3, r25	; 0x03
    1d3a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1d3c:	80 91 84 07 	lds	r24, 0x0784
    1d40:	90 91 85 07 	lds	r25, 0x0785
    1d44:	c8 17       	cp	r28, r24
    1d46:	d9 07       	cpc	r29, r25
    1d48:	68 f4       	brcc	.+26     	; 0x1d64 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1d4a:	60 91 d3 07 	lds	r22, 0x07D3
    1d4e:	70 91 d4 07 	lds	r23, 0x07D4
    1d52:	80 91 99 07 	lds	r24, 0x0799
    1d56:	90 91 9a 07 	lds	r25, 0x079A
    1d5a:	6e 5f       	subi	r22, 0xFE	; 254
    1d5c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d5e:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsert>
    1d62:	17 c0       	rjmp	.+46     	; 0x1d92 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1d64:	60 91 d3 07 	lds	r22, 0x07D3
    1d68:	70 91 d4 07 	lds	r23, 0x07D4
    1d6c:	80 91 9b 07 	lds	r24, 0x079B
    1d70:	90 91 9c 07 	lds	r25, 0x079C
    1d74:	6e 5f       	subi	r22, 0xFE	; 254
    1d76:	7f 4f       	sbci	r23, 0xFF	; 255
    1d78:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1d7c:	80 91 7c 07 	lds	r24, 0x077C
    1d80:	90 91 7d 07 	lds	r25, 0x077D
    1d84:	c8 17       	cp	r28, r24
    1d86:	d9 07       	cpc	r29, r25
    1d88:	20 f4       	brcc	.+8      	; 0x1d92 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1d8a:	d0 93 7d 07 	sts	0x077D, r29
    1d8e:	c0 93 7c 07 	sts	0x077C, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1d92:	df 91       	pop	r29
    1d94:	cf 91       	pop	r28
    1d96:	08 95       	ret

00001d98 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    1d98:	4f 92       	push	r4
    1d9a:	5f 92       	push	r5
    1d9c:	6f 92       	push	r6
    1d9e:	7f 92       	push	r7
    1da0:	8f 92       	push	r8
    1da2:	9f 92       	push	r9
    1da4:	af 92       	push	r10
    1da6:	bf 92       	push	r11
    1da8:	cf 92       	push	r12
    1daa:	df 92       	push	r13
    1dac:	ef 92       	push	r14
    1dae:	ff 92       	push	r15
    1db0:	0f 93       	push	r16
    1db2:	1f 93       	push	r17
    1db4:	cf 93       	push	r28
    1db6:	df 93       	push	r29
    1db8:	4c 01       	movw	r8, r24
    1dba:	5b 01       	movw	r10, r22
    1dbc:	2a 01       	movw	r4, r20
    1dbe:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1dc0:	c1 14       	cp	r12, r1
    1dc2:	d1 04       	cpc	r13, r1
    1dc4:	39 f4       	brne	.+14     	; 0x1dd4 <xTaskGenericCreate+0x3c>
    1dc6:	ca 01       	movw	r24, r20
    1dc8:	0e 94 6f 0b 	call	0x16de	; 0x16de <pvPortMalloc>
    1dcc:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
    1dce:	00 97       	sbiw	r24, 0x00	; 0
    1dd0:	09 f4       	brne	.+2      	; 0x1dd4 <xTaskGenericCreate+0x3c>
    1dd2:	d9 c0       	rjmp	.+434    	; 0x1f86 <xTaskGenericCreate+0x1ee>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    1dd4:	86 e2       	ldi	r24, 0x26	; 38
    1dd6:	90 e0       	ldi	r25, 0x00	; 0
    1dd8:	0e 94 6f 0b 	call	0x16de	; 0x16de <pvPortMalloc>
    1ddc:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
    1dde:	00 97       	sbiw	r24, 0x00	; 0
    1de0:	71 f0       	breq	.+28     	; 0x1dfe <xTaskGenericCreate+0x66>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    1de2:	d8 8e       	std	Y+24, r13	; 0x18
    1de4:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    1de6:	81 e0       	ldi	r24, 0x01	; 1
    1de8:	48 1a       	sub	r4, r24
    1dea:	51 08       	sbc	r5, r1
    1dec:	c4 0c       	add	r12, r4
    1dee:	d5 1c       	adc	r13, r5
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1df0:	d5 01       	movw	r26, r10
    1df2:	8c 91       	ld	r24, X
    1df4:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1df6:	8c 91       	ld	r24, X
    1df8:	81 11       	cpse	r24, r1
    1dfa:	05 c0       	rjmp	.+10     	; 0x1e06 <xTaskGenericCreate+0x6e>
    1dfc:	15 c0       	rjmp	.+42     	; 0x1e28 <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    1dfe:	c6 01       	movw	r24, r12
    1e00:	0e 94 a4 0b 	call	0x1748	; 0x1748 <vPortFree>
    1e04:	c0 c0       	rjmp	.+384    	; 0x1f86 <xTaskGenericCreate+0x1ee>
    1e06:	ae 01       	movw	r20, r28
    1e08:	46 5e       	subi	r20, 0xE6	; 230
    1e0a:	5f 4f       	sbci	r21, 0xFF	; 255
    1e0c:	f5 01       	movw	r30, r10
    1e0e:	31 96       	adiw	r30, 0x01	; 1
		pxTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1e10:	27 e0       	ldi	r18, 0x07	; 7
    1e12:	cf 01       	movw	r24, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1e14:	31 91       	ld	r19, Z+
    1e16:	da 01       	movw	r26, r20
    1e18:	3d 93       	st	X+, r19
    1e1a:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1e1c:	dc 01       	movw	r26, r24
    1e1e:	8c 91       	ld	r24, X
    1e20:	88 23       	and	r24, r24
    1e22:	11 f0       	breq	.+4      	; 0x1e28 <xTaskGenericCreate+0x90>
    1e24:	21 50       	subi	r18, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1e26:	a9 f7       	brne	.-22     	; 0x1e12 <xTaskGenericCreate+0x7a>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1e28:	18 a2       	std	Y+32, r1	; 0x20
    1e2a:	10 2f       	mov	r17, r16
    1e2c:	04 30       	cpi	r16, 0x04	; 4
    1e2e:	08 f0       	brcs	.+2      	; 0x1e32 <xTaskGenericCreate+0x9a>
    1e30:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    1e32:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1e34:	5e 01       	movw	r10, r28
    1e36:	b2 e0       	ldi	r27, 0x02	; 2
    1e38:	ab 0e       	add	r10, r27
    1e3a:	b1 1c       	adc	r11, r1
    1e3c:	c5 01       	movw	r24, r10
    1e3e:	0e 94 95 09 	call	0x132a	; 0x132a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1e42:	ce 01       	movw	r24, r28
    1e44:	0c 96       	adiw	r24, 0x0c	; 12
    1e46:	0e 94 95 09 	call	0x132a	; 0x132a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1e4a:	d9 87       	std	Y+9, r29	; 0x09
    1e4c:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e4e:	84 e0       	ldi	r24, 0x04	; 4
    1e50:	90 e0       	ldi	r25, 0x00	; 0
    1e52:	81 1b       	sub	r24, r17
    1e54:	91 09       	sbc	r25, r1
    1e56:	9d 87       	std	Y+13, r25	; 0x0d
    1e58:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1e5a:	db 8b       	std	Y+19, r29	; 0x13
    1e5c:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    1e5e:	19 a2       	std	Y+33, r1	; 0x21
    1e60:	1a a2       	std	Y+34, r1	; 0x22
    1e62:	1b a2       	std	Y+35, r1	; 0x23
    1e64:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    1e66:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1e68:	a3 01       	movw	r20, r6
    1e6a:	b4 01       	movw	r22, r8
    1e6c:	c6 01       	movw	r24, r12
    1e6e:	0e 94 11 0a 	call	0x1422	; 0x1422 <pxPortInitialiseStack>
    1e72:	99 83       	std	Y+1, r25	; 0x01
    1e74:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    1e76:	e1 14       	cp	r14, r1
    1e78:	f1 04       	cpc	r15, r1
    1e7a:	19 f0       	breq	.+6      	; 0x1e82 <xTaskGenericCreate+0xea>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1e7c:	f7 01       	movw	r30, r14
    1e7e:	d1 83       	std	Z+1, r29	; 0x01
    1e80:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    1e82:	0f b6       	in	r0, 0x3f	; 63
    1e84:	f8 94       	cli
    1e86:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1e88:	80 91 86 07 	lds	r24, 0x0786
    1e8c:	8f 5f       	subi	r24, 0xFF	; 255
    1e8e:	80 93 86 07 	sts	0x0786, r24
			if( pxCurrentTCB == NULL )
    1e92:	80 91 d3 07 	lds	r24, 0x07D3
    1e96:	90 91 d4 07 	lds	r25, 0x07D4
    1e9a:	89 2b       	or	r24, r25
    1e9c:	a9 f5       	brne	.+106    	; 0x1f08 <xTaskGenericCreate+0x170>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1e9e:	d0 93 d4 07 	sts	0x07D4, r29
    1ea2:	c0 93 d3 07 	sts	0x07D3, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1ea6:	80 91 86 07 	lds	r24, 0x0786
    1eaa:	81 30       	cpi	r24, 0x01	; 1
    1eac:	e1 f5       	brne	.+120    	; 0x1f26 <xTaskGenericCreate+0x18e>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1eae:	8f ea       	ldi	r24, 0xAF	; 175
    1eb0:	97 e0       	ldi	r25, 0x07	; 7
    1eb2:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
    1eb6:	88 eb       	ldi	r24, 0xB8	; 184
    1eb8:	97 e0       	ldi	r25, 0x07	; 7
    1eba:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
    1ebe:	81 ec       	ldi	r24, 0xC1	; 193
    1ec0:	97 e0       	ldi	r25, 0x07	; 7
    1ec2:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
    1ec6:	8a ec       	ldi	r24, 0xCA	; 202
    1ec8:	97 e0       	ldi	r25, 0x07	; 7
    1eca:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    1ece:	86 ea       	ldi	r24, 0xA6	; 166
    1ed0:	97 e0       	ldi	r25, 0x07	; 7
    1ed2:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1ed6:	8d e9       	ldi	r24, 0x9D	; 157
    1ed8:	97 e0       	ldi	r25, 0x07	; 7
    1eda:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1ede:	80 e9       	ldi	r24, 0x90	; 144
    1ee0:	97 e0       	ldi	r25, 0x07	; 7
    1ee2:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    1ee6:	87 e8       	ldi	r24, 0x87	; 135
    1ee8:	97 e0       	ldi	r25, 0x07	; 7
    1eea:	0e 94 87 09 	call	0x130e	; 0x130e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1eee:	86 ea       	ldi	r24, 0xA6	; 166
    1ef0:	97 e0       	ldi	r25, 0x07	; 7
    1ef2:	90 93 9c 07 	sts	0x079C, r25
    1ef6:	80 93 9b 07 	sts	0x079B, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1efa:	8d e9       	ldi	r24, 0x9D	; 157
    1efc:	97 e0       	ldi	r25, 0x07	; 7
    1efe:	90 93 9a 07 	sts	0x079A, r25
    1f02:	80 93 99 07 	sts	0x0799, r24
    1f06:	0f c0       	rjmp	.+30     	; 0x1f26 <xTaskGenericCreate+0x18e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1f08:	80 91 82 07 	lds	r24, 0x0782
    1f0c:	81 11       	cpse	r24, r1
    1f0e:	0b c0       	rjmp	.+22     	; 0x1f26 <xTaskGenericCreate+0x18e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1f10:	e0 91 d3 07 	lds	r30, 0x07D3
    1f14:	f0 91 d4 07 	lds	r31, 0x07D4
    1f18:	86 89       	ldd	r24, Z+22	; 0x16
    1f1a:	08 17       	cp	r16, r24
    1f1c:	20 f0       	brcs	.+8      	; 0x1f26 <xTaskGenericCreate+0x18e>
					{
						pxCurrentTCB = pxNewTCB;
    1f1e:	d0 93 d4 07 	sts	0x07D4, r29
    1f22:	c0 93 d3 07 	sts	0x07D3, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    1f26:	80 91 7e 07 	lds	r24, 0x077E
    1f2a:	8f 5f       	subi	r24, 0xFF	; 255
    1f2c:	80 93 7e 07 	sts	0x077E, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    1f30:	8e 89       	ldd	r24, Y+22	; 0x16
    1f32:	90 91 83 07 	lds	r25, 0x0783
    1f36:	98 17       	cp	r25, r24
    1f38:	10 f4       	brcc	.+4      	; 0x1f3e <xTaskGenericCreate+0x1a6>
    1f3a:	80 93 83 07 	sts	0x0783, r24
    1f3e:	90 e0       	ldi	r25, 0x00	; 0
    1f40:	9c 01       	movw	r18, r24
    1f42:	22 0f       	add	r18, r18
    1f44:	33 1f       	adc	r19, r19
    1f46:	22 0f       	add	r18, r18
    1f48:	33 1f       	adc	r19, r19
    1f4a:	22 0f       	add	r18, r18
    1f4c:	33 1f       	adc	r19, r19
    1f4e:	82 0f       	add	r24, r18
    1f50:	93 1f       	adc	r25, r19
    1f52:	b5 01       	movw	r22, r10
    1f54:	81 55       	subi	r24, 0x51	; 81
    1f56:	98 4f       	sbci	r25, 0xF8	; 248
    1f58:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1f5c:	0f 90       	pop	r0
    1f5e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1f60:	80 91 82 07 	lds	r24, 0x0782
    1f64:	88 23       	and	r24, r24
    1f66:	59 f0       	breq	.+22     	; 0x1f7e <xTaskGenericCreate+0x1e6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1f68:	e0 91 d3 07 	lds	r30, 0x07D3
    1f6c:	f0 91 d4 07 	lds	r31, 0x07D4
    1f70:	86 89       	ldd	r24, Z+22	; 0x16
    1f72:	80 17       	cp	r24, r16
    1f74:	30 f4       	brcc	.+12     	; 0x1f82 <xTaskGenericCreate+0x1ea>
			{
				taskYIELD_IF_USING_PREEMPTION();
    1f76:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
    1f7a:	81 e0       	ldi	r24, 0x01	; 1
    1f7c:	05 c0       	rjmp	.+10     	; 0x1f88 <xTaskGenericCreate+0x1f0>
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	03 c0       	rjmp	.+6      	; 0x1f88 <xTaskGenericCreate+0x1f0>
    1f82:	81 e0       	ldi	r24, 0x01	; 1
    1f84:	01 c0       	rjmp	.+2      	; 0x1f88 <xTaskGenericCreate+0x1f0>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f86:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    1f88:	df 91       	pop	r29
    1f8a:	cf 91       	pop	r28
    1f8c:	1f 91       	pop	r17
    1f8e:	0f 91       	pop	r16
    1f90:	ff 90       	pop	r15
    1f92:	ef 90       	pop	r14
    1f94:	df 90       	pop	r13
    1f96:	cf 90       	pop	r12
    1f98:	bf 90       	pop	r11
    1f9a:	af 90       	pop	r10
    1f9c:	9f 90       	pop	r9
    1f9e:	8f 90       	pop	r8
    1fa0:	7f 90       	pop	r7
    1fa2:	6f 90       	pop	r6
    1fa4:	5f 90       	pop	r5
    1fa6:	4f 90       	pop	r4
    1fa8:	08 95       	ret

00001faa <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1faa:	af 92       	push	r10
    1fac:	bf 92       	push	r11
    1fae:	cf 92       	push	r12
    1fb0:	df 92       	push	r13
    1fb2:	ef 92       	push	r14
    1fb4:	ff 92       	push	r15
    1fb6:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    1fb8:	a1 2c       	mov	r10, r1
    1fba:	b1 2c       	mov	r11, r1
    1fbc:	c1 2c       	mov	r12, r1
    1fbe:	d1 2c       	mov	r13, r1
    1fc0:	e1 2c       	mov	r14, r1
    1fc2:	f1 2c       	mov	r15, r1
    1fc4:	00 e0       	ldi	r16, 0x00	; 0
    1fc6:	20 e0       	ldi	r18, 0x00	; 0
    1fc8:	30 e0       	ldi	r19, 0x00	; 0
    1fca:	45 e5       	ldi	r20, 0x55	; 85
    1fcc:	50 e0       	ldi	r21, 0x00	; 0
    1fce:	61 e2       	ldi	r22, 0x21	; 33
    1fd0:	71 e0       	ldi	r23, 0x01	; 1
    1fd2:	8c e8       	ldi	r24, 0x8C	; 140
    1fd4:	9e e0       	ldi	r25, 0x0E	; 14
    1fd6:	0e 94 cc 0e 	call	0x1d98	; 0x1d98 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1fda:	81 30       	cpi	r24, 0x01	; 1
    1fdc:	81 f4       	brne	.+32     	; 0x1ffe <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1fde:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1fe0:	8f ef       	ldi	r24, 0xFF	; 255
    1fe2:	9f ef       	ldi	r25, 0xFF	; 255
    1fe4:	90 93 7d 07 	sts	0x077D, r25
    1fe8:	80 93 7c 07 	sts	0x077C, r24
		xSchedulerRunning = pdTRUE;
    1fec:	81 e0       	ldi	r24, 0x01	; 1
    1fee:	80 93 82 07 	sts	0x0782, r24
		xTickCount = ( TickType_t ) 0U;
    1ff2:	10 92 85 07 	sts	0x0785, r1
    1ff6:	10 92 84 07 	sts	0x0784, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1ffa:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    1ffe:	0f 91       	pop	r16
    2000:	ff 90       	pop	r15
    2002:	ef 90       	pop	r14
    2004:	df 90       	pop	r13
    2006:	cf 90       	pop	r12
    2008:	bf 90       	pop	r11
    200a:	af 90       	pop	r10
    200c:	08 95       	ret

0000200e <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    200e:	80 91 7b 07 	lds	r24, 0x077B
    2012:	8f 5f       	subi	r24, 0xFF	; 255
    2014:	80 93 7b 07 	sts	0x077B, r24
    2018:	08 95       	ret

0000201a <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    201a:	0f b6       	in	r0, 0x3f	; 63
    201c:	f8 94       	cli
    201e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2020:	80 91 84 07 	lds	r24, 0x0784
    2024:	90 91 85 07 	lds	r25, 0x0785
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2028:	0f 90       	pop	r0
    202a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    202c:	08 95       	ret

0000202e <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    202e:	cf 92       	push	r12
    2030:	df 92       	push	r13
    2032:	ef 92       	push	r14
    2034:	ff 92       	push	r15
    2036:	0f 93       	push	r16
    2038:	1f 93       	push	r17
    203a:	cf 93       	push	r28
    203c:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    203e:	80 91 7b 07 	lds	r24, 0x077B
    2042:	81 11       	cpse	r24, r1
    2044:	9a c0       	rjmp	.+308    	; 0x217a <xTaskIncrementTick+0x14c>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    2046:	80 91 84 07 	lds	r24, 0x0784
    204a:	90 91 85 07 	lds	r25, 0x0785
    204e:	01 96       	adiw	r24, 0x01	; 1
    2050:	90 93 85 07 	sts	0x0785, r25
    2054:	80 93 84 07 	sts	0x0784, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2058:	e0 90 84 07 	lds	r14, 0x0784
    205c:	f0 90 85 07 	lds	r15, 0x0785

			if( xConstTickCount == ( TickType_t ) 0U )
    2060:	e1 14       	cp	r14, r1
    2062:	f1 04       	cpc	r15, r1
    2064:	b9 f4       	brne	.+46     	; 0x2094 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
    2066:	80 91 9b 07 	lds	r24, 0x079B
    206a:	90 91 9c 07 	lds	r25, 0x079C
    206e:	20 91 99 07 	lds	r18, 0x0799
    2072:	30 91 9a 07 	lds	r19, 0x079A
    2076:	30 93 9c 07 	sts	0x079C, r19
    207a:	20 93 9b 07 	sts	0x079B, r18
    207e:	90 93 9a 07 	sts	0x079A, r25
    2082:	80 93 99 07 	sts	0x0799, r24
    2086:	80 91 7f 07 	lds	r24, 0x077F
    208a:	8f 5f       	subi	r24, 0xFF	; 255
    208c:	80 93 7f 07 	sts	0x077F, r24
    2090:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    2094:	80 91 7c 07 	lds	r24, 0x077C
    2098:	90 91 7d 07 	lds	r25, 0x077D
    209c:	e8 16       	cp	r14, r24
    209e:	f9 06       	cpc	r15, r25
    20a0:	08 f4       	brcc	.+2      	; 0x20a4 <xTaskIncrementTick+0x76>
    20a2:	54 c0       	rjmp	.+168    	; 0x214c <xTaskIncrementTick+0x11e>
    20a4:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    20a6:	cc 24       	eor	r12, r12
    20a8:	c3 94       	inc	r12
    20aa:	01 c0       	rjmp	.+2      	; 0x20ae <xTaskIncrementTick+0x80>
    20ac:	dc 2c       	mov	r13, r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    20ae:	e0 91 9b 07 	lds	r30, 0x079B
    20b2:	f0 91 9c 07 	lds	r31, 0x079C
    20b6:	80 81       	ld	r24, Z
    20b8:	81 11       	cpse	r24, r1
    20ba:	07 c0       	rjmp	.+14     	; 0x20ca <xTaskIncrementTick+0x9c>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    20bc:	8f ef       	ldi	r24, 0xFF	; 255
    20be:	9f ef       	ldi	r25, 0xFF	; 255
    20c0:	90 93 7d 07 	sts	0x077D, r25
    20c4:	80 93 7c 07 	sts	0x077C, r24
						break;
    20c8:	42 c0       	rjmp	.+132    	; 0x214e <xTaskIncrementTick+0x120>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    20ca:	e0 91 9b 07 	lds	r30, 0x079B
    20ce:	f0 91 9c 07 	lds	r31, 0x079C
    20d2:	05 80       	ldd	r0, Z+5	; 0x05
    20d4:	f6 81       	ldd	r31, Z+6	; 0x06
    20d6:	e0 2d       	mov	r30, r0
    20d8:	c6 81       	ldd	r28, Z+6	; 0x06
    20da:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    20dc:	2a 81       	ldd	r18, Y+2	; 0x02
    20de:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    20e0:	e2 16       	cp	r14, r18
    20e2:	f3 06       	cpc	r15, r19
    20e4:	28 f4       	brcc	.+10     	; 0x20f0 <xTaskIncrementTick+0xc2>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    20e6:	30 93 7d 07 	sts	0x077D, r19
    20ea:	20 93 7c 07 	sts	0x077C, r18
							break;
    20ee:	2f c0       	rjmp	.+94     	; 0x214e <xTaskIncrementTick+0x120>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    20f0:	8e 01       	movw	r16, r28
    20f2:	0e 5f       	subi	r16, 0xFE	; 254
    20f4:	1f 4f       	sbci	r17, 0xFF	; 255
    20f6:	c8 01       	movw	r24, r16
    20f8:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    20fc:	8c 89       	ldd	r24, Y+20	; 0x14
    20fe:	9d 89       	ldd	r25, Y+21	; 0x15
    2100:	89 2b       	or	r24, r25
    2102:	21 f0       	breq	.+8      	; 0x210c <xTaskIncrementTick+0xde>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2104:	ce 01       	movw	r24, r28
    2106:	0c 96       	adiw	r24, 0x0c	; 12
    2108:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    210c:	2e 89       	ldd	r18, Y+22	; 0x16
    210e:	80 91 83 07 	lds	r24, 0x0783
    2112:	82 17       	cp	r24, r18
    2114:	10 f4       	brcc	.+4      	; 0x211a <xTaskIncrementTick+0xec>
    2116:	20 93 83 07 	sts	0x0783, r18
    211a:	30 e0       	ldi	r19, 0x00	; 0
    211c:	c9 01       	movw	r24, r18
    211e:	88 0f       	add	r24, r24
    2120:	99 1f       	adc	r25, r25
    2122:	88 0f       	add	r24, r24
    2124:	99 1f       	adc	r25, r25
    2126:	88 0f       	add	r24, r24
    2128:	99 1f       	adc	r25, r25
    212a:	82 0f       	add	r24, r18
    212c:	93 1f       	adc	r25, r19
    212e:	b8 01       	movw	r22, r16
    2130:	81 55       	subi	r24, 0x51	; 81
    2132:	98 4f       	sbci	r25, 0xF8	; 248
    2134:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2138:	e0 91 d3 07 	lds	r30, 0x07D3
    213c:	f0 91 d4 07 	lds	r31, 0x07D4
    2140:	9e 89       	ldd	r25, Y+22	; 0x16
    2142:	86 89       	ldd	r24, Z+22	; 0x16
    2144:	98 17       	cp	r25, r24
    2146:	08 f0       	brcs	.+2      	; 0x214a <xTaskIncrementTick+0x11c>
    2148:	b1 cf       	rjmp	.-158    	; 0x20ac <xTaskIncrementTick+0x7e>
    214a:	b1 cf       	rjmp	.-158    	; 0x20ae <xTaskIncrementTick+0x80>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    214c:	d1 2c       	mov	r13, r1
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    214e:	e0 91 d3 07 	lds	r30, 0x07D3
    2152:	f0 91 d4 07 	lds	r31, 0x07D4
    2156:	86 89       	ldd	r24, Z+22	; 0x16
    2158:	90 e0       	ldi	r25, 0x00	; 0
    215a:	fc 01       	movw	r30, r24
    215c:	ee 0f       	add	r30, r30
    215e:	ff 1f       	adc	r31, r31
    2160:	ee 0f       	add	r30, r30
    2162:	ff 1f       	adc	r31, r31
    2164:	ee 0f       	add	r30, r30
    2166:	ff 1f       	adc	r31, r31
    2168:	8e 0f       	add	r24, r30
    216a:	9f 1f       	adc	r25, r31
    216c:	fc 01       	movw	r30, r24
    216e:	e1 55       	subi	r30, 0x51	; 81
    2170:	f8 4f       	sbci	r31, 0xF8	; 248
    2172:	80 81       	ld	r24, Z
    2174:	82 30       	cpi	r24, 0x02	; 2
    2176:	40 f4       	brcc	.+16     	; 0x2188 <xTaskIncrementTick+0x15a>
    2178:	09 c0       	rjmp	.+18     	; 0x218c <xTaskIncrementTick+0x15e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    217a:	80 91 81 07 	lds	r24, 0x0781
    217e:	8f 5f       	subi	r24, 0xFF	; 255
    2180:	80 93 81 07 	sts	0x0781, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2184:	d1 2c       	mov	r13, r1
    2186:	02 c0       	rjmp	.+4      	; 0x218c <xTaskIncrementTick+0x15e>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    2188:	dd 24       	eor	r13, r13
    218a:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    218c:	80 91 80 07 	lds	r24, 0x0780
    2190:	88 23       	and	r24, r24
    2192:	11 f0       	breq	.+4      	; 0x2198 <xTaskIncrementTick+0x16a>
		{
			xSwitchRequired = pdTRUE;
    2194:	dd 24       	eor	r13, r13
    2196:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    2198:	8d 2d       	mov	r24, r13
    219a:	df 91       	pop	r29
    219c:	cf 91       	pop	r28
    219e:	1f 91       	pop	r17
    21a0:	0f 91       	pop	r16
    21a2:	ff 90       	pop	r15
    21a4:	ef 90       	pop	r14
    21a6:	df 90       	pop	r13
    21a8:	cf 90       	pop	r12
    21aa:	08 95       	ret

000021ac <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    21ac:	df 92       	push	r13
    21ae:	ef 92       	push	r14
    21b0:	ff 92       	push	r15
    21b2:	0f 93       	push	r16
    21b4:	1f 93       	push	r17
    21b6:	cf 93       	push	r28
    21b8:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    21ba:	0f b6       	in	r0, 0x3f	; 63
    21bc:	f8 94       	cli
    21be:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    21c0:	80 91 7b 07 	lds	r24, 0x077B
    21c4:	81 50       	subi	r24, 0x01	; 1
    21c6:	80 93 7b 07 	sts	0x077B, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    21ca:	80 91 7b 07 	lds	r24, 0x077B
    21ce:	81 11       	cpse	r24, r1
    21d0:	61 c0       	rjmp	.+194    	; 0x2294 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    21d2:	80 91 86 07 	lds	r24, 0x0786
    21d6:	88 23       	and	r24, r24
    21d8:	09 f4       	brne	.+2      	; 0x21dc <xTaskResumeAll+0x30>
    21da:	5e c0       	rjmp	.+188    	; 0x2298 <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    21dc:	0f 2e       	mov	r0, r31
    21de:	f0 e9       	ldi	r31, 0x90	; 144
    21e0:	ef 2e       	mov	r14, r31
    21e2:	f7 e0       	ldi	r31, 0x07	; 7
    21e4:	ff 2e       	mov	r15, r31
    21e6:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    21e8:	dd 24       	eor	r13, r13
    21ea:	d3 94       	inc	r13
    21ec:	30 c0       	rjmp	.+96     	; 0x224e <xTaskResumeAll+0xa2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    21ee:	e0 91 95 07 	lds	r30, 0x0795
    21f2:	f0 91 96 07 	lds	r31, 0x0796
    21f6:	c6 81       	ldd	r28, Z+6	; 0x06
    21f8:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    21fa:	ce 01       	movw	r24, r28
    21fc:	0c 96       	adiw	r24, 0x0c	; 12
    21fe:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2202:	8e 01       	movw	r16, r28
    2204:	0e 5f       	subi	r16, 0xFE	; 254
    2206:	1f 4f       	sbci	r17, 0xFF	; 255
    2208:	c8 01       	movw	r24, r16
    220a:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    220e:	8e 89       	ldd	r24, Y+22	; 0x16
    2210:	90 91 83 07 	lds	r25, 0x0783
    2214:	98 17       	cp	r25, r24
    2216:	10 f4       	brcc	.+4      	; 0x221c <xTaskResumeAll+0x70>
    2218:	80 93 83 07 	sts	0x0783, r24
    221c:	90 e0       	ldi	r25, 0x00	; 0
    221e:	9c 01       	movw	r18, r24
    2220:	22 0f       	add	r18, r18
    2222:	33 1f       	adc	r19, r19
    2224:	22 0f       	add	r18, r18
    2226:	33 1f       	adc	r19, r19
    2228:	22 0f       	add	r18, r18
    222a:	33 1f       	adc	r19, r19
    222c:	82 0f       	add	r24, r18
    222e:	93 1f       	adc	r25, r19
    2230:	b8 01       	movw	r22, r16
    2232:	81 55       	subi	r24, 0x51	; 81
    2234:	98 4f       	sbci	r25, 0xF8	; 248
    2236:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    223a:	e0 91 d3 07 	lds	r30, 0x07D3
    223e:	f0 91 d4 07 	lds	r31, 0x07D4
    2242:	9e 89       	ldd	r25, Y+22	; 0x16
    2244:	86 89       	ldd	r24, Z+22	; 0x16
    2246:	98 17       	cp	r25, r24
    2248:	10 f0       	brcs	.+4      	; 0x224e <xTaskResumeAll+0xa2>
					{
						xYieldPending = pdTRUE;
    224a:	d0 92 80 07 	sts	0x0780, r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    224e:	f7 01       	movw	r30, r14
    2250:	80 81       	ld	r24, Z
    2252:	81 11       	cpse	r24, r1
    2254:	cc cf       	rjmp	.-104    	; 0x21ee <xTaskResumeAll+0x42>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    2256:	80 91 81 07 	lds	r24, 0x0781
    225a:	88 23       	and	r24, r24
    225c:	99 f0       	breq	.+38     	; 0x2284 <xTaskResumeAll+0xd8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    225e:	80 91 81 07 	lds	r24, 0x0781
    2262:	88 23       	and	r24, r24
    2264:	79 f0       	breq	.+30     	; 0x2284 <xTaskResumeAll+0xd8>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    2266:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    2268:	0e 94 17 10 	call	0x202e	; 0x202e <xTaskIncrementTick>
    226c:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
    226e:	c0 93 80 07 	sts	0x0780, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    2272:	80 91 81 07 	lds	r24, 0x0781
    2276:	81 50       	subi	r24, 0x01	; 1
    2278:	80 93 81 07 	sts	0x0781, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    227c:	80 91 81 07 	lds	r24, 0x0781
    2280:	81 11       	cpse	r24, r1
    2282:	f2 cf       	rjmp	.-28     	; 0x2268 <xTaskResumeAll+0xbc>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    2284:	80 91 80 07 	lds	r24, 0x0780
    2288:	81 30       	cpi	r24, 0x01	; 1
    228a:	41 f4       	brne	.+16     	; 0x229c <xTaskResumeAll+0xf0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    228c:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2290:	81 e0       	ldi	r24, 0x01	; 1
    2292:	05 c0       	rjmp	.+10     	; 0x229e <xTaskResumeAll+0xf2>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    2294:	80 e0       	ldi	r24, 0x00	; 0
    2296:	03 c0       	rjmp	.+6      	; 0x229e <xTaskResumeAll+0xf2>
    2298:	80 e0       	ldi	r24, 0x00	; 0
    229a:	01 c0       	rjmp	.+2      	; 0x229e <xTaskResumeAll+0xf2>
    229c:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    229e:	0f 90       	pop	r0
    22a0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    22a2:	df 91       	pop	r29
    22a4:	cf 91       	pop	r28
    22a6:	1f 91       	pop	r17
    22a8:	0f 91       	pop	r16
    22aa:	ff 90       	pop	r15
    22ac:	ef 90       	pop	r14
    22ae:	df 90       	pop	r13
    22b0:	08 95       	ret

000022b2 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    22b2:	0f 93       	push	r16
    22b4:	1f 93       	push	r17
    22b6:	cf 93       	push	r28
    22b8:	df 93       	push	r29
    22ba:	8c 01       	movw	r16, r24
    22bc:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    22be:	0e 94 07 10 	call	0x200e	; 0x200e <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    22c2:	80 91 84 07 	lds	r24, 0x0784
    22c6:	90 91 85 07 	lds	r25, 0x0785

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    22ca:	f8 01       	movw	r30, r16
    22cc:	20 81       	ld	r18, Z
    22ce:	31 81       	ldd	r19, Z+1	; 0x01
    22d0:	c2 0f       	add	r28, r18
    22d2:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    22d4:	82 17       	cp	r24, r18
    22d6:	93 07       	cpc	r25, r19
    22d8:	48 f4       	brcc	.+18     	; 0x22ec <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    22da:	c2 17       	cp	r28, r18
    22dc:	d3 07       	cpc	r29, r19
    22de:	10 f5       	brcc	.+68     	; 0x2324 <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22e0:	d1 83       	std	Z+1, r29	; 0x01
    22e2:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    22e4:	8c 17       	cp	r24, r28
    22e6:	9d 07       	cpc	r25, r29
    22e8:	90 f4       	brcc	.+36     	; 0x230e <vTaskDelayUntil+0x5c>
    22ea:	07 c0       	rjmp	.+14     	; 0x22fa <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    22ec:	c2 17       	cp	r28, r18
    22ee:	d3 07       	cpc	r29, r19
    22f0:	a8 f0       	brcs	.+42     	; 0x231c <vTaskDelayUntil+0x6a>
    22f2:	8c 17       	cp	r24, r28
    22f4:	9d 07       	cpc	r25, r29
    22f6:	90 f0       	brcs	.+36     	; 0x231c <vTaskDelayUntil+0x6a>
    22f8:	15 c0       	rjmp	.+42     	; 0x2324 <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    22fa:	80 91 d3 07 	lds	r24, 0x07D3
    22fe:	90 91 d4 07 	lds	r25, 0x07D4
    2302:	02 96       	adiw	r24, 0x02	; 2
    2304:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2308:	ce 01       	movw	r24, r28
    230a:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    230e:	0e 94 d6 10 	call	0x21ac	; 0x21ac <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2312:	81 11       	cpse	r24, r1
    2314:	0b c0       	rjmp	.+22     	; 0x232c <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
    2316:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
    231a:	08 c0       	rjmp	.+16     	; 0x232c <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    231c:	f8 01       	movw	r30, r16
    231e:	d1 83       	std	Z+1, r29	; 0x01
    2320:	c0 83       	st	Z, r28
    2322:	eb cf       	rjmp	.-42     	; 0x22fa <vTaskDelayUntil+0x48>
    2324:	f8 01       	movw	r30, r16
    2326:	d1 83       	std	Z+1, r29	; 0x01
    2328:	c0 83       	st	Z, r28
    232a:	f1 cf       	rjmp	.-30     	; 0x230e <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    232c:	df 91       	pop	r29
    232e:	cf 91       	pop	r28
    2330:	1f 91       	pop	r17
    2332:	0f 91       	pop	r16
    2334:	08 95       	ret

00002336 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2336:	cf 93       	push	r28
    2338:	df 93       	push	r29
    233a:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    233c:	00 97       	sbiw	r24, 0x00	; 0
    233e:	b1 f0       	breq	.+44     	; 0x236c <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2340:	0e 94 07 10 	call	0x200e	; 0x200e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2344:	80 91 84 07 	lds	r24, 0x0784
    2348:	90 91 85 07 	lds	r25, 0x0785
    234c:	c8 0f       	add	r28, r24
    234e:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2350:	80 91 d3 07 	lds	r24, 0x07D3
    2354:	90 91 d4 07 	lds	r25, 0x07D4
    2358:	02 96       	adiw	r24, 0x02	; 2
    235a:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    235e:	ce 01       	movw	r24, r28
    2360:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2364:	0e 94 d6 10 	call	0x21ac	; 0x21ac <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2368:	81 11       	cpse	r24, r1
    236a:	02 c0       	rjmp	.+4      	; 0x2370 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    236c:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2370:	df 91       	pop	r29
    2372:	cf 91       	pop	r28
    2374:	08 95       	ret

00002376 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2376:	80 91 7b 07 	lds	r24, 0x077B
    237a:	88 23       	and	r24, r24
    237c:	21 f0       	breq	.+8      	; 0x2386 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    237e:	81 e0       	ldi	r24, 0x01	; 1
    2380:	80 93 80 07 	sts	0x0780, r24
    2384:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    2386:	10 92 80 07 	sts	0x0780, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    238a:	80 91 83 07 	lds	r24, 0x0783
    238e:	90 e0       	ldi	r25, 0x00	; 0
    2390:	fc 01       	movw	r30, r24
    2392:	ee 0f       	add	r30, r30
    2394:	ff 1f       	adc	r31, r31
    2396:	ee 0f       	add	r30, r30
    2398:	ff 1f       	adc	r31, r31
    239a:	ee 0f       	add	r30, r30
    239c:	ff 1f       	adc	r31, r31
    239e:	8e 0f       	add	r24, r30
    23a0:	9f 1f       	adc	r25, r31
    23a2:	fc 01       	movw	r30, r24
    23a4:	e1 55       	subi	r30, 0x51	; 81
    23a6:	f8 4f       	sbci	r31, 0xF8	; 248
    23a8:	80 81       	ld	r24, Z
    23aa:	81 11       	cpse	r24, r1
    23ac:	17 c0       	rjmp	.+46     	; 0x23dc <vTaskSwitchContext+0x66>
    23ae:	80 91 83 07 	lds	r24, 0x0783
    23b2:	81 50       	subi	r24, 0x01	; 1
    23b4:	80 93 83 07 	sts	0x0783, r24
    23b8:	80 91 83 07 	lds	r24, 0x0783
    23bc:	90 e0       	ldi	r25, 0x00	; 0
    23be:	fc 01       	movw	r30, r24
    23c0:	ee 0f       	add	r30, r30
    23c2:	ff 1f       	adc	r31, r31
    23c4:	ee 0f       	add	r30, r30
    23c6:	ff 1f       	adc	r31, r31
    23c8:	ee 0f       	add	r30, r30
    23ca:	ff 1f       	adc	r31, r31
    23cc:	8e 0f       	add	r24, r30
    23ce:	9f 1f       	adc	r25, r31
    23d0:	fc 01       	movw	r30, r24
    23d2:	e1 55       	subi	r30, 0x51	; 81
    23d4:	f8 4f       	sbci	r31, 0xF8	; 248
    23d6:	80 81       	ld	r24, Z
    23d8:	88 23       	and	r24, r24
    23da:	49 f3       	breq	.-46     	; 0x23ae <vTaskSwitchContext+0x38>
    23dc:	e0 91 83 07 	lds	r30, 0x0783
    23e0:	f0 e0       	ldi	r31, 0x00	; 0
    23e2:	cf 01       	movw	r24, r30
    23e4:	88 0f       	add	r24, r24
    23e6:	99 1f       	adc	r25, r25
    23e8:	88 0f       	add	r24, r24
    23ea:	99 1f       	adc	r25, r25
    23ec:	88 0f       	add	r24, r24
    23ee:	99 1f       	adc	r25, r25
    23f0:	e8 0f       	add	r30, r24
    23f2:	f9 1f       	adc	r31, r25
    23f4:	e1 55       	subi	r30, 0x51	; 81
    23f6:	f8 4f       	sbci	r31, 0xF8	; 248
    23f8:	a1 81       	ldd	r26, Z+1	; 0x01
    23fa:	b2 81       	ldd	r27, Z+2	; 0x02
    23fc:	12 96       	adiw	r26, 0x02	; 2
    23fe:	0d 90       	ld	r0, X+
    2400:	bc 91       	ld	r27, X
    2402:	a0 2d       	mov	r26, r0
    2404:	b2 83       	std	Z+2, r27	; 0x02
    2406:	a1 83       	std	Z+1, r26	; 0x01
    2408:	cf 01       	movw	r24, r30
    240a:	03 96       	adiw	r24, 0x03	; 3
    240c:	a8 17       	cp	r26, r24
    240e:	b9 07       	cpc	r27, r25
    2410:	31 f4       	brne	.+12     	; 0x241e <vTaskSwitchContext+0xa8>
    2412:	12 96       	adiw	r26, 0x02	; 2
    2414:	8d 91       	ld	r24, X+
    2416:	9c 91       	ld	r25, X
    2418:	13 97       	sbiw	r26, 0x03	; 3
    241a:	92 83       	std	Z+2, r25	; 0x02
    241c:	81 83       	std	Z+1, r24	; 0x01
    241e:	01 80       	ldd	r0, Z+1	; 0x01
    2420:	f2 81       	ldd	r31, Z+2	; 0x02
    2422:	e0 2d       	mov	r30, r0
    2424:	86 81       	ldd	r24, Z+6	; 0x06
    2426:	97 81       	ldd	r25, Z+7	; 0x07
    2428:	90 93 d4 07 	sts	0x07D4, r25
    242c:	80 93 d3 07 	sts	0x07D3, r24
    2430:	08 95       	ret

00002432 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    2432:	0f 93       	push	r16
    2434:	1f 93       	push	r17
    2436:	cf 93       	push	r28
    2438:	df 93       	push	r29
    243a:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    243c:	0f b6       	in	r0, 0x3f	; 63
    243e:	f8 94       	cli
    2440:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    2442:	00 97       	sbiw	r24, 0x00	; 0
    2444:	21 f4       	brne	.+8      	; 0x244e <vTaskSuspend+0x1c>
    2446:	c0 91 d3 07 	lds	r28, 0x07D3
    244a:	d0 91 d4 07 	lds	r29, 0x07D4

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    244e:	8e 01       	movw	r16, r28
    2450:	0e 5f       	subi	r16, 0xFE	; 254
    2452:	1f 4f       	sbci	r17, 0xFF	; 255
    2454:	c8 01       	movw	r24, r16
    2456:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    245a:	8c 89       	ldd	r24, Y+20	; 0x14
    245c:	9d 89       	ldd	r25, Y+21	; 0x15
    245e:	89 2b       	or	r24, r25
    2460:	21 f0       	breq	.+8      	; 0x246a <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2462:	ce 01       	movw	r24, r28
    2464:	0c 96       	adiw	r24, 0x0c	; 12
    2466:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    246a:	b8 01       	movw	r22, r16
    246c:	87 e8       	ldi	r24, 0x87	; 135
    246e:	97 e0       	ldi	r25, 0x07	; 7
    2470:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    2474:	0f 90       	pop	r0
    2476:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    2478:	80 91 d3 07 	lds	r24, 0x07D3
    247c:	90 91 d4 07 	lds	r25, 0x07D4
    2480:	c8 17       	cp	r28, r24
    2482:	d9 07       	cpc	r29, r25
    2484:	a9 f4       	brne	.+42     	; 0x24b0 <vTaskSuspend+0x7e>
		{
			if( xSchedulerRunning != pdFALSE )
    2486:	80 91 82 07 	lds	r24, 0x0782
    248a:	88 23       	and	r24, r24
    248c:	19 f0       	breq	.+6      	; 0x2494 <vTaskSuspend+0x62>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    248e:	0e 94 b7 0a 	call	0x156e	; 0x156e <vPortYield>
    2492:	19 c0       	rjmp	.+50     	; 0x24c6 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    2494:	80 91 86 07 	lds	r24, 0x0786
    2498:	90 91 87 07 	lds	r25, 0x0787
    249c:	98 13       	cpse	r25, r24
    249e:	05 c0       	rjmp	.+10     	; 0x24aa <vTaskSuspend+0x78>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    24a0:	10 92 d4 07 	sts	0x07D4, r1
    24a4:	10 92 d3 07 	sts	0x07D3, r1
    24a8:	0e c0       	rjmp	.+28     	; 0x24c6 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    24aa:	0e 94 bb 11 	call	0x2376	; 0x2376 <vTaskSwitchContext>
    24ae:	0b c0       	rjmp	.+22     	; 0x24c6 <vTaskSuspend+0x94>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    24b0:	80 91 82 07 	lds	r24, 0x0782
    24b4:	88 23       	and	r24, r24
    24b6:	39 f0       	breq	.+14     	; 0x24c6 <vTaskSuspend+0x94>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    24b8:	0f b6       	in	r0, 0x3f	; 63
    24ba:	f8 94       	cli
    24bc:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    24be:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    24c2:	0f 90       	pop	r0
    24c4:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    24c6:	df 91       	pop	r29
    24c8:	cf 91       	pop	r28
    24ca:	1f 91       	pop	r17
    24cc:	0f 91       	pop	r16
    24ce:	08 95       	ret

000024d0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    24d0:	cf 93       	push	r28
    24d2:	df 93       	push	r29
    24d4:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    24d6:	60 91 d3 07 	lds	r22, 0x07D3
    24da:	70 91 d4 07 	lds	r23, 0x07D4
    24de:	64 5f       	subi	r22, 0xF4	; 244
    24e0:	7f 4f       	sbci	r23, 0xFF	; 255
    24e2:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    24e6:	80 91 d3 07 	lds	r24, 0x07D3
    24ea:	90 91 d4 07 	lds	r25, 0x07D4
    24ee:	02 96       	adiw	r24, 0x02	; 2
    24f0:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    24f4:	cf 3f       	cpi	r28, 0xFF	; 255
    24f6:	8f ef       	ldi	r24, 0xFF	; 255
    24f8:	d8 07       	cpc	r29, r24
    24fa:	59 f4       	brne	.+22     	; 0x2512 <vTaskPlaceOnEventList+0x42>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    24fc:	60 91 d3 07 	lds	r22, 0x07D3
    2500:	70 91 d4 07 	lds	r23, 0x07D4
    2504:	6e 5f       	subi	r22, 0xFE	; 254
    2506:	7f 4f       	sbci	r23, 0xFF	; 255
    2508:	87 e8       	ldi	r24, 0x87	; 135
    250a:	97 e0       	ldi	r25, 0x07	; 7
    250c:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
    2510:	08 c0       	rjmp	.+16     	; 0x2522 <vTaskPlaceOnEventList+0x52>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    2512:	80 91 84 07 	lds	r24, 0x0784
    2516:	90 91 85 07 	lds	r25, 0x0785
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    251a:	8c 0f       	add	r24, r28
    251c:	9d 1f       	adc	r25, r29
    251e:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2522:	df 91       	pop	r29
    2524:	cf 91       	pop	r28
    2526:	08 95       	ret

00002528 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2528:	0f 93       	push	r16
    252a:	1f 93       	push	r17
    252c:	cf 93       	push	r28
    252e:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2530:	dc 01       	movw	r26, r24
    2532:	15 96       	adiw	r26, 0x05	; 5
    2534:	ed 91       	ld	r30, X+
    2536:	fc 91       	ld	r31, X
    2538:	16 97       	sbiw	r26, 0x06	; 6
    253a:	c6 81       	ldd	r28, Z+6	; 0x06
    253c:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    253e:	8e 01       	movw	r16, r28
    2540:	04 5f       	subi	r16, 0xF4	; 244
    2542:	1f 4f       	sbci	r17, 0xFF	; 255
    2544:	c8 01       	movw	r24, r16
    2546:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    254a:	80 91 7b 07 	lds	r24, 0x077B
    254e:	81 11       	cpse	r24, r1
    2550:	1c c0       	rjmp	.+56     	; 0x258a <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2552:	0a 50       	subi	r16, 0x0A	; 10
    2554:	11 09       	sbc	r17, r1
    2556:	c8 01       	movw	r24, r16
    2558:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    255c:	8e 89       	ldd	r24, Y+22	; 0x16
    255e:	90 91 83 07 	lds	r25, 0x0783
    2562:	98 17       	cp	r25, r24
    2564:	10 f4       	brcc	.+4      	; 0x256a <xTaskRemoveFromEventList+0x42>
    2566:	80 93 83 07 	sts	0x0783, r24
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	9c 01       	movw	r18, r24
    256e:	22 0f       	add	r18, r18
    2570:	33 1f       	adc	r19, r19
    2572:	22 0f       	add	r18, r18
    2574:	33 1f       	adc	r19, r19
    2576:	22 0f       	add	r18, r18
    2578:	33 1f       	adc	r19, r19
    257a:	82 0f       	add	r24, r18
    257c:	93 1f       	adc	r25, r19
    257e:	b8 01       	movw	r22, r16
    2580:	81 55       	subi	r24, 0x51	; 81
    2582:	98 4f       	sbci	r25, 0xF8	; 248
    2584:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
    2588:	05 c0       	rjmp	.+10     	; 0x2594 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    258a:	b8 01       	movw	r22, r16
    258c:	80 e9       	ldi	r24, 0x90	; 144
    258e:	97 e0       	ldi	r25, 0x07	; 7
    2590:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2594:	e0 91 d3 07 	lds	r30, 0x07D3
    2598:	f0 91 d4 07 	lds	r31, 0x07D4
    259c:	9e 89       	ldd	r25, Y+22	; 0x16
    259e:	86 89       	ldd	r24, Z+22	; 0x16
    25a0:	89 17       	cp	r24, r25
    25a2:	20 f4       	brcc	.+8      	; 0x25ac <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    25a4:	81 e0       	ldi	r24, 0x01	; 1
    25a6:	80 93 80 07 	sts	0x0780, r24
    25aa:	01 c0       	rjmp	.+2      	; 0x25ae <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    25ac:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    25ae:	df 91       	pop	r29
    25b0:	cf 91       	pop	r28
    25b2:	1f 91       	pop	r17
    25b4:	0f 91       	pop	r16
    25b6:	08 95       	ret

000025b8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    25b8:	20 91 7f 07 	lds	r18, 0x077F
    25bc:	fc 01       	movw	r30, r24
    25be:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    25c0:	20 91 84 07 	lds	r18, 0x0784
    25c4:	30 91 85 07 	lds	r19, 0x0785
    25c8:	32 83       	std	Z+2, r19	; 0x02
    25ca:	21 83       	std	Z+1, r18	; 0x01
    25cc:	08 95       	ret

000025ce <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    25ce:	0f b6       	in	r0, 0x3f	; 63
    25d0:	f8 94       	cli
    25d2:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    25d4:	40 91 84 07 	lds	r20, 0x0784
    25d8:	50 91 85 07 	lds	r21, 0x0785

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    25dc:	db 01       	movw	r26, r22
    25de:	2d 91       	ld	r18, X+
    25e0:	3c 91       	ld	r19, X
    25e2:	2f 3f       	cpi	r18, 0xFF	; 255
    25e4:	bf ef       	ldi	r27, 0xFF	; 255
    25e6:	3b 07       	cpc	r19, r27
    25e8:	19 f1       	breq	.+70     	; 0x2630 <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    25ea:	e0 91 7f 07 	lds	r30, 0x077F
    25ee:	dc 01       	movw	r26, r24
    25f0:	fc 91       	ld	r31, X
    25f2:	fe 17       	cp	r31, r30
    25f4:	39 f0       	breq	.+14     	; 0x2604 <xTaskCheckForTimeOut+0x36>
    25f6:	11 96       	adiw	r26, 0x01	; 1
    25f8:	ed 91       	ld	r30, X+
    25fa:	fc 91       	ld	r31, X
    25fc:	12 97       	sbiw	r26, 0x02	; 2
    25fe:	4e 17       	cp	r20, r30
    2600:	5f 07       	cpc	r21, r31
    2602:	c0 f4       	brcc	.+48     	; 0x2634 <xTaskCheckForTimeOut+0x66>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2604:	dc 01       	movw	r26, r24
    2606:	11 96       	adiw	r26, 0x01	; 1
    2608:	ed 91       	ld	r30, X+
    260a:	fc 91       	ld	r31, X
    260c:	12 97       	sbiw	r26, 0x02	; 2
    260e:	da 01       	movw	r26, r20
    2610:	ae 1b       	sub	r26, r30
    2612:	bf 0b       	sbc	r27, r31
    2614:	a2 17       	cp	r26, r18
    2616:	b3 07       	cpc	r27, r19
    2618:	78 f4       	brcc	.+30     	; 0x2638 <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    261a:	e4 1b       	sub	r30, r20
    261c:	f5 0b       	sbc	r31, r21
    261e:	2e 0f       	add	r18, r30
    2620:	3f 1f       	adc	r19, r31
    2622:	fb 01       	movw	r30, r22
    2624:	31 83       	std	Z+1, r19	; 0x01
    2626:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    2628:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    262c:	80 e0       	ldi	r24, 0x00	; 0
    262e:	05 c0       	rjmp	.+10     	; 0x263a <xTaskCheckForTimeOut+0x6c>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    2630:	80 e0       	ldi	r24, 0x00	; 0
    2632:	03 c0       	rjmp	.+6      	; 0x263a <xTaskCheckForTimeOut+0x6c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	01 c0       	rjmp	.+2      	; 0x263a <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2638:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    263a:	0f 90       	pop	r0
    263c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    263e:	08 95       	ret

00002640 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2640:	81 e0       	ldi	r24, 0x01	; 1
    2642:	80 93 80 07 	sts	0x0780, r24
    2646:	08 95       	ret

00002648 <__tablejump2__>:
    2648:	ee 0f       	add	r30, r30
    264a:	ff 1f       	adc	r31, r31

0000264c <__tablejump__>:
    264c:	05 90       	lpm	r0, Z+
    264e:	f4 91       	lpm	r31, Z
    2650:	e0 2d       	mov	r30, r0
    2652:	09 94       	ijmp

00002654 <memcpy>:
    2654:	fb 01       	movw	r30, r22
    2656:	dc 01       	movw	r26, r24
    2658:	02 c0       	rjmp	.+4      	; 0x265e <memcpy+0xa>
    265a:	01 90       	ld	r0, Z+
    265c:	0d 92       	st	X+, r0
    265e:	41 50       	subi	r20, 0x01	; 1
    2660:	50 40       	sbci	r21, 0x00	; 0
    2662:	d8 f7       	brcc	.-10     	; 0x265a <memcpy+0x6>
    2664:	08 95       	ret

00002666 <_exit>:
    2666:	f8 94       	cli

00002668 <__stop_program>:
    2668:	ff cf       	rjmp	.-2      	; 0x2668 <__stop_program>
