
FreeRTOSatmega328p.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  00002678  0000270c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002678  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000757  00800126  00800126  00002732  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002732  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000520  00000000  00000000  00002762  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00006697  00000000  00000000  00002c82  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000019a4  00000000  00000000  00009319  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000026f0  00000000  00000000  0000acbd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f7c  00000000  00000000  0000d3b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000186c  00000000  00000000  0000e32c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00005945  00000000  00000000  0000fb98  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000480  00000000  00000000  000154dd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
       0:	0c 94 be 01 	jmp	0x37c	; 0x37c <__ctors_end>
       4:	0c 94 64 09 	jmp	0x12c8	; 0x12c8 <__vector_1>
       8:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
       c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      10:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      14:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      18:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
      1c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
      20:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      24:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
      28:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
      2c:	0c 94 73 0b 	jmp	0x16e6	; 0x16e6 <__vector_11>
      30:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      34:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      38:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
      3c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      40:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      44:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      48:	0c 94 c1 06 	jmp	0xd82	; 0xd82 <__vector_18>
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );

		if( xWaitConditionMet != pdFALSE )
      4c:	0c 94 f1 06 	jmp	0xde2	; 0xde2 <__vector_19>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
      50:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
      54:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      58:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      5c:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      60:	0c 94 a2 07 	jmp	0xf44	; 0xf44 <__vector_24>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
      64:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__bad_interrupt>
      68:	bc 07       	cpc	r27, r28
      6a:	1d 08       	sbc	r1, r13
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
      6c:	1d 08       	sbc	r1, r13
      6e:	1d 08       	sbc	r1, r13
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
      70:	1d 08       	sbc	r1, r13
      72:	1d 08       	sbc	r1, r13
      74:	1d 08       	sbc	r1, r13
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
      76:	1d 08       	sbc	r1, r13
      78:	bc 07       	cpc	r27, r28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
      7a:	1d 08       	sbc	r1, r13
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
      7c:	1d 08       	sbc	r1, r13
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
      7e:	1d 08       	sbc	r1, r13
      80:	1d 08       	sbc	r1, r13
      82:	1d 08       	sbc	r1, r13
      84:	1d 08       	sbc	r1, r13
      86:	1d 08       	sbc	r1, r13
      88:	be 07       	cpc	r27, r30
      8a:	1d 08       	sbc	r1, r13
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
      8c:	1d 08       	sbc	r1, r13
      8e:	1d 08       	sbc	r1, r13

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
      90:	1d 08       	sbc	r1, r13
      92:	1d 08       	sbc	r1, r13
		{
			portYIELD_WITHIN_API();
      94:	1d 08       	sbc	r1, r13
      96:	1d 08       	sbc	r1, r13

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
      98:	1d 08       	sbc	r1, r13
      9a:	1d 08       	sbc	r1, r13

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
      9c:	1d 08       	sbc	r1, r13
      9e:	1d 08       	sbc	r1, r13
		{
			taskENTER_CRITICAL();
      a0:	1d 08       	sbc	r1, r13
      a2:	1d 08       	sbc	r1, r13
      a4:	1d 08       	sbc	r1, r13
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
      a6:	1d 08       	sbc	r1, r13
      a8:	be 07       	cpc	r27, r30
      aa:	1d 08       	sbc	r1, r13

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
      ac:	1d 08       	sbc	r1, r13
      ae:	1d 08       	sbc	r1, r13
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
      b0:	1d 08       	sbc	r1, r13
      b2:	1d 08       	sbc	r1, r13
      b4:	1d 08       	sbc	r1, r13
      b6:	1d 08       	sbc	r1, r13
      b8:	1d 08       	sbc	r1, r13
      ba:	1d 08       	sbc	r1, r13
      bc:	1d 08       	sbc	r1, r13
      be:	1d 08       	sbc	r1, r13
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
      c0:	1d 08       	sbc	r1, r13
      c2:	1d 08       	sbc	r1, r13
      c4:	1d 08       	sbc	r1, r13
      c6:	1d 08       	sbc	r1, r13
      c8:	16 08       	sbc	r1, r6
      ca:	1d 08       	sbc	r1, r13
      cc:	1d 08       	sbc	r1, r13
      ce:	1d 08       	sbc	r1, r13
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
      d0:	1d 08       	sbc	r1, r13
      d2:	1d 08       	sbc	r1, r13
				{
					if( xClearOnExit != pdFALSE )
      d4:	1d 08       	sbc	r1, r13
      d6:	1d 08       	sbc	r1, r13
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
      d8:	eb 07       	cpc	r30, r27
      da:	1d 08       	sbc	r1, r13
      dc:	1d 08       	sbc	r1, r13
      de:	1d 08       	sbc	r1, r13
      e0:	1d 08       	sbc	r1, r13
      e2:	1d 08       	sbc	r1, r13
      e4:	1d 08       	sbc	r1, r13
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
      e6:	1d 08       	sbc	r1, r13
      e8:	1d 08       	sbc	r1, r13
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
      ea:	1d 08       	sbc	r1, r13
      ec:	1d 08       	sbc	r1, r13
      ee:	1d 08       	sbc	r1, r13
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
      f0:	1d 08       	sbc	r1, r13
      f2:	1d 08       	sbc	r1, r13
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
      f4:	1d 08       	sbc	r1, r13
      f6:	1d 08       	sbc	r1, r13
      f8:	df 07       	cpc	r29, r31
      fa:	1d 08       	sbc	r1, r13
      fc:	1d 08       	sbc	r1, r13
      fe:	1d 08       	sbc	r1, r13
     100:	1d 08       	sbc	r1, r13
     102:	1d 08       	sbc	r1, r13
     104:	1d 08       	sbc	r1, r13
     106:	1d 08       	sbc	r1, r13
     108:	03 08       	sbc	r0, r3

0000010a <__trampolines_end>:
     10a:	05 00       	.word	0x0005	; ????
     10c:	05 00       	.word	0x0005	; ????

0000010e <setServiceACK>:
     10e:	01 02 00 00 08 01                                   ......

00000114 <setService>:
     114:	01 0a 05 08 03 01 00 f9 81 00 00 01 2c              ............,

00000121 <serviceACK>:
     121:	0e 00 05 00                                         ....

00000125 <svcIndication>:
     125:	0e 0c 04 00 00 80 01 03 02 f9 81 00 00 03 e8        ...............

00000134 <operationalEvent>:
     134:	0f 09 02 00 00 00 24 05 00 00 00 00                 ......$.....

00000140 <alarmEvent>:
     140:	0f 09 04 00 00 00 02 04 00 00 00 00                 ............

0000014c <negotiatingEvent>:
     14c:	0f 09 04 00 00 01 00 03 00 00 00 08                 ............

00000158 <moteSearchingEvent>:
     158:	0f 09 04 00 00 00 02 02 00 00 00 08                 ............

00000164 <joinACK>:
     164:	06 00 05 00                                         ....

00000168 <joinCommand>:
     168:	06 00 04                                            ...

0000016b <eventACK>:
     16b:	0f 00 05 00                                         ....

0000016f <bootEvent>:
     16f:	0f 09 08 00 00 00 01 01 00 00 00 00                 ............

0000017b <fcstab>:
     17b:	00 00 89 11 12 23 9b 32 24 46 ad 57 36 65 bf 74     .....#.2$F.W6e.t
     18b:	48 8c c1 9d 5a af d3 be 6c ca e5 db 7e e9 f7 f8     H...Z...l...~...
     19b:	81 10 08 01 93 33 1a 22 a5 56 2c 47 b7 75 3e 64     .....3.".V,G.u>d
     1ab:	c9 9c 40 8d db bf 52 ae ed da 64 cb ff f9 76 e8     ..@...R...d...v.
     1bb:	02 21 8b 30 10 02 99 13 26 67 af 76 34 44 bd 55     .!.0....&g.v4D.U
     1cb:	4a ad c3 bc 58 8e d1 9f 6e eb e7 fa 7c c8 f5 d9     J...X...n...|...
     1db:	83 31 0a 20 91 12 18 03 a7 77 2e 66 b5 54 3c 45     .1. .....w.f.T<E
     1eb:	cb bd 42 ac d9 9e 50 8f ef fb 66 ea fd d8 74 c9     ..B...P...f...t.
     1fb:	04 42 8d 53 16 61 9f 70 20 04 a9 15 32 27 bb 36     .B.S.a.p ...2'.6
     20b:	4c ce c5 df 5e ed d7 fc 68 88 e1 99 7a ab f3 ba     L...^...h...z...
     21b:	85 52 0c 43 97 71 1e 60 a1 14 28 05 b3 37 3a 26     .R.C.q.`..(..7:&
     22b:	cd de 44 cf df fd 56 ec e9 98 60 89 fb bb 72 aa     ..D...V...`...r.
     23b:	06 63 8f 72 14 40 9d 51 22 25 ab 34 30 06 b9 17     .c.r.@.Q"%.40...
     24b:	4e ef c7 fe 5c cc d5 dd 6a a9 e3 b8 78 8a f1 9b     N...\...j...x...
     25b:	87 73 0e 62 95 50 1c 41 a3 35 2a 24 b1 16 38 07     .s.b.P.A.5*$..8.
     26b:	cf ff 46 ee dd dc 54 cd eb b9 62 a8 f9 9a 70 8b     ..F...T...b...p.
     27b:	08 84 81 95 1a a7 93 b6 2c c2 a5 d3 3e e1 b7 f0     ........,...>...
     28b:	40 08 c9 19 52 2b db 3a 64 4e ed 5f 76 6d ff 7c     @...R+.:dN._vm.|
     29b:	89 94 00 85 9b b7 12 a6 ad d2 24 c3 bf f1 36 e0     ..........$...6.
     2ab:	c1 18 48 09 d3 3b 5a 2a e5 5e 6c 4f f7 7d 7e 6c     ..H..;Z*.^lO.}~l
     2bb:	0a a5 83 b4 18 86 91 97 2e e3 a7 f2 3c c0 b5 d1     ............<...
     2cb:	42 29 cb 38 50 0a d9 1b 66 6f ef 7e 74 4c fd 5d     B).8P...fo.~tL.]
     2db:	8b b5 02 a4 99 96 10 87 af f3 26 e2 bd d0 34 c1     ..........&...4.
     2eb:	c3 39 4a 28 d1 1a 58 0b e7 7f 6e 6e f5 5c 7c 4d     .9J(..X...nn.\|M
     2fb:	0c c6 85 d7 1e e5 97 f4 28 80 a1 91 3a a3 b3 b2     ........(...:...
     30b:	44 4a cd 5b 56 69 df 78 60 0c e9 1d 72 2f fb 3e     DJ.[Vi.x`...r/.>
     31b:	8d d6 04 c7 9f f5 16 e4 a9 90 20 81 bb b3 32 a2     .......... ...2.
     32b:	c5 5a 4c 4b d7 79 5e 68 e1 1c 68 0d f3 3f 7a 2e     .ZLK.y^h..h..?z.
     33b:	0e e7 87 f6 1c c4 95 d5 2a a1 a3 b0 38 82 b1 93     ........*...8...
     34b:	46 6b cf 7a 54 48 dd 59 62 2d eb 3c 70 0e f9 1f     Fk.zTH.Yb-.<p...
     35b:	8f f7 06 e6 9d d4 14 c5 ab b1 22 a0 b9 92 30 83     .........."...0.
     36b:	c7 7b 4e 6a d5 58 5c 49 e3 3d 6a 2c f1 1e 78 0f     .{Nj.X\I.=j,..x.
	...

0000037c <__ctors_end>:
     37c:	11 24       	eor	r1, r1
     37e:	1f be       	out	0x3f, r1	; 63
     380:	cf ef       	ldi	r28, 0xFF	; 255
     382:	d8 e0       	ldi	r29, 0x08	; 8
     384:	de bf       	out	0x3e, r29	; 62
     386:	cd bf       	out	0x3d, r28	; 61

00000388 <__do_copy_data>:
     388:	11 e0       	ldi	r17, 0x01	; 1
     38a:	a0 e0       	ldi	r26, 0x00	; 0
     38c:	b1 e0       	ldi	r27, 0x01	; 1
     38e:	e8 e7       	ldi	r30, 0x78	; 120
     390:	f6 e2       	ldi	r31, 0x26	; 38
     392:	02 c0       	rjmp	.+4      	; 0x398 <__do_copy_data+0x10>
     394:	05 90       	lpm	r0, Z+
     396:	0d 92       	st	X+, r0
     398:	a6 32       	cpi	r26, 0x26	; 38
     39a:	b1 07       	cpc	r27, r17
     39c:	d9 f7       	brne	.-10     	; 0x394 <__do_copy_data+0xc>

0000039e <__do_clear_bss>:
     39e:	28 e0       	ldi	r18, 0x08	; 8
     3a0:	a6 e2       	ldi	r26, 0x26	; 38
     3a2:	b1 e0       	ldi	r27, 0x01	; 1
     3a4:	01 c0       	rjmp	.+2      	; 0x3a8 <.do_clear_bss_start>

000003a6 <.do_clear_bss_loop>:
     3a6:	1d 92       	st	X+, r1

000003a8 <.do_clear_bss_start>:
     3a8:	ad 37       	cpi	r26, 0x7D	; 125
     3aa:	b2 07       	cpc	r27, r18
     3ac:	e1 f7       	brne	.-8      	; 0x3a6 <.do_clear_bss_loop>
     3ae:	0e 94 33 08 	call	0x1066	; 0x1066 <main>
     3b2:	0c 94 3a 13 	jmp	0x2674	; 0x2674 <_exit>

000003b6 <__bad_interrupt>:
     3b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003ba <xMoteTask>:
	moteReadySemaphore = xSemaphoreCreateBinary();
	xTaskCreate( xMoteTask,( signed char * ) "Mote", comSTACK_SIZE, NULL, uxPriority, NULL );
		
}

void xMoteTask( void* pvParameters){
     3ba:	cf 93       	push	r28
     3bc:	df 93       	push	r29
     3be:	00 d0       	rcall	.+0      	; 0x3c0 <xMoteTask+0x6>
     3c0:	cd b7       	in	r28, 0x3d	; 61
     3c2:	de b7       	in	r29, 0x3e	; 62
	
	
	configureMote();
     3c4:	0e 94 38 07 	call	0xe70	; 0xe70 <configureMote>
	xSemaphoreGive(moteReadySemaphore);
     3c8:	20 e0       	ldi	r18, 0x00	; 0
     3ca:	40 e0       	ldi	r20, 0x00	; 0
     3cc:	50 e0       	ldi	r21, 0x00	; 0
     3ce:	60 e0       	ldi	r22, 0x00	; 0
     3d0:	70 e0       	ldi	r23, 0x00	; 0
     3d2:	80 91 d5 07 	lds	r24, 0x07D5
     3d6:	90 91 d6 07 	lds	r25, 0x07D6
     3da:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xQueueGenericSend>
	for ( ;; )
	{
		//sendMoteData(datos2,sizeof(datos2));
		//vTaskDelayUntil(&xLastWakeTime2,xFrequency2);
		
		if ( xQueueReceive(DataToSend,&(datos),DATA_READY_TO_SEND_BLOCK_TIME)  ) //Block on the DataToSendQueue
     3de:	20 e0       	ldi	r18, 0x00	; 0
     3e0:	4f ef       	ldi	r20, 0xFF	; 255
     3e2:	5f ef       	ldi	r21, 0xFF	; 255
     3e4:	be 01       	movw	r22, r28
     3e6:	6f 5f       	subi	r22, 0xFF	; 255
     3e8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ea:	80 91 79 08 	lds	r24, 0x0879
     3ee:	90 91 7a 08 	lds	r25, 0x087A
     3f2:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     3f6:	88 23       	and	r24, r24
     3f8:	91 f3       	breq	.-28     	; 0x3de <xMoteTask+0x24>
		{
			//The queue is of size 1 and contains the pointer to the data to be sent
			sendMoteData(datos,NUMBER_OF_BYTES_TO_SEND);
     3fa:	60 e3       	ldi	r22, 0x30	; 48
     3fc:	89 81       	ldd	r24, Y+1	; 0x01
     3fe:	9a 81       	ldd	r25, Y+2	; 0x02
     400:	0e 94 32 07 	call	0xe64	; 0xe64 <sendMoteData>
     404:	ec cf       	rjmp	.-40     	; 0x3de <xMoteTask+0x24>

00000406 <startCommTasks>:
static xComPortHandle xPort = NULL;

extern QueueHandle_t DataToSend;
SemaphoreHandle_t moteReadySemaphore; // sync for sensor task

void startCommTasks(UBaseType_t uxPriority){
     406:	af 92       	push	r10
     408:	bf 92       	push	r11
     40a:	cf 92       	push	r12
     40c:	df 92       	push	r13
     40e:	ef 92       	push	r14
     410:	ff 92       	push	r15
     412:	0f 93       	push	r16
     414:	08 2f       	mov	r16, r24
	xSerialPortInitMinimal(BUFFER_LENGTH);
     416:	80 e8       	ldi	r24, 0x80	; 128
     418:	0e 94 77 06 	call	0xcee	; 0xcee <xSerialPortInitMinimal>
	/* The Tx task is spawned with a lower priority than the Rx task. */
	moteReadySemaphore = xSemaphoreCreateBinary();
     41c:	43 e0       	ldi	r20, 0x03	; 3
     41e:	60 e0       	ldi	r22, 0x00	; 0
     420:	81 e0       	ldi	r24, 0x01	; 1
     422:	0e 94 9a 0c 	call	0x1934	; 0x1934 <xQueueGenericCreate>
     426:	90 93 d6 07 	sts	0x07D6, r25
     42a:	80 93 d5 07 	sts	0x07D5, r24
	xTaskCreate( xMoteTask,( signed char * ) "Mote", comSTACK_SIZE, NULL, uxPriority, NULL );
     42e:	a1 2c       	mov	r10, r1
     430:	b1 2c       	mov	r11, r1
     432:	c1 2c       	mov	r12, r1
     434:	d1 2c       	mov	r13, r1
     436:	e1 2c       	mov	r14, r1
     438:	f1 2c       	mov	r15, r1
     43a:	20 e0       	ldi	r18, 0x00	; 0
     43c:	30 e0       	ldi	r19, 0x00	; 0
     43e:	40 e0       	ldi	r20, 0x00	; 0
     440:	51 e0       	ldi	r21, 0x01	; 1
     442:	61 e0       	ldi	r22, 0x01	; 1
     444:	71 e0       	ldi	r23, 0x01	; 1
     446:	8d ed       	ldi	r24, 0xDD	; 221
     448:	91 e0       	ldi	r25, 0x01	; 1
     44a:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xTaskGenericCreate>
		
}
     44e:	0f 91       	pop	r16
     450:	ff 90       	pop	r15
     452:	ef 90       	pop	r14
     454:	df 90       	pop	r13
     456:	cf 90       	pop	r12
     458:	bf 90       	pop	r11
     45a:	af 90       	pop	r10
     45c:	08 95       	ret

0000045e <InterruptReception>:

extern SemaphoreHandle_t frameHandle;



uint8_t InterruptReception (MoteData_p moteData) {
     45e:	0f 93       	push	r16
     460:	1f 93       	push	r17
     462:	cf 93       	push	r28
     464:	df 93       	push	r29
     466:	ec 01       	movw	r28, r24
//Place this function inside your Serial Receipt Interrupt
//Dont read the byte, the function serialMoteReceive will do it

moteData->RXbuffer[moteData->RXindex]=moteData->serialMoteReceive();
     468:	0c 81       	ldd	r16, Y+4	; 0x04
     46a:	10 e0       	ldi	r17, 0x00	; 0
     46c:	ea 81       	ldd	r30, Y+2	; 0x02
     46e:	fb 81       	ldd	r31, Y+3	; 0x03
     470:	09 95       	icall
     472:	fe 01       	movw	r30, r28
     474:	e0 0f       	add	r30, r16
     476:	f1 1f       	adc	r31, r17
     478:	85 83       	std	Z+5, r24	; 0x05
//moteData->RXbuffer[moteData->RXindex]=rxedChar;
	moteData->RXindex++;
     47a:	8c 81       	ldd	r24, Y+4	; 0x04
     47c:	8f 5f       	subi	r24, 0xFF	; 255
     47e:	8c 83       	std	Y+4, r24	; 0x04
	//sei();
	
	//serialPCtx(moteData->RXbuffer[moteData->RXindex-1]);
	
	
	if ((moteData->RXbuffer[moteData->RXindex-1] == 0x7E) && ((moteData->RXindex-1) > 0) )
     480:	ec 81       	ldd	r30, Y+4	; 0x04
     482:	f0 e0       	ldi	r31, 0x00	; 0
     484:	31 97       	sbiw	r30, 0x01	; 1
     486:	ec 0f       	add	r30, r28
     488:	fd 1f       	adc	r31, r29
     48a:	85 81       	ldd	r24, Z+5	; 0x05
     48c:	8e 37       	cpi	r24, 0x7E	; 126
     48e:	f9 f4       	brne	.+62     	; 0x4ce <InterruptReception+0x70>
     490:	8c 81       	ldd	r24, Y+4	; 0x04
     492:	90 e0       	ldi	r25, 0x00	; 0
     494:	01 97       	sbiw	r24, 0x01	; 1
     496:	18 16       	cp	r1, r24
     498:	19 06       	cpc	r1, r25
     49a:	cc f4       	brge	.+50     	; 0x4ce <InterruptReception+0x70>
	{
		//serialPCtxArray(moteData->RXbuffer,moteData->RXindex);
	
		//moteData->RXindex++;
		//serialPCtxArray(moteData->RXbuffer,moteData->RXindex);
	 moteData->decodeResult = hdlc_decode(moteData->hdlcDecoded, moteData->RXbuffer,&moteData->RXindex, sizeof(moteData->hdlcDecoded));
     49c:	20 e2       	ldi	r18, 0x20	; 32
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	ae 01       	movw	r20, r28
     4a2:	4c 5f       	subi	r20, 0xFC	; 252
     4a4:	5f 4f       	sbci	r21, 0xFF	; 255
     4a6:	be 01       	movw	r22, r28
     4a8:	6b 5f       	subi	r22, 0xFB	; 251
     4aa:	7f 4f       	sbci	r23, 0xFF	; 255
     4ac:	ce 01       	movw	r24, r28
     4ae:	8e 58       	subi	r24, 0x8E	; 142
     4b0:	9f 4f       	sbci	r25, 0xFF	; 255
     4b2:	0e 94 1f 05 	call	0xa3e	; 0xa3e <hdlc_decode>
     4b6:	9e 8f       	std	Y+30, r25	; 0x1e
     4b8:	8d 8f       	std	Y+29, r24	; 0x1d
		if (moteData->decodeResult>0)
     4ba:	8d 8d       	ldd	r24, Y+29	; 0x1d
     4bc:	9e 8d       	ldd	r25, Y+30	; 0x1e
     4be:	18 16       	cp	r1, r24
     4c0:	19 06       	cpc	r1, r25
     4c2:	14 f4       	brge	.+4      	; 0x4c8 <InterruptReception+0x6a>
		{
			moteData->validFrame=1;
     4c4:	81 e0       	ldi	r24, 0x01	; 1
     4c6:	8f 8f       	std	Y+31, r24	; 0x1f
			//serialPCtxArray(moteData->hdlcDecoded,moteData->decodeResult);
		}
		moteData->RXindex=0;
     4c8:	1c 82       	std	Y+4, r1	; 0x04
		return moteData->validFrame;
     4ca:	8f 8d       	ldd	r24, Y+31	; 0x1f
     4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <InterruptReception+0x74>
	}else{
		moteData->validFrame=0;
     4ce:	1f 8e       	std	Y+31, r1	; 0x1f
		return moteData->validFrame;}//moteData->RXindex++;}
     4d0:	8f 8d       	ldd	r24, Y+31	; 0x1f


}
     4d2:	df 91       	pop	r29
     4d4:	cf 91       	pop	r28
     4d6:	1f 91       	pop	r17
     4d8:	0f 91       	pop	r16
     4da:	08 95       	ret

000004dc <serialMoteSendArray>:
	}
}



void serialMoteSendArray(uint8_t* datos, uint8_t tam, MoteData_p moteData){
     4dc:	ef 92       	push	r14
     4de:	ff 92       	push	r15
     4e0:	0f 93       	push	r16
     4e2:	1f 93       	push	r17
     4e4:	cf 93       	push	r28
     4e6:	df 93       	push	r29
     4e8:	e6 2e       	mov	r14, r22
     4ea:	8a 01       	movw	r16, r20
	//send many bytes
	for (uint8_t i=0;i<tam;i++)
     4ec:	66 23       	and	r22, r22
     4ee:	59 f0       	breq	.+22     	; 0x506 <serialMoteSendArray+0x2a>
     4f0:	c8 2f       	mov	r28, r24
     4f2:	d9 2f       	mov	r29, r25
     4f4:	f1 2c       	mov	r15, r1
	{
		//serialMoteSend(datos[i]);
		moteData->serialMoteSend(datos[i]);
     4f6:	d8 01       	movw	r26, r16
     4f8:	ed 91       	ld	r30, X+
     4fa:	fc 91       	ld	r31, X
     4fc:	89 91       	ld	r24, Y+
     4fe:	09 95       	icall



void serialMoteSendArray(uint8_t* datos, uint8_t tam, MoteData_p moteData){
	//send many bytes
	for (uint8_t i=0;i<tam;i++)
     500:	f3 94       	inc	r15
     502:	fe 10       	cpse	r15, r14
     504:	f8 cf       	rjmp	.-16     	; 0x4f6 <serialMoteSendArray+0x1a>
	{
		//serialMoteSend(datos[i]);
		moteData->serialMoteSend(datos[i]);
	}
	
}
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	1f 91       	pop	r17
     50c:	0f 91       	pop	r16
     50e:	ff 90       	pop	r15
     510:	ef 90       	pop	r14
     512:	08 95       	ret

00000514 <compareBuffer>:
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     514:	44 23       	and	r20, r20
     516:	89 f0       	breq	.+34     	; 0x53a <compareBuffer+0x26>
     518:	28 2f       	mov	r18, r24
     51a:	e6 2f       	mov	r30, r22
     51c:	f7 2f       	mov	r31, r23
     51e:	a8 2f       	mov	r26, r24
     520:	b9 2f       	mov	r27, r25
	
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     522:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i=0;i<tam;i++)
	{
		//if (datos[i]==datos2[i])
		if (datos[i]==pgm_read_byte(&(datos2[i])))
     524:	8d 91       	ld	r24, X+
     526:	94 91       	lpm	r25, Z
     528:	89 13       	cpse	r24, r25
     52a:	01 c0       	rjmp	.+2      	; 0x52e <compareBuffer+0x1a>
		{
			comparacion++;
     52c:	3f 5f       	subi	r19, 0xFF	; 255
     52e:	31 96       	adiw	r30, 0x01	; 1
     530:	8a 2f       	mov	r24, r26
     532:	82 1b       	sub	r24, r18
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     534:	84 17       	cp	r24, r20
     536:	b0 f3       	brcs	.-20     	; 0x524 <compareBuffer+0x10>
     538:	01 c0       	rjmp	.+2      	; 0x53c <compareBuffer+0x28>
	
	
}

uint8_t compareBuffer(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     53a:	30 e0       	ldi	r19, 0x00	; 0
		{
			comparacion++;
		}
	}
	
	if (comparacion>=tam)
     53c:	81 e0       	ldi	r24, 0x01	; 1
     53e:	34 17       	cp	r19, r20
     540:	08 f4       	brcc	.+2      	; 0x544 <compareBuffer+0x30>
     542:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}else return 0;
	
	
	
}
     544:	08 95       	ret

00000546 <MoteInitialization>:
}




void MoteInitialization( MoteData_p moteData){
     546:	ef 92       	push	r14
     548:	ff 92       	push	r15
     54a:	0f 93       	push	r16
     54c:	1f 93       	push	r17
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
     552:	ec 01       	movw	r28, r24

while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     554:	20 e0       	ldi	r18, 0x00	; 0
     556:	4f ef       	ldi	r20, 0xFF	; 255
     558:	5f ef       	ldi	r21, 0xFF	; 255
     55a:	60 e0       	ldi	r22, 0x00	; 0
     55c:	70 e0       	ldi	r23, 0x00	; 0
     55e:	80 91 d7 07 	lds	r24, 0x07D7
     562:	90 91 d8 07 	lds	r25, 0x07D8
     566:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     56a:	81 30       	cpi	r24, 0x01	; 1
     56c:	99 f7       	brne	.-26     	; 0x554 <MoteInitialization+0xe>
	moteData->validFrame=0;
     56e:	1f 8e       	std	Y+31, r1	; 0x1f
	moteData->hdlcDecoded[2]=0x08;
     570:	88 e0       	ldi	r24, 0x08	; 8
     572:	fe 01       	movw	r30, r28
     574:	ec 58       	subi	r30, 0x8C	; 140
     576:	ff 4f       	sbci	r31, 0xFF	; 255
     578:	80 83       	st	Z, r24
	if (compareBuffer(moteData->hdlcDecoded,bootEvent,moteData->decodeResult))
     57a:	4d 8d       	ldd	r20, Y+29	; 0x1d
     57c:	5e 8d       	ldd	r21, Y+30	; 0x1e
     57e:	8e 01       	movw	r16, r28
     580:	0e 58       	subi	r16, 0x8E	; 142
     582:	1f 4f       	sbci	r17, 0xFF	; 255
     584:	6f e6       	ldi	r22, 0x6F	; 111
     586:	71 e0       	ldi	r23, 0x01	; 1
     588:	c8 01       	movw	r24, r16
     58a:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     58e:	88 23       	and	r24, r24
     590:	b1 f0       	breq	.+44     	; 0x5be <MoteInitialization+0x78>
	{
		//serialPCtx(0x00);
		
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     592:	22 e5       	ldi	r18, 0x52	; 82
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	44 e0       	ldi	r20, 0x04	; 4
     598:	50 e0       	ldi	r21, 0x00	; 0
     59a:	6b e6       	ldi	r22, 0x6B	; 107
     59c:	71 e0       	ldi	r23, 0x01	; 1
     59e:	7e 01       	movw	r14, r28
     5a0:	80 e2       	ldi	r24, 0x20	; 32
     5a2:	e8 0e       	add	r14, r24
     5a4:	f1 1c       	adc	r15, r1
     5a6:	c7 01       	movw	r24, r14
     5a8:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     5ac:	fe 01       	movw	r30, r28
     5ae:	ee 56       	subi	r30, 0x6E	; 110
     5b0:	ff 4f       	sbci	r31, 0xFF	; 255
     5b2:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     5b4:	ae 01       	movw	r20, r28
     5b6:	68 2f       	mov	r22, r24
     5b8:	c7 01       	movw	r24, r14
     5ba:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtxArray(moteData->hdlcOutput,moteData->sizeToSend);
	
	}
	//_delay_ms(100);
	moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,joinCommand,sizeof(joinCommand),sizeof(moteData->hdlcOutput));
     5be:	7e 01       	movw	r14, r28
     5c0:	80 e2       	ldi	r24, 0x20	; 32
     5c2:	e8 0e       	add	r14, r24
     5c4:	f1 1c       	adc	r15, r1
     5c6:	22 e5       	ldi	r18, 0x52	; 82
     5c8:	30 e0       	ldi	r19, 0x00	; 0
     5ca:	43 e0       	ldi	r20, 0x03	; 3
     5cc:	50 e0       	ldi	r21, 0x00	; 0
     5ce:	68 e6       	ldi	r22, 0x68	; 104
     5d0:	71 e0       	ldi	r23, 0x01	; 1
     5d2:	c7 01       	movw	r24, r14
     5d4:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     5d8:	fe 01       	movw	r30, r28
     5da:	ee 56       	subi	r30, 0x6E	; 110
     5dc:	ff 4f       	sbci	r31, 0xFF	; 255
     5de:	80 83       	st	Z, r24
	serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     5e0:	ae 01       	movw	r20, r28
     5e2:	68 2f       	mov	r22, r24
     5e4:	c7 01       	movw	r24, r14
     5e6:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     5ea:	20 e0       	ldi	r18, 0x00	; 0
     5ec:	4f ef       	ldi	r20, 0xFF	; 255
     5ee:	5f ef       	ldi	r21, 0xFF	; 255
     5f0:	60 e0       	ldi	r22, 0x00	; 0
     5f2:	70 e0       	ldi	r23, 0x00	; 0
     5f4:	80 91 d7 07 	lds	r24, 0x07D7
     5f8:	90 91 d8 07 	lds	r25, 0x07D8
     5fc:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     600:	81 30       	cpi	r24, 0x01	; 1
     602:	99 f7       	brne	.-26     	; 0x5ea <MoteInitialization+0xa4>
	moteData->validFrame=0;
     604:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,joinACK,moteData->decodeResult))
     606:	4d 8d       	ldd	r20, Y+29	; 0x1d
     608:	5e 8d       	ldd	r21, Y+30	; 0x1e
     60a:	64 e6       	ldi	r22, 0x64	; 100
     60c:	71 e0       	ldi	r23, 0x01	; 1
     60e:	c8 01       	movw	r24, r16
     610:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     614:	88 23       	and	r24, r24
     616:	91 f0       	breq	.+36     	; 0x63c <MoteInitialization+0xf6>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,joinACK,sizeof(joinACK),sizeof(moteData->hdlcOutput));
     618:	22 e5       	ldi	r18, 0x52	; 82
     61a:	30 e0       	ldi	r19, 0x00	; 0
     61c:	44 e0       	ldi	r20, 0x04	; 4
     61e:	50 e0       	ldi	r21, 0x00	; 0
     620:	64 e6       	ldi	r22, 0x64	; 100
     622:	71 e0       	ldi	r23, 0x01	; 1
     624:	c7 01       	movw	r24, r14
     626:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     62a:	fe 01       	movw	r30, r28
     62c:	ee 56       	subi	r30, 0x6E	; 110
     62e:	ff 4f       	sbci	r31, 0xFF	; 255
     630:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     632:	ae 01       	movw	r20, r28
     634:	68 2f       	mov	r22, r24
     636:	c7 01       	movw	r24, r14
     638:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x01);
	}
	
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     63c:	20 e0       	ldi	r18, 0x00	; 0
     63e:	4f ef       	ldi	r20, 0xFF	; 255
     640:	5f ef       	ldi	r21, 0xFF	; 255
     642:	60 e0       	ldi	r22, 0x00	; 0
     644:	70 e0       	ldi	r23, 0x00	; 0
     646:	80 91 d7 07 	lds	r24, 0x07D7
     64a:	90 91 d8 07 	lds	r25, 0x07D8
     64e:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     652:	81 30       	cpi	r24, 0x01	; 1
     654:	99 f7       	brne	.-26     	; 0x63c <MoteInitialization+0xf6>
	moteData->validFrame=0;
     656:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,moteSearchingEvent,moteData->decodeResult))
     658:	4d 8d       	ldd	r20, Y+29	; 0x1d
     65a:	5e 8d       	ldd	r21, Y+30	; 0x1e
     65c:	68 e5       	ldi	r22, 0x58	; 88
     65e:	71 e0       	ldi	r23, 0x01	; 1
     660:	c8 01       	movw	r24, r16
     662:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     666:	88 23       	and	r24, r24
     668:	91 f0       	breq	.+36     	; 0x68e <MoteInitialization+0x148>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     66a:	22 e5       	ldi	r18, 0x52	; 82
     66c:	30 e0       	ldi	r19, 0x00	; 0
     66e:	44 e0       	ldi	r20, 0x04	; 4
     670:	50 e0       	ldi	r21, 0x00	; 0
     672:	6b e6       	ldi	r22, 0x6B	; 107
     674:	71 e0       	ldi	r23, 0x01	; 1
     676:	c7 01       	movw	r24, r14
     678:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     67c:	fe 01       	movw	r30, r28
     67e:	ee 56       	subi	r30, 0x6E	; 110
     680:	ff 4f       	sbci	r31, 0xFF	; 255
     682:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     684:	ae 01       	movw	r20, r28
     686:	68 2f       	mov	r22, r24
     688:	c7 01       	movw	r24, r14
     68a:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x02);
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     68e:	20 e0       	ldi	r18, 0x00	; 0
     690:	4f ef       	ldi	r20, 0xFF	; 255
     692:	5f ef       	ldi	r21, 0xFF	; 255
     694:	60 e0       	ldi	r22, 0x00	; 0
     696:	70 e0       	ldi	r23, 0x00	; 0
     698:	80 91 d7 07 	lds	r24, 0x07D7
     69c:	90 91 d8 07 	lds	r25, 0x07D8
     6a0:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     6a4:	81 30       	cpi	r24, 0x01	; 1
     6a6:	99 f7       	brne	.-26     	; 0x68e <MoteInitialization+0x148>
	moteData->validFrame=0;
     6a8:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,negotiatingEvent,moteData->decodeResult))
     6aa:	4d 8d       	ldd	r20, Y+29	; 0x1d
     6ac:	5e 8d       	ldd	r21, Y+30	; 0x1e
     6ae:	6c e4       	ldi	r22, 0x4C	; 76
     6b0:	71 e0       	ldi	r23, 0x01	; 1
     6b2:	c8 01       	movw	r24, r16
     6b4:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     6b8:	88 23       	and	r24, r24
     6ba:	91 f0       	breq	.+36     	; 0x6e0 <MoteInitialization+0x19a>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     6bc:	22 e5       	ldi	r18, 0x52	; 82
     6be:	30 e0       	ldi	r19, 0x00	; 0
     6c0:	44 e0       	ldi	r20, 0x04	; 4
     6c2:	50 e0       	ldi	r21, 0x00	; 0
     6c4:	6b e6       	ldi	r22, 0x6B	; 107
     6c6:	71 e0       	ldi	r23, 0x01	; 1
     6c8:	c7 01       	movw	r24, r14
     6ca:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     6ce:	fe 01       	movw	r30, r28
     6d0:	ee 56       	subi	r30, 0x6E	; 110
     6d2:	ff 4f       	sbci	r31, 0xFF	; 255
     6d4:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     6d6:	ae 01       	movw	r20, r28
     6d8:	68 2f       	mov	r22, r24
     6da:	c7 01       	movw	r24, r14
     6dc:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x03);
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     6e0:	20 e0       	ldi	r18, 0x00	; 0
     6e2:	4f ef       	ldi	r20, 0xFF	; 255
     6e4:	5f ef       	ldi	r21, 0xFF	; 255
     6e6:	60 e0       	ldi	r22, 0x00	; 0
     6e8:	70 e0       	ldi	r23, 0x00	; 0
     6ea:	80 91 d7 07 	lds	r24, 0x07D7
     6ee:	90 91 d8 07 	lds	r25, 0x07D8
     6f2:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     6f6:	81 30       	cpi	r24, 0x01	; 1
     6f8:	99 f7       	brne	.-26     	; 0x6e0 <MoteInitialization+0x19a>
	moteData->validFrame=0;
     6fa:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,alarmEvent,moteData->decodeResult))
     6fc:	4d 8d       	ldd	r20, Y+29	; 0x1d
     6fe:	5e 8d       	ldd	r21, Y+30	; 0x1e
     700:	60 e4       	ldi	r22, 0x40	; 64
     702:	71 e0       	ldi	r23, 0x01	; 1
     704:	c8 01       	movw	r24, r16
     706:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     70a:	88 23       	and	r24, r24
     70c:	91 f0       	breq	.+36     	; 0x732 <MoteInitialization+0x1ec>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     70e:	22 e5       	ldi	r18, 0x52	; 82
     710:	30 e0       	ldi	r19, 0x00	; 0
     712:	44 e0       	ldi	r20, 0x04	; 4
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	6b e6       	ldi	r22, 0x6B	; 107
     718:	71 e0       	ldi	r23, 0x01	; 1
     71a:	c7 01       	movw	r24, r14
     71c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     720:	fe 01       	movw	r30, r28
     722:	ee 56       	subi	r30, 0x6E	; 110
     724:	ff 4f       	sbci	r31, 0xFF	; 255
     726:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     728:	ae 01       	movw	r20, r28
     72a:	68 2f       	mov	r22, r24
     72c:	c7 01       	movw	r24, r14
     72e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x04);
		
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) !=  pdTRUE);
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	4f ef       	ldi	r20, 0xFF	; 255
     736:	5f ef       	ldi	r21, 0xFF	; 255
     738:	60 e0       	ldi	r22, 0x00	; 0
     73a:	70 e0       	ldi	r23, 0x00	; 0
     73c:	80 91 d7 07 	lds	r24, 0x07D7
     740:	90 91 d8 07 	lds	r25, 0x07D8
     744:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     748:	81 30       	cpi	r24, 0x01	; 1
     74a:	99 f7       	brne	.-26     	; 0x732 <MoteInitialization+0x1ec>
	moteData->validFrame=0;
     74c:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,operationalEvent,moteData->decodeResult))
     74e:	4d 8d       	ldd	r20, Y+29	; 0x1d
     750:	5e 8d       	ldd	r21, Y+30	; 0x1e
     752:	64 e3       	ldi	r22, 0x34	; 52
     754:	71 e0       	ldi	r23, 0x01	; 1
     756:	c8 01       	movw	r24, r16
     758:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     75c:	88 23       	and	r24, r24
     75e:	91 f0       	breq	.+36     	; 0x784 <MoteInitialization+0x23e>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,eventACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     760:	22 e5       	ldi	r18, 0x52	; 82
     762:	30 e0       	ldi	r19, 0x00	; 0
     764:	44 e0       	ldi	r20, 0x04	; 4
     766:	50 e0       	ldi	r21, 0x00	; 0
     768:	6b e6       	ldi	r22, 0x6B	; 107
     76a:	71 e0       	ldi	r23, 0x01	; 1
     76c:	c7 01       	movw	r24, r14
     76e:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     772:	fe 01       	movw	r30, r28
     774:	ee 56       	subi	r30, 0x6E	; 110
     776:	ff 4f       	sbci	r31, 0xFF	; 255
     778:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     77a:	ae 01       	movw	r20, r28
     77c:	68 2f       	mov	r22, r24
     77e:	c7 01       	movw	r24, r14
     780:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
		//serialPCtx(0x05);
		
	}
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     784:	20 e0       	ldi	r18, 0x00	; 0
     786:	4f ef       	ldi	r20, 0xFF	; 255
     788:	5f ef       	ldi	r21, 0xFF	; 255
     78a:	60 e0       	ldi	r22, 0x00	; 0
     78c:	70 e0       	ldi	r23, 0x00	; 0
     78e:	80 91 d7 07 	lds	r24, 0x07D7
     792:	90 91 d8 07 	lds	r25, 0x07D8
     796:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     79a:	81 30       	cpi	r24, 0x01	; 1
     79c:	99 f7       	brne	.-26     	; 0x784 <MoteInitialization+0x23e>
	moteData->validFrame=0;
     79e:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,svcIndication,moteData->decodeResult))
     7a0:	4d 8d       	ldd	r20, Y+29	; 0x1d
     7a2:	5e 8d       	ldd	r21, Y+30	; 0x1e
     7a4:	65 e2       	ldi	r22, 0x25	; 37
     7a6:	71 e0       	ldi	r23, 0x01	; 1
     7a8:	c8 01       	movw	r24, r16
     7aa:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
     7ae:	88 23       	and	r24, r24
     7b0:	91 f0       	breq	.+36     	; 0x7d6 <MoteInitialization+0x290>
	{
		moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,serviceACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     7b2:	22 e5       	ldi	r18, 0x52	; 82
     7b4:	30 e0       	ldi	r19, 0x00	; 0
     7b6:	44 e0       	ldi	r20, 0x04	; 4
     7b8:	50 e0       	ldi	r21, 0x00	; 0
     7ba:	61 e2       	ldi	r22, 0x21	; 33
     7bc:	71 e0       	ldi	r23, 0x01	; 1
     7be:	c7 01       	movw	r24, r14
     7c0:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     7c4:	fe 01       	movw	r30, r28
     7c6:	ee 56       	subi	r30, 0x6E	; 110
     7c8:	ff 4f       	sbci	r31, 0xFF	; 255
     7ca:	80 83       	st	Z, r24
		serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     7cc:	ae 01       	movw	r20, r28
     7ce:	68 2f       	mov	r22, r24
     7d0:	c7 01       	movw	r24, r14
     7d2:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	{
		//return to state machine
	}


}
     7d6:	df 91       	pop	r29
     7d8:	cf 91       	pop	r28
     7da:	1f 91       	pop	r17
     7dc:	0f 91       	pop	r16
     7de:	ff 90       	pop	r15
     7e0:	ef 90       	pop	r14
     7e2:	08 95       	ret

000007e4 <MoteSvcInitialization>:

void MoteSvcInitialization( MoteData_p moteData){
     7e4:	cf 92       	push	r12
     7e6:	df 92       	push	r13
     7e8:	ef 92       	push	r14
     7ea:	ff 92       	push	r15
     7ec:	0f 93       	push	r16
     7ee:	1f 93       	push	r17
     7f0:	cf 93       	push	r28
     7f2:	df 93       	push	r29
     7f4:	ec 01       	movw	r28, r24

// requesting service
	
	moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,setService,sizeof(setService),sizeof(moteData->hdlcOutput));
     7f6:	8c 01       	movw	r16, r24
     7f8:	00 5e       	subi	r16, 0xE0	; 224
     7fa:	1f 4f       	sbci	r17, 0xFF	; 255
     7fc:	22 e5       	ldi	r18, 0x52	; 82
     7fe:	30 e0       	ldi	r19, 0x00	; 0
     800:	4d e0       	ldi	r20, 0x0D	; 13
     802:	50 e0       	ldi	r21, 0x00	; 0
     804:	64 e1       	ldi	r22, 0x14	; 20
     806:	71 e0       	ldi	r23, 0x01	; 1
     808:	c8 01       	movw	r24, r16
     80a:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     80e:	fe 01       	movw	r30, r28
     810:	ee 56       	subi	r30, 0x6E	; 110
     812:	ff 4f       	sbci	r31, 0xFF	; 255
     814:	80 83       	st	Z, r24
	serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     816:	ae 01       	movw	r20, r28
     818:	68 2f       	mov	r22, r24
     81a:	c8 01       	movw	r24, r16
     81c:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     820:	20 e0       	ldi	r18, 0x00	; 0
     822:	4f ef       	ldi	r20, 0xFF	; 255
     824:	5f ef       	ldi	r21, 0xFF	; 255
     826:	60 e0       	ldi	r22, 0x00	; 0
     828:	70 e0       	ldi	r23, 0x00	; 0
     82a:	80 91 d7 07 	lds	r24, 0x07D7
     82e:	90 91 d8 07 	lds	r25, 0x07D8
     832:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     836:	81 30       	cpi	r24, 0x01	; 1
     838:	99 f7       	brne	.-26     	; 0x820 <MoteSvcInitialization+0x3c>
	moteData->validFrame=0;
     83a:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer(moteData->hdlcDecoded,setServiceACK,moteData->decodeResult))
     83c:	4d 8d       	ldd	r20, Y+29	; 0x1d
     83e:	5e 8d       	ldd	r21, Y+30	; 0x1e
     840:	6e e0       	ldi	r22, 0x0E	; 14
     842:	71 e0       	ldi	r23, 0x01	; 1
     844:	ce 01       	movw	r24, r28
     846:	8e 58       	subi	r24, 0x8E	; 142
     848:	9f 4f       	sbci	r25, 0xFF	; 255
     84a:	0e 94 8a 02 	call	0x514	; 0x514 <compareBuffer>
	{
		while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
		moteData->validFrame=0;
		//en este punto esperamos un svcIndication con el tiempo pedido, puede llegar uno de delayed response
		//asi que todos los respondes con el serviceACK y checamos si se nos otorgo el tiempo
			moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,serviceACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     84e:	6e 01       	movw	r12, r28
     850:	82 e9       	ldi	r24, 0x92	; 146
     852:	c8 0e       	add	r12, r24
     854:	d1 1c       	adc	r13, r1
			serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
			
		if (moteData->hdlcDecoded[3]==0x03)//delayed response
     856:	7e 01       	movw	r14, r28
     858:	e5 e7       	ldi	r30, 0x75	; 117
     85a:	ee 0e       	add	r14, r30
     85c:	f1 1c       	adc	r15, r1
	}
	
	uint8_t serviceReady=0;
	while (!serviceReady)
	{
		while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     85e:	20 e0       	ldi	r18, 0x00	; 0
     860:	4f ef       	ldi	r20, 0xFF	; 255
     862:	5f ef       	ldi	r21, 0xFF	; 255
     864:	60 e0       	ldi	r22, 0x00	; 0
     866:	70 e0       	ldi	r23, 0x00	; 0
     868:	80 91 d7 07 	lds	r24, 0x07D7
     86c:	90 91 d8 07 	lds	r25, 0x07D8
     870:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     874:	81 30       	cpi	r24, 0x01	; 1
     876:	99 f7       	brne	.-26     	; 0x85e <MoteSvcInitialization+0x7a>
		moteData->validFrame=0;
     878:	1f 8e       	std	Y+31, r1	; 0x1f
		//en este punto esperamos un svcIndication con el tiempo pedido, puede llegar uno de delayed response
		//asi que todos los respondes con el serviceACK y checamos si se nos otorgo el tiempo
			moteData->sizeToSend=(int8_t)hdlc_encode(moteData->hdlcOutput,serviceACK,sizeof(eventACK),sizeof(moteData->hdlcOutput));
     87a:	22 e5       	ldi	r18, 0x52	; 82
     87c:	30 e0       	ldi	r19, 0x00	; 0
     87e:	44 e0       	ldi	r20, 0x04	; 4
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	61 e2       	ldi	r22, 0x21	; 33
     884:	71 e0       	ldi	r23, 0x01	; 1
     886:	c8 01       	movw	r24, r16
     888:	0e 94 0d 06 	call	0xc1a	; 0xc1a <hdlc_encode>
     88c:	f6 01       	movw	r30, r12
     88e:	80 83       	st	Z, r24
			serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     890:	ae 01       	movw	r20, r28
     892:	68 2f       	mov	r22, r24
     894:	c8 01       	movw	r24, r16
     896:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
			
		if (moteData->hdlcDecoded[3]==0x03)//delayed response
     89a:	f7 01       	movw	r30, r14
     89c:	80 81       	ld	r24, Z
     89e:	83 30       	cpi	r24, 0x03	; 3
     8a0:	f1 f2       	breq	.-68     	; 0x85e <MoteSvcInitialization+0x7a>
		{
			serviceReady=0;
		}
		else{
			if (moteData->hdlcDecoded[3]==0x00)//created
     8a2:	80 81       	ld	r24, Z
     8a4:	81 11       	cpse	r24, r1
     8a6:	db cf       	rjmp	.-74     	; 0x85e <MoteSvcInitialization+0x7a>
				serviceReady=1;
				//serialPCtx(0xF0);
			}
		}
	}
}
     8a8:	df 91       	pop	r29
     8aa:	cf 91       	pop	r28
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	ff 90       	pop	r15
     8b2:	ef 90       	pop	r14
     8b4:	df 90       	pop	r13
     8b6:	cf 90       	pop	r12
     8b8:	08 95       	ret

000008ba <compareBuffer_D>:
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     8ba:	44 23       	and	r20, r20
     8bc:	81 f0       	breq	.+32     	; 0x8de <compareBuffer_D+0x24>
     8be:	28 2f       	mov	r18, r24
     8c0:	a6 2f       	mov	r26, r22
     8c2:	b7 2f       	mov	r27, r23
     8c4:	e8 2f       	mov	r30, r24
     8c6:	f9 2f       	mov	r31, r25
	
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     8c8:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i=0;i<tam;i++)
	{
		//if (datos[i]==datos2[i])
		if (datos[i]==(datos2[i]))
     8ca:	91 91       	ld	r25, Z+
     8cc:	8d 91       	ld	r24, X+
     8ce:	98 13       	cpse	r25, r24
     8d0:	01 c0       	rjmp	.+2      	; 0x8d4 <compareBuffer_D+0x1a>
		{
			comparacion++;
     8d2:	3f 5f       	subi	r19, 0xFF	; 255
     8d4:	8e 2f       	mov	r24, r30
     8d6:	82 1b       	sub	r24, r18
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
	for (uint8_t i=0;i<tam;i++)
     8d8:	84 17       	cp	r24, r20
     8da:	b8 f3       	brcs	.-18     	; 0x8ca <compareBuffer_D+0x10>
     8dc:	01 c0       	rjmp	.+2      	; 0x8e0 <compareBuffer_D+0x26>
	
}


uint8_t compareBuffer_D(uint8_t* datos, uint8_t*datos2,uint8_t tam){
	uint8_t comparacion=0;
     8de:	30 e0       	ldi	r19, 0x00	; 0
		{
			comparacion++;
		}
	}
	
	if (comparacion>=tam)
     8e0:	81 e0       	ldi	r24, 0x01	; 1
     8e2:	34 17       	cp	r19, r20
     8e4:	08 f4       	brcc	.+2      	; 0x8e8 <compareBuffer_D+0x2e>
     8e6:	80 e0       	ldi	r24, 0x00	; 0
		return 1;
	}else return 0;
	
	
	
}
     8e8:	08 95       	ret

000008ea <sendData>:
		moteData->serialMoteSend(datos[i]);
	}
	
}

uint8_t sendData(uint8_t* data, uint8_t tam, uint8_t svcId, MoteData_p moteData){
     8ea:	df 92       	push	r13
     8ec:	ef 92       	push	r14
     8ee:	ff 92       	push	r15
     8f0:	0f 93       	push	r16
     8f2:	1f 93       	push	r17
     8f4:	cf 93       	push	r28
     8f6:	df 93       	push	r29
     8f8:	d6 2e       	mov	r13, r22
     8fa:	14 2f       	mov	r17, r20
     8fc:	e9 01       	movw	r28, r18
	
	
	moteData->sizeToSend=0;
     8fe:	79 01       	movw	r14, r18
     900:	22 e9       	ldi	r18, 0x92	; 146
     902:	e2 0e       	add	r14, r18
     904:	f1 1c       	adc	r15, r1
     906:	f7 01       	movw	r30, r14
     908:	10 82       	st	Z, r1
	uint8_t newTam = 12+tam;
	//uint8_t* arr;
	static uint8_t arr[BUFFER_LENGHT];
	//arr = (uint8_t*)malloc(newTam);
	memcpy(arr,sendComand,11);
     90a:	2b e0       	ldi	r18, 0x0B	; 11
     90c:	e6 e0       	ldi	r30, 0x06	; 6
     90e:	f1 e0       	ldi	r31, 0x01	; 1
     910:	a6 e2       	ldi	r26, 0x26	; 38
     912:	b1 e0       	ldi	r27, 0x01	; 1
     914:	01 90       	ld	r0, Z+
     916:	0d 92       	st	X+, r0
     918:	2a 95       	dec	r18
     91a:	e1 f7       	brne	.-8      	; 0x914 <__stack+0x15>
	arr[1]=newTam-3;//menos el header
     91c:	29 e0       	ldi	r18, 0x09	; 9
     91e:	26 0f       	add	r18, r22
     920:	20 93 27 01 	sts	0x0127, r18
	arr[11]=tam;//tanaio del payload
     924:	60 93 31 01 	sts	0x0131, r22
	memcpy(&arr[12],data,tam);
     928:	46 2f       	mov	r20, r22
     92a:	50 e0       	ldi	r21, 0x00	; 0
     92c:	bc 01       	movw	r22, r24
     92e:	82 e3       	ldi	r24, 0x32	; 50
     930:	91 e0       	ldi	r25, 0x01	; 1
     932:	0e 94 31 13 	call	0x2662	; 0x2662 <memcpy>
	arr[5]=svcId;
     936:	10 93 2b 01 	sts	0x012B, r17
	moteData->sizeToSend=(int8_t)hdlc_encode_D(moteData->hdlcOutput,arr,newTam,sizeof(moteData->hdlcOutput));
     93a:	8e 01       	movw	r16, r28
     93c:	00 5e       	subi	r16, 0xE0	; 224
     93e:	1f 4f       	sbci	r17, 0xFF	; 255

uint8_t sendData(uint8_t* data, uint8_t tam, uint8_t svcId, MoteData_p moteData){
	
	
	moteData->sizeToSend=0;
	uint8_t newTam = 12+tam;
     940:	4c e0       	ldi	r20, 0x0C	; 12
     942:	4d 0d       	add	r20, r13
	memcpy(arr,sendComand,11);
	arr[1]=newTam-3;//menos el header
	arr[11]=tam;//tanaio del payload
	memcpy(&arr[12],data,tam);
	arr[5]=svcId;
	moteData->sizeToSend=(int8_t)hdlc_encode_D(moteData->hdlcOutput,arr,newTam,sizeof(moteData->hdlcOutput));
     944:	50 e0       	ldi	r21, 0x00	; 0
     946:	22 e5       	ldi	r18, 0x52	; 82
     948:	30 e0       	ldi	r19, 0x00	; 0
     94a:	66 e2       	ldi	r22, 0x26	; 38
     94c:	71 e0       	ldi	r23, 0x01	; 1
     94e:	c8 01       	movw	r24, r16
     950:	0e 94 b0 05 	call	0xb60	; 0xb60 <hdlc_encode_D>
     954:	f7 01       	movw	r30, r14
     956:	80 83       	st	Z, r24
	serialMoteSendArray(moteData->hdlcOutput,moteData->sizeToSend,moteData);
     958:	ae 01       	movw	r20, r28
     95a:	68 2f       	mov	r22, r24
     95c:	c8 01       	movw	r24, r16
     95e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <serialMoteSendArray>
	//free(arr);
	while(xSemaphoreTake(frameHandle,0xFFFF) != pdTRUE);
     962:	20 e0       	ldi	r18, 0x00	; 0
     964:	4f ef       	ldi	r20, 0xFF	; 255
     966:	5f ef       	ldi	r21, 0xFF	; 255
     968:	60 e0       	ldi	r22, 0x00	; 0
     96a:	70 e0       	ldi	r23, 0x00	; 0
     96c:	80 91 d7 07 	lds	r24, 0x07D7
     970:	90 91 d8 07 	lds	r25, 0x07D8
     974:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
     978:	81 30       	cpi	r24, 0x01	; 1
     97a:	99 f7       	brne	.-26     	; 0x962 <__stack+0x63>
	moteData->validFrame=0;
     97c:	1f 8e       	std	Y+31, r1	; 0x1f
	if (compareBuffer_D(moteData->hdlcDecoded,sendACK,moteData->decodeResult))
     97e:	4d 8d       	ldd	r20, Y+29	; 0x1d
     980:	5e 8d       	ldd	r21, Y+30	; 0x1e
     982:	6a e0       	ldi	r22, 0x0A	; 10
     984:	71 e0       	ldi	r23, 0x01	; 1
     986:	ce 01       	movw	r24, r28
     988:	8e 58       	subi	r24, 0x8E	; 142
     98a:	9f 4f       	sbci	r25, 0xFF	; 255
     98c:	0e 94 5d 04 	call	0x8ba	; 0x8ba <compareBuffer_D>
     990:	91 e0       	ldi	r25, 0x01	; 1
     992:	81 11       	cpse	r24, r1
     994:	01 c0       	rjmp	.+2      	; 0x998 <__stack+0x99>
     996:	90 e0       	ldi	r25, 0x00	; 0
	
	
	
	
	
}
     998:	89 2f       	mov	r24, r25
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	1f 91       	pop	r17
     9a0:	0f 91       	pop	r16
     9a2:	ff 90       	pop	r15
     9a4:	ef 90       	pop	r14
     9a6:	df 90       	pop	r13
     9a8:	08 95       	ret

000009aa <fcs_fcs16>:
 */
INT16U fcs_fcs16(INT16U fcs, INT8U data)
{
  // return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff];
   
   return (fcs >> 8) ^ pgm_read_word(&fcstab[(fcs ^ data) & 0xff]);
     9aa:	fc 01       	movw	r30, r24
     9ac:	e6 27       	eor	r30, r22
     9ae:	ff 27       	eor	r31, r31
     9b0:	ee 0f       	add	r30, r30
     9b2:	ff 1f       	adc	r31, r31
     9b4:	e5 58       	subi	r30, 0x85	; 133
     9b6:	fe 4f       	sbci	r31, 0xFE	; 254
     9b8:	25 91       	lpm	r18, Z+
     9ba:	34 91       	lpm	r19, Z
     9bc:	89 2f       	mov	r24, r25
     9be:	99 27       	eor	r25, r25
}
     9c0:	82 27       	eor	r24, r18
     9c2:	93 27       	eor	r25, r19
     9c4:	08 95       	ret

000009c6 <fcs_calcFcs>:
 * @param len - length of buffer
 * 
 * @return INT16U - calculated FCS16
 */
INT16U fcs_calcFcs(INT8U* buf, INT32U len)
{
     9c6:	0f 93       	push	r16
     9c8:	1f 93       	push	r17
     9ca:	cf 93       	push	r28
     9cc:	df 93       	push	r29
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     9ce:	61 15       	cp	r22, r1
     9d0:	71 05       	cpc	r23, r1
     9d2:	79 f0       	breq	.+30     	; 0x9f2 <fcs_calcFcs+0x2c>
     9d4:	ec 01       	movw	r28, r24
     9d6:	8c 01       	movw	r16, r24
     9d8:	06 0f       	add	r16, r22
     9da:	17 1f       	adc	r17, r23
INT16U fcs_calcFcs(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     9dc:	8f ef       	ldi	r24, 0xFF	; 255
     9de:	9f ef       	ldi	r25, 0xFF	; 255
   for (i = 0; i < len; i++) {
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, pgm_read_byte(&buf[i]));
     9e0:	fe 01       	movw	r30, r28
     9e2:	64 91       	lpm	r22, Z
     9e4:	0e 94 d5 04 	call	0x9aa	; 0x9aa <fcs_fcs16>
     9e8:	21 96       	adiw	r28, 0x01	; 1
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     9ea:	c0 17       	cp	r28, r16
     9ec:	d1 07       	cpc	r29, r17
     9ee:	c1 f7       	brne	.-16     	; 0x9e0 <fcs_calcFcs+0x1a>
     9f0:	02 c0       	rjmp	.+4      	; 0x9f6 <fcs_calcFcs+0x30>
INT16U fcs_calcFcs(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     9f2:	8f ef       	ldi	r24, 0xFF	; 255
     9f4:	9f ef       	ldi	r25, 0xFF	; 255
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, pgm_read_byte(&buf[i]));
   }

   return (fcs ^ 0xffff); /* return complement */
}
     9f6:	80 95       	com	r24
     9f8:	90 95       	com	r25
     9fa:	df 91       	pop	r29
     9fc:	cf 91       	pop	r28
     9fe:	1f 91       	pop	r17
     a00:	0f 91       	pop	r16
     a02:	08 95       	ret

00000a04 <fcs_calcFcs_D>:
 * @param len - length of buffer
 * 
 * @return INT16U - calculated FCS16
 */
INT16U fcs_calcFcs_D(INT8U* buf, INT32U len)
{
     a04:	0f 93       	push	r16
     a06:	1f 93       	push	r17
     a08:	cf 93       	push	r28
     a0a:	df 93       	push	r29
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     a0c:	61 15       	cp	r22, r1
     a0e:	71 05       	cpc	r23, r1
     a10:	69 f0       	breq	.+26     	; 0xa2c <fcs_calcFcs_D+0x28>
     a12:	ec 01       	movw	r28, r24
     a14:	8c 01       	movw	r16, r24
     a16:	06 0f       	add	r16, r22
     a18:	17 1f       	adc	r17, r23
INT16U fcs_calcFcs_D(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     a1a:	8f ef       	ldi	r24, 0xFF	; 255
     a1c:	9f ef       	ldi	r25, 0xFF	; 255
   for (i = 0; i < len; i++) {
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, buf[i]);
     a1e:	69 91       	ld	r22, Y+
     a20:	0e 94 d5 04 	call	0x9aa	; 0x9aa <fcs_fcs16>
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
   for (i = 0; i < len; i++) {
     a24:	c0 17       	cp	r28, r16
     a26:	d1 07       	cpc	r29, r17
     a28:	d1 f7       	brne	.-12     	; 0xa1e <fcs_calcFcs_D+0x1a>
     a2a:	02 c0       	rjmp	.+4      	; 0xa30 <fcs_calcFcs_D+0x2c>
INT16U fcs_calcFcs_D(INT8U* buf, INT32U len)
{
   INT16U fcs;
   INT32U i;

   fcs = FCS_INITIAL_FCS16;
     a2c:	8f ef       	ldi	r24, 0xFF	; 255
     a2e:	9f ef       	ldi	r25, 0xFF	; 255
      //fcs = fcs_fcs16(fcs, buf[i]);
	  fcs = fcs_fcs16(fcs, buf[i]);
   }

   return (fcs ^ 0xffff); /* return complement */
}
     a30:	80 95       	com	r24
     a32:	90 95       	com	r25
     a34:	df 91       	pop	r29
     a36:	cf 91       	pop	r28
     a38:	1f 91       	pop	r17
     a3a:	0f 91       	pop	r16
     a3c:	08 95       	ret

00000a3e <hdlc_decode>:
 * Returns:
 *    > 0: length of decoded data
 *    < 0: error code
 */
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
     a3e:	4f 92       	push	r4
     a40:	5f 92       	push	r5
     a42:	6f 92       	push	r6
     a44:	7f 92       	push	r7
     a46:	8f 92       	push	r8
     a48:	9f 92       	push	r9
     a4a:	af 92       	push	r10
     a4c:	bf 92       	push	r11
     a4e:	cf 92       	push	r12
     a50:	df 92       	push	r13
     a52:	ef 92       	push	r14
     a54:	ff 92       	push	r15
     a56:	0f 93       	push	r16
     a58:	1f 93       	push	r17
     a5a:	cf 93       	push	r28
     a5c:	df 93       	push	r29
     a5e:	4c 01       	movw	r8, r24
     a60:	6a 01       	movw	r12, r20
     a62:	59 01       	movw	r10, r18
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
     a64:	fa 01       	movw	r30, r20
     a66:	80 81       	ld	r24, Z
     a68:	88 23       	and	r24, r24
     a6a:	09 f4       	brne	.+2      	; 0xa6e <hdlc_decode+0x30>
     a6c:	4d c0       	rjmp	.+154    	; 0xb08 <hdlc_decode+0xca>
     a6e:	06 2f       	mov	r16, r22
     a70:	17 2f       	mov	r17, r23
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
     a72:	40 e0       	ldi	r20, 0x00	; 0
{
   INT32U i;
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
     a74:	50 e0       	ldi	r21, 0x00	; 0
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
   INT32U i;
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
   INT8U fOpenFlag = 0;
     a76:	71 2c       	mov	r7, r1
 */
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
   INT32U i;
   INT32U wIdx = 0;
   INT16U calcCrc = FCS_INITIAL_FCS16;
     a78:	8f ef       	ldi	r24, 0xFF	; 255
     a7a:	9f ef       	ldi	r25, 0xFF	; 255
 *    < 0: error code
 */
INT32S hdlc_decode(INT8U* pOut, INT8U* pIn, INT8U* inLen, INT32U maxOutLen)
{
   INT32U i;
   INT32U wIdx = 0;
     a7c:	e1 2c       	mov	r14, r1
     a7e:	f1 2c       	mov	r15, r1
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
     a80:	c0 e0       	ldi	r28, 0x00	; 0
     a82:	d0 e0       	ldi	r29, 0x00	; 0
               return HDLC_ERR_CRC;
            }
         }
      }
      else if (curByte == HDLC_ESCAPE_BYTE) {
         fEscape = 1;
     a84:	66 24       	eor	r6, r6
     a86:	63 94       	inc	r6
            }
            if (wIdx > maxOutLen) {
               return HDLC_ERR_LEN;
            }
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
            wIdx++;
     a88:	51 2c       	mov	r5, r1
      else {
         if (fOpenFlag) {
            fDataStart = 1;
            if (fEscape) {
               fEscape = 0;
               pOut[wIdx] = (curByte ^ 0x20);
     a8a:	68 94       	set
     a8c:	44 24       	eor	r4, r4
     a8e:	45 f8       	bld	r4, 5
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
      curByte = pIn[i];
     a90:	f8 01       	movw	r30, r16
     a92:	21 91       	ld	r18, Z+
     a94:	8f 01       	movw	r16, r30
      if (curByte == HDLC_FRAME_BYTE) {
     a96:	2e 37       	cpi	r18, 0x7E	; 126
     a98:	69 f4       	brne	.+26     	; 0xab4 <hdlc_decode+0x76>
         if (!fOpenFlag) {
     a9a:	77 20       	and	r7, r7
     a9c:	51 f1       	breq	.+84     	; 0xaf2 <hdlc_decode+0xb4>
            fOpenFlag = 1;
         }
         else if (fDataStart) {
     a9e:	55 23       	and	r21, r21
     aa0:	59 f1       	breq	.+86     	; 0xaf8 <hdlc_decode+0xba>
            // output amount of input read
            *inLen = i+1;
     aa2:	cf 5f       	subi	r28, 0xFF	; 255
     aa4:	f6 01       	movw	r30, r12
     aa6:	c0 83       	st	Z, r28
            if (calcCrc == FCS_GOOD_FCS16) {
     aa8:	88 3b       	cpi	r24, 0xB8	; 184
     aaa:	90 4f       	sbci	r25, 0xF0	; 240
     aac:	81 f5       	brne	.+96     	; 0xb0e <hdlc_decode+0xd0>
               // return length excluding CRC bytes
               return (wIdx - 2);
     aae:	c7 01       	movw	r24, r14
     ab0:	02 97       	sbiw	r24, 0x02	; 2
     ab2:	35 c0       	rjmp	.+106    	; 0xb1e <hdlc_decode+0xe0>
            else {
               return HDLC_ERR_CRC;
            }
         }
      }
      else if (curByte == HDLC_ESCAPE_BYTE) {
     ab4:	2d 37       	cpi	r18, 0x7D	; 125
     ab6:	f9 f0       	breq	.+62     	; 0xaf6 <hdlc_decode+0xb8>
         fEscape = 1;
      }
      else {
         if (fOpenFlag) {
     ab8:	77 20       	and	r7, r7
     aba:	f1 f0       	breq	.+60     	; 0xaf8 <hdlc_decode+0xba>
            fDataStart = 1;
            if (fEscape) {
     abc:	44 23       	and	r20, r20
     abe:	31 f0       	breq	.+12     	; 0xacc <hdlc_decode+0x8e>
               fEscape = 0;
               pOut[wIdx] = (curByte ^ 0x20);
     ac0:	f4 01       	movw	r30, r8
     ac2:	ee 0d       	add	r30, r14
     ac4:	ff 1d       	adc	r31, r15
     ac6:	24 25       	eor	r18, r4
     ac8:	20 83       	st	Z, r18
     aca:	04 c0       	rjmp	.+8      	; 0xad4 <hdlc_decode+0x96>
            }
            else {
               pOut[wIdx] = curByte;
     acc:	f4 01       	movw	r30, r8
     ace:	ee 0d       	add	r30, r14
     ad0:	ff 1d       	adc	r31, r15
     ad2:	20 83       	st	Z, r18
            }
            if (wIdx > maxOutLen) {
     ad4:	ae 14       	cp	r10, r14
     ad6:	bf 04       	cpc	r11, r15
     ad8:	e8 f0       	brcs	.+58     	; 0xb14 <hdlc_decode+0xd6>
               return HDLC_ERR_LEN;
            }
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
     ada:	f4 01       	movw	r30, r8
     adc:	ee 0d       	add	r30, r14
     ade:	ff 1d       	adc	r31, r15
     ae0:	60 81       	ld	r22, Z
     ae2:	0e 94 d5 04 	call	0x9aa	; 0x9aa <fcs_fcs16>
            wIdx++;
     ae6:	2f ef       	ldi	r18, 0xFF	; 255
     ae8:	e2 1a       	sub	r14, r18
     aea:	f2 0a       	sbc	r15, r18
     aec:	45 2d       	mov	r20, r5
      else if (curByte == HDLC_ESCAPE_BYTE) {
         fEscape = 1;
      }
      else {
         if (fOpenFlag) {
            fDataStart = 1;
     aee:	56 2d       	mov	r21, r6
     af0:	03 c0       	rjmp	.+6      	; 0xaf8 <hdlc_decode+0xba>
   
   for (i = 0; i < *inLen; i++) {
      curByte = pIn[i];
      if (curByte == HDLC_FRAME_BYTE) {
         if (!fOpenFlag) {
            fOpenFlag = 1;
     af2:	76 2c       	mov	r7, r6
     af4:	01 c0       	rjmp	.+2      	; 0xaf8 <hdlc_decode+0xba>
               return HDLC_ERR_CRC;
            }
         }
      }
      else if (curByte == HDLC_ESCAPE_BYTE) {
         fEscape = 1;
     af6:	46 2d       	mov	r20, r6
   INT8U fOpenFlag = 0;
   INT8U fDataStart = 0;
   INT8U curByte;
   INT8U fEscape = 0;
   
   for (i = 0; i < *inLen; i++) {
     af8:	21 96       	adiw	r28, 0x01	; 1
     afa:	f6 01       	movw	r30, r12
     afc:	20 81       	ld	r18, Z
     afe:	30 e0       	ldi	r19, 0x00	; 0
     b00:	c2 17       	cp	r28, r18
     b02:	d3 07       	cpc	r29, r19
     b04:	28 f2       	brcs	.-118    	; 0xa90 <hdlc_decode+0x52>
     b06:	09 c0       	rjmp	.+18     	; 0xb1a <hdlc_decode+0xdc>
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
            wIdx++;
         }
      }
   }
   return HDLC_ERR_FRAME;
     b08:	8e ef       	ldi	r24, 0xFE	; 254
     b0a:	9f ef       	ldi	r25, 0xFF	; 255
     b0c:	08 c0       	rjmp	.+16     	; 0xb1e <hdlc_decode+0xe0>
            if (calcCrc == FCS_GOOD_FCS16) {
               // return length excluding CRC bytes
               return (wIdx - 2);
            }
            else {
               return HDLC_ERR_CRC;
     b0e:	8f ef       	ldi	r24, 0xFF	; 255
     b10:	9f ef       	ldi	r25, 0xFF	; 255
     b12:	05 c0       	rjmp	.+10     	; 0xb1e <hdlc_decode+0xe0>
            }
            else {
               pOut[wIdx] = curByte;
            }
            if (wIdx > maxOutLen) {
               return HDLC_ERR_LEN;
     b14:	8d ef       	ldi	r24, 0xFD	; 253
     b16:	9f ef       	ldi	r25, 0xFF	; 255
     b18:	02 c0       	rjmp	.+4      	; 0xb1e <hdlc_decode+0xe0>
            calcCrc = fcs_fcs16(calcCrc, pOut[wIdx]);
            wIdx++;
         }
      }
   }
   return HDLC_ERR_FRAME;
     b1a:	8e ef       	ldi	r24, 0xFE	; 254
     b1c:	9f ef       	ldi	r25, 0xFF	; 255
}
     b1e:	df 91       	pop	r29
     b20:	cf 91       	pop	r28
     b22:	1f 91       	pop	r17
     b24:	0f 91       	pop	r16
     b26:	ff 90       	pop	r15
     b28:	ef 90       	pop	r14
     b2a:	df 90       	pop	r13
     b2c:	cf 90       	pop	r12
     b2e:	bf 90       	pop	r11
     b30:	af 90       	pop	r10
     b32:	9f 90       	pop	r9
     b34:	8f 90       	pop	r8
     b36:	7f 90       	pop	r7
     b38:	6f 90       	pop	r6
     b3a:	5f 90       	pop	r5
     b3c:	4f 90       	pop	r4
     b3e:	08 95       	ret

00000b40 <hdlc_stuffByte>:
 * Returns:
 *    Number of bytes written to destination (1 or 2 if escaped) 
 */
INT8U hdlc_stuffByte(INT8U* pDest, INT8U byte)
{
   if (byte == HDLC_FRAME_BYTE || byte == HDLC_ESCAPE_BYTE) {
     b40:	23 e8       	ldi	r18, 0x83	; 131
     b42:	26 0f       	add	r18, r22
     b44:	22 30       	cpi	r18, 0x02	; 2
     b46:	40 f4       	brcc	.+16     	; 0xb58 <hdlc_stuffByte+0x18>
      *pDest = HDLC_ESCAPE_BYTE;
     b48:	2d e7       	ldi	r18, 0x7D	; 125
     b4a:	fc 01       	movw	r30, r24
     b4c:	20 83       	st	Z, r18
      *(pDest+1) = byte ^ 0x20;
     b4e:	20 e2       	ldi	r18, 0x20	; 32
     b50:	62 27       	eor	r22, r18
     b52:	61 83       	std	Z+1, r22	; 0x01
      return 2;
     b54:	82 e0       	ldi	r24, 0x02	; 2
     b56:	08 95       	ret
   }
   else {
      *pDest = byte;
     b58:	fc 01       	movw	r30, r24
     b5a:	60 83       	st	Z, r22
      return 1;
     b5c:	81 e0       	ldi	r24, 0x01	; 1
   }
}
     b5e:	08 95       	ret

00000b60 <hdlc_encode_D>:
 *    maxOutLen: Max output length  
 * Returns:
 *    Number of bytes written to destination 
 */
INT32S hdlc_encode_D(INT8U* pOut, INT8U* pIn, INT32U inLen, INT32U maxOutLen)
{
     b60:	8f 92       	push	r8
     b62:	9f 92       	push	r9
     b64:	af 92       	push	r10
     b66:	bf 92       	push	r11
     b68:	cf 92       	push	r12
     b6a:	df 92       	push	r13
     b6c:	ef 92       	push	r14
     b6e:	ff 92       	push	r15
     b70:	0f 93       	push	r16
     b72:	1f 93       	push	r17
     b74:	cf 93       	push	r28
     b76:	df 93       	push	r29
     b78:	7c 01       	movw	r14, r24
     b7a:	5b 01       	movw	r10, r22
     b7c:	ea 01       	movw	r28, r20
     b7e:	69 01       	movw	r12, r18
   INT16U wIdx = 0;
   INT16U txFcs = 0;
   INT8U fcsHi, fcsLo;

   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);
     b80:	ba 01       	movw	r22, r20
     b82:	c5 01       	movw	r24, r10
     b84:	0e 94 02 05 	call	0xa04	; 0xa04 <fcs_calcFcs_D>
     b88:	88 2e       	mov	r8, r24
     b8a:	99 2e       	mov	r9, r25

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     b8c:	8e e7       	ldi	r24, 0x7E	; 126
     b8e:	f7 01       	movw	r30, r14
     b90:	80 83       	st	Z, r24
   for (i = 0; i < inLen; i++) {
     b92:	20 97       	sbiw	r28, 0x00	; 0
     b94:	c9 f0       	breq	.+50     	; 0xbc8 <hdlc_encode_D+0x68>
     b96:	85 01       	movw	r16, r10
     b98:	ac 0e       	add	r10, r28
     b9a:	bd 1e       	adc	r11, r29

   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     b9c:	c1 e0       	ldi	r28, 0x01	; 1
     b9e:	d0 e0       	ldi	r29, 0x00	; 0
   for (i = 0; i < inLen; i++) {
      wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  //wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
     ba0:	f4 e0       	ldi	r31, 0x04	; 4
     ba2:	cf 1a       	sub	r12, r31
     ba4:	d1 08       	sbc	r13, r1
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
      wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
     ba6:	f8 01       	movw	r30, r16
     ba8:	61 91       	ld	r22, Z+
     baa:	8f 01       	movw	r16, r30
     bac:	c7 01       	movw	r24, r14
     bae:	8c 0f       	add	r24, r28
     bb0:	9d 1f       	adc	r25, r29
     bb2:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     bb6:	c8 0f       	add	r28, r24
     bb8:	d1 1d       	adc	r29, r1
	  //wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
     bba:	cc 16       	cp	r12, r28
     bbc:	dd 06       	cpc	r13, r29
     bbe:	f0 f0       	brcs	.+60     	; 0xbfc <hdlc_encode_D+0x9c>
   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     bc0:	0a 15       	cp	r16, r10
     bc2:	1b 05       	cpc	r17, r11
     bc4:	81 f7       	brne	.-32     	; 0xba6 <hdlc_encode_D+0x46>
     bc6:	02 c0       	rjmp	.+4      	; 0xbcc <hdlc_encode_D+0x6c>

   // calculate the FCS
   txFcs = fcs_calcFcs_D(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     bc8:	c1 e0       	ldi	r28, 0x01	; 1
     bca:	d0 e0       	ldi	r29, 0x00	; 0
   }
   
   // append CRC
   fcsHi = (txFcs & 0xFF);
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
     bcc:	68 2d       	mov	r22, r8
     bce:	c7 01       	movw	r24, r14
     bd0:	8c 0f       	add	r24, r28
     bd2:	9d 1f       	adc	r25, r29
     bd4:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     bd8:	c8 0f       	add	r28, r24
     bda:	d1 1d       	adc	r29, r1
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
     bdc:	69 2d       	mov	r22, r9
     bde:	c7 01       	movw	r24, r14
     be0:	8c 0f       	add	r24, r28
     be2:	9d 1f       	adc	r25, r29
     be4:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     be8:	c8 0f       	add	r28, r24
     bea:	d1 1d       	adc	r29, r1
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     bec:	f7 01       	movw	r30, r14
     bee:	ec 0f       	add	r30, r28
     bf0:	fd 1f       	adc	r31, r29
     bf2:	8e e7       	ldi	r24, 0x7E	; 126
     bf4:	80 83       	st	Z, r24
     bf6:	ce 01       	movw	r24, r28
     bf8:	01 96       	adiw	r24, 0x01	; 1
   return wIdx;
     bfa:	02 c0       	rjmp	.+4      	; 0xc00 <hdlc_encode_D+0xa0>
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
      wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  //wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
         return HDLC_ERR_LEN; 
     bfc:	8d ef       	ldi	r24, 0xFD	; 253
     bfe:	9f ef       	ldi	r25, 0xFF	; 255
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   return wIdx;
}
     c00:	df 91       	pop	r29
     c02:	cf 91       	pop	r28
     c04:	1f 91       	pop	r17
     c06:	0f 91       	pop	r16
     c08:	ff 90       	pop	r15
     c0a:	ef 90       	pop	r14
     c0c:	df 90       	pop	r13
     c0e:	cf 90       	pop	r12
     c10:	bf 90       	pop	r11
     c12:	af 90       	pop	r10
     c14:	9f 90       	pop	r9
     c16:	8f 90       	pop	r8
     c18:	08 95       	ret

00000c1a <hdlc_encode>:
 *    maxOutLen: Max output length  
 * Returns:
 *    Number of bytes written to destination 
 */
INT32S hdlc_encode(INT8U* pOut, INT8U* pIn, INT32U inLen, INT32U maxOutLen)
{
     c1a:	8f 92       	push	r8
     c1c:	9f 92       	push	r9
     c1e:	af 92       	push	r10
     c20:	bf 92       	push	r11
     c22:	cf 92       	push	r12
     c24:	df 92       	push	r13
     c26:	ef 92       	push	r14
     c28:	ff 92       	push	r15
     c2a:	0f 93       	push	r16
     c2c:	1f 93       	push	r17
     c2e:	cf 93       	push	r28
     c30:	df 93       	push	r29
     c32:	7c 01       	movw	r14, r24
     c34:	5b 01       	movw	r10, r22
     c36:	ea 01       	movw	r28, r20
     c38:	69 01       	movw	r12, r18
   INT16U wIdx = 0;
   INT16U txFcs = 0;
   INT8U fcsHi, fcsLo;

   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);
     c3a:	ba 01       	movw	r22, r20
     c3c:	c5 01       	movw	r24, r10
     c3e:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <fcs_calcFcs>
     c42:	88 2e       	mov	r8, r24
     c44:	99 2e       	mov	r9, r25

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     c46:	8e e7       	ldi	r24, 0x7E	; 126
     c48:	f7 01       	movw	r30, r14
     c4a:	80 83       	st	Z, r24
   for (i = 0; i < inLen; i++) {
     c4c:	20 97       	sbiw	r28, 0x00	; 0
     c4e:	d1 f0       	breq	.+52     	; 0xc84 <hdlc_encode+0x6a>
     c50:	85 01       	movw	r16, r10
     c52:	ac 0e       	add	r10, r28
     c54:	bd 1e       	adc	r11, r29

   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     c56:	c1 e0       	ldi	r28, 0x01	; 1
     c58:	d0 e0       	ldi	r29, 0x00	; 0
   for (i = 0; i < inLen; i++) {
     // wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(&pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
     c5a:	f4 e0       	ldi	r31, 0x04	; 4
     c5c:	cf 1a       	sub	r12, r31
     c5e:	d1 08       	sbc	r13, r1

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     // wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(&pIn[i]));
     c60:	f8 01       	movw	r30, r16
     c62:	64 91       	lpm	r22, Z
     c64:	c7 01       	movw	r24, r14
     c66:	8c 0f       	add	r24, r28
     c68:	9d 1f       	adc	r25, r29
     c6a:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     c6e:	c8 0f       	add	r28, r24
     c70:	d1 1d       	adc	r29, r1
      if (wIdx > (maxOutLen - 4)) {
     c72:	cc 16       	cp	r12, r28
     c74:	dd 06       	cpc	r13, r29
     c76:	00 f1       	brcs	.+64     	; 0xcb8 <hdlc_encode+0x9e>
     c78:	0f 5f       	subi	r16, 0xFF	; 255
     c7a:	1f 4f       	sbci	r17, 0xFF	; 255
   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     c7c:	0a 15       	cp	r16, r10
     c7e:	1b 05       	cpc	r17, r11
     c80:	79 f7       	brne	.-34     	; 0xc60 <hdlc_encode+0x46>
     c82:	02 c0       	rjmp	.+4      	; 0xc88 <hdlc_encode+0x6e>

   // calculate the FCS
   txFcs = fcs_calcFcs(pIn, inLen);

   // stuff input into output buffer, escaping framing characters in input
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     c84:	c1 e0       	ldi	r28, 0x01	; 1
     c86:	d0 e0       	ldi	r29, 0x00	; 0
   }
   
   // append CRC
   fcsHi = (txFcs & 0xFF);
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
     c88:	68 2d       	mov	r22, r8
     c8a:	c7 01       	movw	r24, r14
     c8c:	8c 0f       	add	r24, r28
     c8e:	9d 1f       	adc	r25, r29
     c90:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     c94:	c8 0f       	add	r28, r24
     c96:	d1 1d       	adc	r29, r1
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
     c98:	69 2d       	mov	r22, r9
     c9a:	c7 01       	movw	r24, r14
     c9c:	8c 0f       	add	r24, r28
     c9e:	9d 1f       	adc	r25, r29
     ca0:	0e 94 a0 05 	call	0xb40	; 0xb40 <hdlc_stuffByte>
     ca4:	c8 0f       	add	r28, r24
     ca6:	d1 1d       	adc	r29, r1
   pOut[wIdx++] = HDLC_FRAME_BYTE;
     ca8:	f7 01       	movw	r30, r14
     caa:	ec 0f       	add	r30, r28
     cac:	fd 1f       	adc	r31, r29
     cae:	8e e7       	ldi	r24, 0x7E	; 126
     cb0:	80 83       	st	Z, r24
     cb2:	ce 01       	movw	r24, r28
     cb4:	01 96       	adiw	r24, 0x01	; 1
   return wIdx;
     cb6:	02 c0       	rjmp	.+4      	; 0xcbc <hdlc_encode+0xa2>
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   for (i = 0; i < inLen; i++) {
     // wIdx += hdlc_stuffByte(&pOut[wIdx], pIn[i]);
	  wIdx += hdlc_stuffByte(&pOut[wIdx], pgm_read_byte(&pIn[i]));
      if (wIdx > (maxOutLen - 4)) {
         return HDLC_ERR_LEN; 
     cb8:	8d ef       	ldi	r24, 0xFD	; 253
     cba:	9f ef       	ldi	r25, 0xFF	; 255
   fcsLo = ((txFcs >> 8) & 0xFF);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsHi);
   wIdx += hdlc_stuffByte(&pOut[wIdx], fcsLo);
   pOut[wIdx++] = HDLC_FRAME_BYTE;
   return wIdx;
}
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	1f 91       	pop	r17
     cc2:	0f 91       	pop	r16
     cc4:	ff 90       	pop	r15
     cc6:	ef 90       	pop	r14
     cc8:	df 90       	pop	r13
     cca:	cf 90       	pop	r12
     ccc:	bf 90       	pop	r11
     cce:	af 90       	pop	r10
     cd0:	9f 90       	pop	r9
     cd2:	8f 90       	pop	r8
     cd4:	08 95       	ret

00000cd6 <vLEDInit>:
{

	// Set LED_O as output pin

	//DDR_LED_O |= (1<<BIT_LED_O);
	DDR_LED_O |= 0xFF;
     cd6:	84 b1       	in	r24, 0x04	; 4
     cd8:	8f ef       	ldi	r24, 0xFF	; 255
     cda:	84 b9       	out	0x04, r24	; 4
     cdc:	08 95       	ret

00000cde <vLEDToggle>:

{

	//Toggle LED

	PORT_LED_O ^= (1<<BIT_LED_O);
     cde:	95 b1       	in	r25, 0x05	; 5
     ce0:	81 e0       	ldi	r24, 0x01	; 1
     ce2:	89 27       	eor	r24, r25
     ce4:	85 b9       	out	0x05, r24	; 5
     ce6:	08 95       	ret

00000ce8 <serialMoteReceive>:
	xSerialPutChar(NULL,tx,0x0010);
	
}

int8_t serialMoteReceive(void){
	return UDR0;
     ce8:	80 91 c6 00 	lds	r24, 0x00C6
}
     cec:	08 95       	ret

00000cee <xSerialPortInitMinimal>:



xComPortHandle xSerialPortInitMinimal( unsigned portBASE_TYPE uxQueueLength ){	
	
	portENTER_CRITICAL();
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	0f 92       	push	r0
	/* Create the queues used by the com test task. */
		//xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     cf4:	40 e0       	ldi	r20, 0x00	; 0
     cf6:	61 e0       	ldi	r22, 0x01	; 1
     cf8:	0e 94 9a 0c 	call	0x1934	; 0x1934 <xQueueGenericCreate>
     cfc:	90 93 67 01 	sts	0x0167, r25
     d00:	80 93 66 01 	sts	0x0166, r24
		UBRR0 = UBRRMOTE;
     d04:	83 e0       	ldi	r24, 0x03	; 3
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	90 93 c5 00 	sts	0x00C5, r25
     d0c:	80 93 c4 00 	sts	0x00C4, r24
		//UCSR0A = (1<<U2X0);
		UCSR0B = (1<<TXEN0)|(1<<RXEN0)|(1<<RXCIE0);                // enable receiver and transmitter
     d10:	88 e9       	ldi	r24, 0x98	; 152
     d12:	80 93 c1 00 	sts	0x00C1, r24
		UCSR0C = (1<<UCSZ00)|(1<<UCSZ01);   // 8bit data format
     d16:	86 e0       	ldi	r24, 0x06	; 6
     d18:	80 93 c2 00 	sts	0x00C2, r24
		//Enable interrupts for  TX later
		
	frameHandle = xSemaphoreCreateBinary();
     d1c:	43 e0       	ldi	r20, 0x03	; 3
     d1e:	60 e0       	ldi	r22, 0x00	; 0
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	0e 94 9a 0c 	call	0x1934	; 0x1934 <xQueueGenericCreate>
     d26:	90 93 d8 07 	sts	0x07D8, r25
     d2a:	80 93 d7 07 	sts	0x07D7, r24

	portEXIT_CRITICAL();
     d2e:	0f 90       	pop	r0
     d30:	0f be       	out	0x3f, r0	; 63

	instead just return NULL. */

	return NULL;

}
     d32:	80 e0       	ldi	r24, 0x00	; 0
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	08 95       	ret

00000d38 <xSerialPutChar>:



signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )

{
     d38:	cf 93       	push	r28
     d3a:	df 93       	push	r29
     d3c:	1f 92       	push	r1
     d3e:	cd b7       	in	r28, 0x3d	; 61
     d40:	de b7       	in	r29, 0x3e	; 62
     d42:	69 83       	std	Y+1, r22	; 0x01



	/* Return false if after the block time there is no room on the Tx queue. */

	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     d44:	20 e0       	ldi	r18, 0x00	; 0
     d46:	be 01       	movw	r22, r28
     d48:	6f 5f       	subi	r22, 0xFF	; 255
     d4a:	7f 4f       	sbci	r23, 0xFF	; 255
     d4c:	80 91 66 01 	lds	r24, 0x0166
     d50:	90 91 67 01 	lds	r25, 0x0167
     d54:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xQueueGenericSend>
     d58:	81 30       	cpi	r24, 0x01	; 1
     d5a:	31 f4       	brne	.+12     	; 0xd68 <xSerialPutChar+0x30>
	



	//vInterruptOn();
	UCSR0B |= (1<<UDRIE0);
     d5c:	e1 ec       	ldi	r30, 0xC1	; 193
     d5e:	f0 e0       	ldi	r31, 0x00	; 0
     d60:	90 81       	ld	r25, Z
     d62:	90 62       	ori	r25, 0x20	; 32
     d64:	90 83       	st	Z, r25
	return pdPASS;
     d66:	01 c0       	rjmp	.+2      	; 0xd6a <xSerialPutChar+0x32>
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )

	{
		

		return pdFAIL;
     d68:	80 e0       	ldi	r24, 0x00	; 0

	//vInterruptOn();
	UCSR0B |= (1<<UDRIE0);
	return pdPASS;

}
     d6a:	0f 90       	pop	r0
     d6c:	df 91       	pop	r29
     d6e:	cf 91       	pop	r28
     d70:	08 95       	ret

00000d72 <serialMoteSend>:

}

void serialMoteSend(int8_t tx){
	
	xSerialPutChar(NULL,tx,0x0010);
     d72:	40 e1       	ldi	r20, 0x10	; 16
     d74:	50 e0       	ldi	r21, 0x00	; 0
     d76:	68 2f       	mov	r22, r24
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	0e 94 9c 06 	call	0xd38	; 0xd38 <xSerialPutChar>
     d80:	08 95       	ret

00000d82 <__vector_18>:

/*-----------------------------------------------------------*/
/*-----------------------------------------------------------*/
ISR( USART_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART_RX_vect )
{
     d82:	1f 92       	push	r1
     d84:	0f 92       	push	r0
     d86:	0f b6       	in	r0, 0x3f	; 63
     d88:	0f 92       	push	r0
     d8a:	11 24       	eor	r1, r1
     d8c:	2f 93       	push	r18
     d8e:	3f 93       	push	r19
     d90:	4f 93       	push	r20
     d92:	5f 93       	push	r21
     d94:	6f 93       	push	r22
     d96:	7f 93       	push	r23
     d98:	8f 93       	push	r24
     d9a:	9f 93       	push	r25
     d9c:	af 93       	push	r26
     d9e:	bf 93       	push	r27
     da0:	ef 93       	push	r30
     da2:	ff 93       	push	r31

	may have a higher priority than the task we have interrupted. */
	//PORTB ^= (1<<PORTB1);
	
	
	if( InterruptReception(&moteData)){//check to see if a valid frame has been received
     da4:	89 ed       	ldi	r24, 0xD9	; 217
     da6:	97 e0       	ldi	r25, 0x07	; 7
     da8:	0e 94 2f 02 	call	0x45e	; 0x45e <InterruptReception>
     dac:	88 23       	and	r24, r24
     dae:	41 f0       	breq	.+16     	; 0xdc0 <__vector_18+0x3e>
		
		xSemaphoreGiveFromISR(frameHandle,NULL);
     db0:	60 e0       	ldi	r22, 0x00	; 0
     db2:	70 e0       	ldi	r23, 0x00	; 0
     db4:	80 91 d7 07 	lds	r24, 0x07D7
     db8:	90 91 d8 07 	lds	r25, 0x07D8
     dbc:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <xQueueGiveFromISR>

		taskYIELD();

	}

}
     dc0:	ff 91       	pop	r31
     dc2:	ef 91       	pop	r30
     dc4:	bf 91       	pop	r27
     dc6:	af 91       	pop	r26
     dc8:	9f 91       	pop	r25
     dca:	8f 91       	pop	r24
     dcc:	7f 91       	pop	r23
     dce:	6f 91       	pop	r22
     dd0:	5f 91       	pop	r21
     dd2:	4f 91       	pop	r20
     dd4:	3f 91       	pop	r19
     dd6:	2f 91       	pop	r18
     dd8:	0f 90       	pop	r0
     dda:	0f be       	out	0x3f, r0	; 63
     ddc:	0f 90       	pop	r0
     dde:	1f 90       	pop	r1
     de0:	18 95       	reti

00000de2 <__vector_19>:

/*-----------------------------------------------------------*/

ISR( USART_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART_UDRE_vect )
{
     de2:	1f 92       	push	r1
     de4:	0f 92       	push	r0
     de6:	0f b6       	in	r0, 0x3f	; 63
     de8:	0f 92       	push	r0
     dea:	11 24       	eor	r1, r1
     dec:	2f 93       	push	r18
     dee:	3f 93       	push	r19
     df0:	4f 93       	push	r20
     df2:	5f 93       	push	r21
     df4:	6f 93       	push	r22
     df6:	7f 93       	push	r23
     df8:	8f 93       	push	r24
     dfa:	9f 93       	push	r25
     dfc:	af 93       	push	r26
     dfe:	bf 93       	push	r27
     e00:	ef 93       	push	r30
     e02:	ff 93       	push	r31
     e04:	cf 93       	push	r28
     e06:	df 93       	push	r29
     e08:	1f 92       	push	r1
     e0a:	cd b7       	in	r28, 0x3d	; 61
     e0c:	de b7       	in	r29, 0x3e	; 62

signed char cChar, cTaskWoken;
PORTB |= (1<<PORTB2);
     e0e:	2a 9a       	sbi	0x05, 2	; 5

	if( xQueueReceiveFromISR( xCharsForTx, &cChar,NULL) == pdTRUE )
     e10:	40 e0       	ldi	r20, 0x00	; 0
     e12:	50 e0       	ldi	r21, 0x00	; 0
     e14:	be 01       	movw	r22, r28
     e16:	6f 5f       	subi	r22, 0xFF	; 255
     e18:	7f 4f       	sbci	r23, 0xFF	; 255
     e1a:	80 91 66 01 	lds	r24, 0x0166
     e1e:	90 91 67 01 	lds	r25, 0x0167
     e22:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xQueueReceiveFromISR>
     e26:	81 30       	cpi	r24, 0x01	; 1
     e28:	21 f4       	brne	.+8      	; 0xe32 <__vector_19+0x50>
	{
		/* Send the next character queued for Tx. */
    	UDR0 = cChar;
     e2a:	89 81       	ldd	r24, Y+1	; 0x01
     e2c:	80 93 c6 00 	sts	0x00C6, r24
     e30:	05 c0       	rjmp	.+10     	; 0xe3c <__vector_19+0x5a>
	}
	else
	{/* Queue empty, nothing to send. */
	//vInterruptOff();
	UCSR0B &= ~(1<<UDRIE0);		
     e32:	e1 ec       	ldi	r30, 0xC1	; 193
     e34:	f0 e0       	ldi	r31, 0x00	; 0
     e36:	80 81       	ld	r24, Z
     e38:	8f 7d       	andi	r24, 0xDF	; 223
     e3a:	80 83       	st	Z, r24
	}

}
     e3c:	0f 90       	pop	r0
     e3e:	df 91       	pop	r29
     e40:	cf 91       	pop	r28
     e42:	ff 91       	pop	r31
     e44:	ef 91       	pop	r30
     e46:	bf 91       	pop	r27
     e48:	af 91       	pop	r26
     e4a:	9f 91       	pop	r25
     e4c:	8f 91       	pop	r24
     e4e:	7f 91       	pop	r23
     e50:	6f 91       	pop	r22
     e52:	5f 91       	pop	r21
     e54:	4f 91       	pop	r20
     e56:	3f 91       	pop	r19
     e58:	2f 91       	pop	r18
     e5a:	0f 90       	pop	r0
     e5c:	0f be       	out	0x3f, r0	; 63
     e5e:	0f 90       	pop	r0
     e60:	1f 90       	pop	r1
     e62:	18 95       	reti

00000e64 <sendMoteData>:
	return UDR0;
}

uint8_t sendMoteData(uint8_t* data, uint8_t data_size){
	
	return sendData(data,data_size,serviceID,&moteData);
     e64:	29 ed       	ldi	r18, 0xD9	; 217
     e66:	37 e0       	ldi	r19, 0x07	; 7
     e68:	43 e0       	ldi	r20, 0x03	; 3
     e6a:	0e 94 75 04 	call	0x8ea	; 0x8ea <sendData>
	
	
}
     e6e:	08 95       	ret

00000e70 <configureMote>:


void configureMote(void){
	
	
	moteData.serialMoteSend=serialMoteSend; 
     e70:	89 eb       	ldi	r24, 0xB9	; 185
     e72:	96 e0       	ldi	r25, 0x06	; 6
     e74:	90 93 da 07 	sts	0x07DA, r25
     e78:	80 93 d9 07 	sts	0x07D9, r24
	moteData.serialMoteReceive=serialMoteReceive;
     e7c:	84 e7       	ldi	r24, 0x74	; 116
     e7e:	96 e0       	ldi	r25, 0x06	; 6
     e80:	90 93 dc 07 	sts	0x07DC, r25
     e84:	80 93 db 07 	sts	0x07DB, r24
	
	DDRC = (1<<PORTC0)|(1<<PORTC1); // select pc0 and pc1 as outputs
     e88:	83 e0       	ldi	r24, 0x03	; 3
     e8a:	87 b9       	out	0x07, r24	; 7
	//pc0 drives the reset on the whmt, pc1 is the led indication
	
	PORTC = (1<<PORTC2);//Pull up on the button, reset the mote
     e8c:	84 e0       	ldi	r24, 0x04	; 4
     e8e:	88 b9       	out	0x08, r24	; 8
	
	vTaskDelay(200);
     e90:	88 ec       	ldi	r24, 0xC8	; 200
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskDelay>
	
	PORTC |= (1<<PORTC0);// turn on the mote
     e98:	40 9a       	sbi	0x08, 0	; 8
	
	MoteInitialization(&moteData);
     e9a:	89 ed       	ldi	r24, 0xD9	; 217
     e9c:	97 e0       	ldi	r25, 0x07	; 7
     e9e:	0e 94 a3 02 	call	0x546	; 0x546 <MoteInitialization>
	MoteSvcInitialization(&moteData);
     ea2:	89 ed       	ldi	r24, 0xD9	; 217
     ea4:	97 e0       	ldi	r25, 0x07	; 7
     ea6:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <MoteSvcInitialization>
	
	PORTC |= (1<<PORTC1); //turn on LED, the Mote is ready to send
     eaa:	41 9a       	sbi	0x08, 1	; 8
     eac:	08 95       	ret

00000eae <TWI_Master_Initialise>:
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
	TWSR = 0; //no prescaler
     eae:	10 92 b9 00 	sts	0x00B9, r1
	TWBR = 29;// 100 Khz                             //
     eb2:	8d e1       	ldi	r24, 0x1D	; 29
     eb4:	80 93 b8 00 	sts	0x00B8, r24
     eb8:	08 95       	ret

00000eba <TWI_Start_Transceiver_With_Data>:
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
	//return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
	return twi_done;
     eba:	20 91 6a 01 	lds	r18, 0x016A
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
	unsigned char temp;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     ebe:	21 11       	cpse	r18, r1
     ec0:	fc cf       	rjmp	.-8      	; 0xeba <TWI_Start_Transceiver_With_Data>

	TWI_msgSize = msgSize;                        // Number of data to transmit.
     ec2:	60 93 6c 08 	sts	0x086C, r22
	TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
     ec6:	fc 01       	movw	r30, r24
     ec8:	20 81       	ld	r18, Z
     eca:	20 93 6d 08 	sts	0x086D, r18
	if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
     ece:	20 81       	ld	r18, Z
     ed0:	20 fd       	sbrc	r18, 0
     ed2:	12 c0       	rjmp	.+36     	; 0xef8 <TWI_Start_Transceiver_With_Data+0x3e>
	{
		for ( temp = 1; temp < msgSize; temp++ )
     ed4:	62 30       	cpi	r22, 0x02	; 2
     ed6:	80 f0       	brcs	.+32     	; 0xef8 <TWI_Start_Transceiver_With_Data+0x3e>
     ed8:	31 96       	adiw	r30, 0x01	; 1
     eda:	9c 01       	movw	r18, r24
     edc:	02 96       	adiw	r24, 0x02	; 2
     ede:	62 50       	subi	r22, 0x02	; 2
     ee0:	86 0f       	add	r24, r22
     ee2:	91 1d       	adc	r25, r1
     ee4:	df 01       	movw	r26, r30
     ee6:	a2 1b       	sub	r26, r18
     ee8:	b3 0b       	sbc	r27, r19
		TWI_buf[ temp ] = msg[ temp ];
     eea:	41 91       	ld	r20, Z+
     eec:	a3 59       	subi	r26, 0x93	; 147
     eee:	b7 4f       	sbci	r27, 0xF7	; 247
     ef0:	4c 93       	st	X, r20

	TWI_msgSize = msgSize;                        // Number of data to transmit.
	TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	{
		for ( temp = 1; temp < msgSize; temp++ )
     ef2:	e8 17       	cp	r30, r24
     ef4:	f9 07       	cpc	r31, r25
     ef6:	b1 f7       	brne	.-20     	; 0xee4 <TWI_Start_Transceiver_With_Data+0x2a>
		TWI_buf[ temp ] = msg[ temp ];
	}
	TWI_statusReg.all = 0;
     ef8:	10 92 69 01 	sts	0x0169, r1
	TWI_state         = TWI_NO_STATE ;
     efc:	88 ef       	ldi	r24, 0xF8	; 248
     efe:	80 93 00 01 	sts	0x0100, r24
	TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     f02:	85 ea       	ldi	r24, 0xA5	; 165
     f04:	80 93 bc 00 	sts	0x00BC, r24
	(1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
	(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
	(0<<TWWC);                             //
	twi_done=1;
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	80 93 6a 01 	sts	0x016A, r24
     f0e:	08 95       	ret

00000f10 <TWI_Get_Data_From_Transceiver>:
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
	//return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
	return twi_done;
     f10:	20 91 6a 01 	lds	r18, 0x016A
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
	unsigned char i;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     f14:	21 11       	cpse	r18, r1
     f16:	fc cf       	rjmp	.-8      	; 0xf10 <TWI_Get_Data_From_Transceiver>

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.
     f18:	20 91 69 01 	lds	r18, 0x0169
     f1c:	20 ff       	sbrs	r18, 0
     f1e:	0e c0       	rjmp	.+28     	; 0xf3c <TWI_Get_Data_From_Transceiver+0x2c>
	{
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     f20:	66 23       	and	r22, r22
     f22:	61 f0       	breq	.+24     	; 0xf3c <TWI_Get_Data_From_Transceiver+0x2c>
     f24:	e8 2f       	mov	r30, r24
     f26:	f9 2f       	mov	r31, r25
     f28:	80 e0       	ldi	r24, 0x00	; 0
     f2a:	90 e0       	ldi	r25, 0x00	; 0
		{
			msg[ i ] = TWI_buf[ i ];
     f2c:	dc 01       	movw	r26, r24
     f2e:	a3 59       	subi	r26, 0x93	; 147
     f30:	b7 4f       	sbci	r27, 0xF7	; 247
     f32:	2c 91       	ld	r18, X
     f34:	21 93       	st	Z+, r18
     f36:	01 96       	adiw	r24, 0x01	; 1

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.
	{
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     f38:	86 17       	cp	r24, r22
     f3a:	c0 f3       	brcs	.-16     	; 0xf2c <TWI_Get_Data_From_Transceiver+0x1c>
		{
			msg[ i ] = TWI_buf[ i ];
		}
	}
	return( TWI_statusReg.lastTransOK );
     f3c:	80 91 69 01 	lds	r24, 0x0169
}
     f40:	81 70       	andi	r24, 0x01	; 1
     f42:	08 95       	ret

00000f44 <__vector_24>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR (TWI_vect) __attribute__ ((hot, flatten));
ISR (TWI_vect)
{
     f44:	1f 92       	push	r1
     f46:	0f 92       	push	r0
     f48:	0f b6       	in	r0, 0x3f	; 63
     f4a:	0f 92       	push	r0
     f4c:	11 24       	eor	r1, r1
     f4e:	2f 93       	push	r18
     f50:	3f 93       	push	r19
     f52:	8f 93       	push	r24
     f54:	9f 93       	push	r25
     f56:	af 93       	push	r26
     f58:	bf 93       	push	r27
     f5a:	ef 93       	push	r30
     f5c:	ff 93       	push	r31
	static unsigned char TWI_bufPtr=0;
	
	switch (TWSR)
     f5e:	80 91 b9 00 	lds	r24, 0x00B9
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	fc 01       	movw	r30, r24
     f66:	38 97       	sbiw	r30, 0x08	; 8
     f68:	e1 35       	cpi	r30, 0x51	; 81
     f6a:	f1 05       	cpc	r31, r1
     f6c:	08 f0       	brcs	.+2      	; 0xf70 <__vector_24+0x2c>
     f6e:	65 c0       	rjmp	.+202    	; 0x103a <__vector_24+0xf6>
     f70:	ec 5c       	subi	r30, 0xCC	; 204
     f72:	ff 4f       	sbci	r31, 0xFF	; 255
     f74:	0c 94 2b 13 	jmp	0x2656	; 0x2656 <__tablejump2__>
	{
		case TWI_START:             // START has been transmitted
		case TWI_REP_START:         // Repeated START has been transmitted
		TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
     f78:	10 92 68 01 	sts	0x0168, r1
		case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
		case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
		if (TWI_bufPtr < TWI_msgSize)
     f7c:	e0 91 68 01 	lds	r30, 0x0168
     f80:	80 91 6c 08 	lds	r24, 0x086C
     f84:	e8 17       	cp	r30, r24
     f86:	80 f4       	brcc	.+32     	; 0xfa8 <__vector_24+0x64>
		{
			twi_done=1;
     f88:	81 e0       	ldi	r24, 0x01	; 1
     f8a:	80 93 6a 01 	sts	0x016A, r24
			TWDR = TWI_buf[TWI_bufPtr++];
     f8e:	8e 0f       	add	r24, r30
     f90:	80 93 68 01 	sts	0x0168, r24
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	e3 59       	subi	r30, 0x93	; 147
     f98:	f7 4f       	sbci	r31, 0xF7	; 247
     f9a:	80 81       	ld	r24, Z
     f9c:	80 93 bb 00 	sts	0x00BB, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     fa0:	85 e8       	ldi	r24, 0x85	; 133
     fa2:	80 93 bc 00 	sts	0x00BC, r24
     fa6:	52 c0       	rjmp	.+164    	; 0x104c <__vector_24+0x108>
			(1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
			(0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
			TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully.
     fa8:	80 91 69 01 	lds	r24, 0x0169
     fac:	81 60       	ori	r24, 0x01	; 1
     fae:	80 93 69 01 	sts	0x0169, r24
			twi_done=0;
     fb2:	10 92 6a 01 	sts	0x016A, r1
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     fb6:	84 e9       	ldi	r24, 0x94	; 148
     fb8:	80 93 bc 00 	sts	0x00BC, r24
     fbc:	47 c0       	rjmp	.+142    	; 0x104c <__vector_24+0x108>
			(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			(0<<TWWC);                                 //
		}
		break;
		case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
		TWI_buf[TWI_bufPtr++] = TWDR;
     fbe:	e0 91 68 01 	lds	r30, 0x0168
     fc2:	81 e0       	ldi	r24, 0x01	; 1
     fc4:	8e 0f       	add	r24, r30
     fc6:	80 93 68 01 	sts	0x0168, r24
     fca:	f0 e0       	ldi	r31, 0x00	; 0
     fcc:	80 91 bb 00 	lds	r24, 0x00BB
     fd0:	e3 59       	subi	r30, 0x93	; 147
     fd2:	f7 4f       	sbci	r31, 0xF7	; 247
     fd4:	80 83       	st	Z, r24
		case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
		if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
     fd6:	80 91 6c 08 	lds	r24, 0x086C
     fda:	20 91 68 01 	lds	r18, 0x0168
     fde:	30 e0       	ldi	r19, 0x00	; 0
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	01 97       	sbiw	r24, 0x01	; 1
     fe4:	28 17       	cp	r18, r24
     fe6:	39 07       	cpc	r19, r25
     fe8:	3c f4       	brge	.+14     	; 0xff8 <__vector_24+0xb4>
		{
			twi_done =1;
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	80 93 6a 01 	sts	0x016A, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     ff0:	85 ec       	ldi	r24, 0xC5	; 197
     ff2:	80 93 bc 00 	sts	0x00BC, r24
     ff6:	2a c0       	rjmp	.+84     	; 0x104c <__vector_24+0x108>
			(1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
			(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
			(0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			twi_done=1;
     ff8:	81 e0       	ldi	r24, 0x01	; 1
     ffa:	80 93 6a 01 	sts	0x016A, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     ffe:	85 e8       	ldi	r24, 0x85	; 133
    1000:	80 93 bc 00 	sts	0x00BC, r24
    1004:	23 c0       	rjmp	.+70     	; 0x104c <__vector_24+0x108>
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
			(0<<TWWC);                                 //
		}
		break;
		case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
		TWI_buf[TWI_bufPtr] = TWDR;
    1006:	e0 91 68 01 	lds	r30, 0x0168
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	80 91 bb 00 	lds	r24, 0x00BB
    1010:	e3 59       	subi	r30, 0x93	; 147
    1012:	f7 4f       	sbci	r31, 0xF7	; 247
    1014:	80 83       	st	Z, r24
		TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully.
    1016:	80 91 69 01 	lds	r24, 0x0169
    101a:	81 60       	ori	r24, 0x01	; 1
    101c:	80 93 69 01 	sts	0x0169, r24
		twi_done=0;
    1020:	10 92 6a 01 	sts	0x016A, r1
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1024:	84 e9       	ldi	r24, 0x94	; 148
    1026:	80 93 bc 00 	sts	0x00BC, r24
		(0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
		(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
		(0<<TWWC);                                 //
		break;
    102a:	10 c0       	rjmp	.+32     	; 0x104c <__vector_24+0x108>
		case TWI_ARB_LOST:          // Arbitration lost
		twi_done=1;
    102c:	81 e0       	ldi	r24, 0x01	; 1
    102e:	80 93 6a 01 	sts	0x016A, r24
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1032:	85 ea       	ldi	r24, 0xA5	; 165
    1034:	80 93 bc 00 	sts	0x00BC, r24
		(1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
		(0<<TWWC);                                 //
		break;
    1038:	09 c0       	rjmp	.+18     	; 0x104c <__vector_24+0x108>
		case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received
		case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
		//    case TWI_NO_STATE              // No relevant state information available; TWINT
		case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
		default:
		twi_done=0;
    103a:	10 92 6a 01 	sts	0x016A, r1
		TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    103e:	80 91 b9 00 	lds	r24, 0x00B9
    1042:	80 93 00 01 	sts	0x0100, r24
		// Reset TWI Interface
		TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    1046:	84 e0       	ldi	r24, 0x04	; 4
    1048:	80 93 bc 00 	sts	0x00BC, r24
		(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
		(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
		(0<<TWWC);                                 //
	}
}
    104c:	ff 91       	pop	r31
    104e:	ef 91       	pop	r30
    1050:	bf 91       	pop	r27
    1052:	af 91       	pop	r26
    1054:	9f 91       	pop	r25
    1056:	8f 91       	pop	r24
    1058:	3f 91       	pop	r19
    105a:	2f 91       	pop	r18
    105c:	0f 90       	pop	r0
    105e:	0f be       	out	0x3f, r0	; 63
    1060:	0f 90       	pop	r0
    1062:	1f 90       	pop	r1
    1064:	18 95       	reti

00001066 <main>:



portSHORT main(void)
{
	startCommTasks(mainComm_TASK_PRIORITY);
    1066:	82 e0       	ldi	r24, 0x02	; 2
    1068:	0e 94 03 02 	call	0x406	; 0x406 <startCommTasks>
    startSensorTasks( mainSensor_TASK_PRIORITY);
    106c:	82 e0       	ldi	r24, 0x02	; 2
    106e:	0e 94 40 09 	call	0x1280	; 0x1280 <startSensorTasks>
	
	xTaskCreate( vLEDFlashTask, ( signed char * ) "LED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
    1072:	a1 2c       	mov	r10, r1
    1074:	b1 2c       	mov	r11, r1
    1076:	c1 2c       	mov	r12, r1
    1078:	d1 2c       	mov	r13, r1
    107a:	e1 2c       	mov	r14, r1
    107c:	f1 2c       	mov	r15, r1
    107e:	01 e0       	ldi	r16, 0x01	; 1
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	45 e5       	ldi	r20, 0x55	; 85
    1086:	50 e0       	ldi	r21, 0x00	; 0
    1088:	66 e1       	ldi	r22, 0x16	; 22
    108a:	71 e0       	ldi	r23, 0x01	; 1
    108c:	8d e4       	ldi	r24, 0x4D	; 77
    108e:	98 e0       	ldi	r25, 0x08	; 8
    1090:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xTaskGenericCreate>

	//start scheduler

	vTaskStartScheduler();
    1094:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vTaskStartScheduler>
    1098:	ff cf       	rjmp	.-2      	; 0x1098 <main+0x32>

0000109a <vLEDFlashTask>:
#include "FreeRTOS.h"
#include "task.h"
#include "Drivers/LED.h"
#include "mytasks.h"

void vLEDFlashTask( void *pvParameters ){
    109a:	cf 93       	push	r28
    109c:	df 93       	push	r29
    109e:	00 d0       	rcall	.+0      	; 0x10a0 <vLEDFlashTask+0x6>
    10a0:	cd b7       	in	r28, 0x3d	; 61
    10a2:	de b7       	in	r29, 0x3e	; 62

	vLEDInit();
    10a4:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vLEDInit>

	portTickType xLastWakeTime;

	const portTickType xFrequency = 1000;

	xLastWakeTime=xTaskGetTickCount();
    10a8:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskGetTickCount>
    10ac:	9a 83       	std	Y+2, r25	; 0x02
    10ae:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )	{

		vLEDToggle();
    10b0:	0e 94 6f 06 	call	0xcde	; 0xcde <vLEDToggle>

		vTaskDelayUntil(&xLastWakeTime,xFrequency);
    10b4:	68 ee       	ldi	r22, 0xE8	; 232
    10b6:	73 e0       	ldi	r23, 0x03	; 3
    10b8:	ce 01       	movw	r24, r28
    10ba:	01 96       	adiw	r24, 0x01	; 1
    10bc:	0e 94 60 11 	call	0x22c0	; 0x22c0 <vTaskDelayUntil>
    10c0:	f7 cf       	rjmp	.-18     	; 0x10b0 <vLEDFlashTask+0x16>

000010c2 <xSensorTask>:
	xSemaphoreGiveFromISR(dataReadySemaphore,NULL);
}



void xSensorTask (void* pvParameters){
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
    10c6:	cd b7       	in	r28, 0x3d	; 61
    10c8:	de b7       	in	r29, 0x3e	; 62
    10ca:	2c 97       	sbiw	r28, 0x0c	; 12
    10cc:	0f b6       	in	r0, 0x3f	; 63
    10ce:	f8 94       	cli
    10d0:	de bf       	out	0x3e, r29	; 62
    10d2:	0f be       	out	0x3f, r0	; 63
    10d4:	cd bf       	out	0x3d, r28	; 61
	static uint8_t sensorData[NUMBER_OF_BYTES_TO_SEND];
	uint8_t messages=0;
	uint8_t *pSensorData;
	
	
	DataToSend = xQueueCreate(1,sizeof(uint8_t*));
    10d6:	40 e0       	ldi	r20, 0x00	; 0
    10d8:	62 e0       	ldi	r22, 0x02	; 2
    10da:	81 e0       	ldi	r24, 0x01	; 1
    10dc:	0e 94 9a 0c 	call	0x1934	; 0x1934 <xQueueGenericCreate>
    10e0:	90 93 7a 08 	sts	0x087A, r25
    10e4:	80 93 79 08 	sts	0x0879, r24
	//only 1 element in queue, pointer to data
	dataReadySemaphore = xSemaphoreCreateBinary();
    10e8:	43 e0       	ldi	r20, 0x03	; 3
    10ea:	60 e0       	ldi	r22, 0x00	; 0
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	0e 94 9a 0c 	call	0x1934	; 0x1934 <xQueueGenericCreate>
    10f2:	90 93 78 08 	sts	0x0878, r25
    10f6:	80 93 77 08 	sts	0x0877, r24
	//create semaphore for dataReady, the sensorTask will block on this semaphore
	while(xSemaphoreTake(moteReadySemaphore,0xFFFF) != pdTRUE);
    10fa:	20 e0       	ldi	r18, 0x00	; 0
    10fc:	4f ef       	ldi	r20, 0xFF	; 255
    10fe:	5f ef       	ldi	r21, 0xFF	; 255
    1100:	60 e0       	ldi	r22, 0x00	; 0
    1102:	70 e0       	ldi	r23, 0x00	; 0
    1104:	80 91 d5 07 	lds	r24, 0x07D5
    1108:	90 91 d6 07 	lds	r25, 0x07D6
    110c:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
    1110:	81 30       	cpi	r24, 0x01	; 1
    1112:	99 f7       	brne	.-26     	; 0x10fa <xSensorTask+0x38>
	//wait a long time for mote to be ready to send
	
	
	DDRD &= ~(1<<PORTD2); // as input
    1114:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<PORTD2); // pull up
    1116:	5a 9a       	sbi	0x0b, 2	; 11
	EIMSK |= (1<<INT0); //enable external Interrupt 0 for Data ready Pin
    1118:	e8 9a       	sbi	0x1d, 0	; 29
	EICRA |= (1<<ISC01);//the falling edge generates the interrupt
    111a:	e9 e6       	ldi	r30, 0x69	; 105
    111c:	f0 e0       	ldi	r31, 0x00	; 0
    111e:	80 81       	ld	r24, Z
    1120:	82 60       	ori	r24, 0x02	; 2
    1122:	80 83       	st	Z, r24
	
	
	TWI_Master_Initialise();
    1124:	0e 94 57 07 	call	0xeae	; 0xeae <TWI_Master_Initialise>
	
	uint8_t sensorConfig[10];
	//(8-average, 15 Hz default, normal measurement)
	sensorConfig[0]=SLAVE_SENSOR_W;
    1128:	1c e3       	ldi	r17, 0x3C	; 60
    112a:	1b 83       	std	Y+3, r17	; 0x03
	sensorConfig[1]=CRA;
    112c:	1c 82       	std	Y+4, r1	; 0x04
	sensorConfig[2]=0x70;//(8-average, 15 Hz default, normal measurement)
    112e:	80 e7       	ldi	r24, 0x70	; 112
    1130:	8d 83       	std	Y+5, r24	; 0x05
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
    1132:	63 e0       	ldi	r22, 0x03	; 3
    1134:	ce 01       	movw	r24, r28
    1136:	03 96       	adiw	r24, 0x03	; 3
    1138:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
	vTaskDelay(100);
    113c:	84 e6       	ldi	r24, 0x64	; 100
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskDelay>
	sensorConfig[0]=SLAVE_SENSOR_W;
    1144:	1b 83       	std	Y+3, r17	; 0x03
	sensorConfig[1]=CRB;
    1146:	01 e0       	ldi	r16, 0x01	; 1
    1148:	0c 83       	std	Y+4, r16	; 0x04
	sensorConfig[2]= 0xA0; //(Gain=5, or any  other desired gain
    114a:	80 ea       	ldi	r24, 0xA0	; 160
    114c:	8d 83       	std	Y+5, r24	; 0x05
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
    114e:	63 e0       	ldi	r22, 0x03	; 3
    1150:	ce 01       	movw	r24, r28
    1152:	03 96       	adiw	r24, 0x03	; 3
    1154:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
	vTaskDelay(100);
    1158:	84 e6       	ldi	r24, 0x64	; 100
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskDelay>
	sensorConfig[0]=SLAVE_SENSOR_W;
    1160:	1b 83       	std	Y+3, r17	; 0x03
	sensorConfig[1]=MODE_REGISTER;
    1162:	82 e0       	ldi	r24, 0x02	; 2
    1164:	8c 83       	std	Y+4, r24	; 0x04
	sensorConfig[2]=0x01; // single measurement mode
    1166:	0d 83       	std	Y+5, r16	; 0x05
	TWI_Start_Transceiver_With_Data(sensorConfig,3);
    1168:	63 e0       	ldi	r22, 0x03	; 3
    116a:	ce 01       	movw	r24, r28
    116c:	03 96       	adiw	r24, 0x03	; 3
    116e:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
	vTaskDelay(100);
    1172:	84 e6       	ldi	r24, 0x64	; 100
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskDelay>
	#ifdef SEND_DEFINED_NUMBER
	uint16_t messagesSent=0;
    117a:	e1 2c       	mov	r14, r1
    117c:	f1 2c       	mov	r15, r1


void xSensorTask (void* pvParameters){
	
	static uint8_t sensorData[NUMBER_OF_BYTES_TO_SEND];
	uint8_t messages=0;
    117e:	b1 2c       	mov	r11, r1
		
			
			if (xSemaphoreTake(dataReadySemaphore,0xFFFF))//Block on sensor interrupt
			{
				
				sensorConfig[0]=SLAVE_SENSOR_R;
    1180:	0f 2e       	mov	r0, r31
    1182:	fd e3       	ldi	r31, 0x3D	; 61
    1184:	6f 2e       	mov	r6, r31
    1186:	f0 2d       	mov	r31, r0
				sensorConfig[1]=DATA_OUTPUT_REGISTER; //Start with X MSB register
    1188:	0f 2e       	mov	r0, r31
    118a:	f3 e0       	ldi	r31, 0x03	; 3
    118c:	af 2e       	mov	r10, r31
    118e:	f0 2d       	mov	r31, r0
    1190:	8e 01       	movw	r16, r28
    1192:	05 5f       	subi	r16, 0xF5	; 245
    1194:	1f 4f       	sbci	r17, 0xFF	; 255
					#ifdef SEND_DEFINED_NUMBER
					messagesSent++;
					#endif
					
					messages=0;
					sensorData[0]=0x10;
    1196:	0f 2e       	mov	r0, r31
    1198:	fb e6       	ldi	r31, 0x6B	; 107
    119a:	cf 2e       	mov	r12, r31
    119c:	f1 e0       	ldi	r31, 0x01	; 1
    119e:	df 2e       	mov	r13, r31
    11a0:	f0 2d       	mov	r31, r0
    11a2:	68 94       	set
    11a4:	55 24       	eor	r5, r5
    11a6:	54 f8       	bld	r5, 4
					pSensorData = sensorData;
					xQueueSend( DataToSend, (void*) &pSensorData, ( TickType_t ) 0 );
				}
				//we must setup the sensor for the next measurement in single measurement mode
				sensorConfig[0]=SLAVE_SENSOR_W;
    11a8:	0f 2e       	mov	r0, r31
    11aa:	fc e3       	ldi	r31, 0x3C	; 60
    11ac:	7f 2e       	mov	r7, r31
    11ae:	f0 2d       	mov	r31, r0
				sensorConfig[1]=MODE_REGISTER;
    11b0:	68 94       	set
    11b2:	88 24       	eor	r8, r8
    11b4:	81 f8       	bld	r8, 1
				sensorConfig[2]=0x01; // single measurement mode
    11b6:	99 24       	eor	r9, r9
    11b8:	93 94       	inc	r9
	#endif
	

	while(1){
		
		PORTC &= ~(1<<PORTC1);
    11ba:	41 98       	cbi	0x08, 1	; 8
		
			
			if (xSemaphoreTake(dataReadySemaphore,0xFFFF))//Block on sensor interrupt
    11bc:	20 e0       	ldi	r18, 0x00	; 0
    11be:	4f ef       	ldi	r20, 0xFF	; 255
    11c0:	5f ef       	ldi	r21, 0xFF	; 255
    11c2:	60 e0       	ldi	r22, 0x00	; 0
    11c4:	70 e0       	ldi	r23, 0x00	; 0
    11c6:	80 91 77 08 	lds	r24, 0x0877
    11ca:	90 91 78 08 	lds	r25, 0x0878
    11ce:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <xQueueGenericReceive>
    11d2:	88 23       	and	r24, r24
    11d4:	91 f3       	breq	.-28     	; 0x11ba <xSensorTask+0xf8>
			{
				
				sensorConfig[0]=SLAVE_SENSOR_R;
    11d6:	6b 82       	std	Y+3, r6	; 0x03
				sensorConfig[1]=DATA_OUTPUT_REGISTER; //Start with X MSB register
    11d8:	ac 82       	std	Y+4, r10	; 0x04
				TWI_Start_Transceiver_With_Data(sensorConfig,8); // 2 + 6 bytes to be read
    11da:	68 e0       	ldi	r22, 0x08	; 8
    11dc:	ce 01       	movw	r24, r28
    11de:	03 96       	adiw	r24, 0x03	; 3
    11e0:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
				vTaskDelay(1);
    11e4:	81 e0       	ldi	r24, 0x01	; 1
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskDelay>
				TWI_Get_Data_From_Transceiver(sensorConfig,8);// get the data from the i2c buffer into sensorconfig array
    11ec:	68 e0       	ldi	r22, 0x08	; 8
    11ee:	ce 01       	movw	r24, r28
    11f0:	03 96       	adiw	r24, 0x03	; 3
    11f2:	0e 94 88 07 	call	0xf10	; 0xf10 <TWI_Get_Data_From_Transceiver>
    11f6:	fe 01       	movw	r30, r28
    11f8:	35 96       	adiw	r30, 0x05	; 5
				
				for (uint8_t i =0;i<6;i++){
					sensorData[(messages*NUMBER_OF_BYTES_TO_READ)+i]=sensorConfig[i+2];
    11fa:	8b 2d       	mov	r24, r11
    11fc:	90 e0       	ldi	r25, 0x00	; 0
    11fe:	dc 01       	movw	r26, r24
    1200:	aa 0f       	add	r26, r26
    1202:	bb 1f       	adc	r27, r27
    1204:	8a 0f       	add	r24, r26
    1206:	9b 1f       	adc	r25, r27
    1208:	dc 01       	movw	r26, r24
    120a:	aa 0f       	add	r26, r26
    120c:	bb 1f       	adc	r27, r27
    120e:	a5 59       	subi	r26, 0x95	; 149
    1210:	be 4f       	sbci	r27, 0xFE	; 254
    1212:	81 91       	ld	r24, Z+
    1214:	8d 93       	st	X+, r24
				sensorConfig[1]=DATA_OUTPUT_REGISTER; //Start with X MSB register
				TWI_Start_Transceiver_With_Data(sensorConfig,8); // 2 + 6 bytes to be read
				vTaskDelay(1);
				TWI_Get_Data_From_Transceiver(sensorConfig,8);// get the data from the i2c buffer into sensorconfig array
				
				for (uint8_t i =0;i<6;i++){
    1216:	e0 17       	cp	r30, r16
    1218:	f1 07       	cpc	r31, r17
    121a:	d9 f7       	brne	.-10     	; 0x1212 <xSensorTask+0x150>
					sensorData[(messages*NUMBER_OF_BYTES_TO_READ)+i]=sensorConfig[i+2];
				}
				messages++;
    121c:	b3 94       	inc	r11
				if (messages>=NUMBER_OF_MEASURES){
    121e:	87 e0       	ldi	r24, 0x07	; 7
    1220:	8b 15       	cp	r24, r11
    1222:	a0 f4       	brcc	.+40     	; 0x124c <xSensorTask+0x18a>
					#ifdef SEND_DEFINED_NUMBER
					messagesSent++;
    1224:	ef ef       	ldi	r30, 0xFF	; 255
    1226:	ee 1a       	sub	r14, r30
    1228:	fe 0a       	sbc	r15, r30
					#endif
					
					messages=0;
					sensorData[0]=0x10;
    122a:	f6 01       	movw	r30, r12
    122c:	50 82       	st	Z, r5
					pSensorData = sensorData;
    122e:	da 82       	std	Y+2, r13	; 0x02
    1230:	c9 82       	std	Y+1, r12	; 0x01
					xQueueSend( DataToSend, (void*) &pSensorData, ( TickType_t ) 0 );
    1232:	20 e0       	ldi	r18, 0x00	; 0
    1234:	40 e0       	ldi	r20, 0x00	; 0
    1236:	50 e0       	ldi	r21, 0x00	; 0
    1238:	be 01       	movw	r22, r28
    123a:	6f 5f       	subi	r22, 0xFF	; 255
    123c:	7f 4f       	sbci	r23, 0xFF	; 255
    123e:	80 91 79 08 	lds	r24, 0x0879
    1242:	90 91 7a 08 	lds	r25, 0x087A
    1246:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xQueueGenericSend>
				if (messages>=NUMBER_OF_MEASURES){
					#ifdef SEND_DEFINED_NUMBER
					messagesSent++;
					#endif
					
					messages=0;
    124a:	b1 2c       	mov	r11, r1
					sensorData[0]=0x10;
					pSensorData = sensorData;
					xQueueSend( DataToSend, (void*) &pSensorData, ( TickType_t ) 0 );
				}
				//we must setup the sensor for the next measurement in single measurement mode
				sensorConfig[0]=SLAVE_SENSOR_W;
    124c:	7b 82       	std	Y+3, r7	; 0x03
				sensorConfig[1]=MODE_REGISTER;
    124e:	8c 82       	std	Y+4, r8	; 0x04
				sensorConfig[2]=0x01; // single measurement mode
    1250:	9d 82       	std	Y+5, r9	; 0x05
				TWI_Start_Transceiver_With_Data(sensorConfig,3);
    1252:	6a 2d       	mov	r22, r10
    1254:	ce 01       	movw	r24, r28
    1256:	03 96       	adiw	r24, 0x03	; 3
    1258:	0e 94 5d 07 	call	0xeba	; 0xeba <TWI_Start_Transceiver_With_Data>
				vTaskDelay(1);
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskDelay>
				#ifdef SEND_DEFINED_NUMBER
				//USED ONLY FOR TESTING PURPOSES, THIS WILL SUSPEND THE SENSOR TASK!
				if (messagesSent == NUMBER_OF_MESSAGES)
    1264:	f8 e8       	ldi	r31, 0x88	; 136
    1266:	ef 16       	cp	r14, r31
    1268:	f3 e1       	ldi	r31, 0x13	; 19
    126a:	ff 06       	cpc	r15, r31
    126c:	09 f0       	breq	.+2      	; 0x1270 <xSensorTask+0x1ae>
    126e:	a5 cf       	rjmp	.-182    	; 0x11ba <xSensorTask+0xf8>
				{
					PORTC |= (1<<PORTC1);
    1270:	41 9a       	sbi	0x08, 1	; 8
					vTaskSuspend(xSensorHandle);
    1272:	80 91 7b 08 	lds	r24, 0x087B
    1276:	90 91 7c 08 	lds	r25, 0x087C
    127a:	0e 94 20 12 	call	0x2440	; 0x2440 <vTaskSuspend>
    127e:	9d cf       	rjmp	.-198    	; 0x11ba <xSensorTask+0xf8>

00001280 <startSensorTasks>:

QueueHandle_t DataToSend;


TaskHandle_t xSensorHandle;
void startSensorTasks(UBaseType_t uxPriority){
    1280:	af 92       	push	r10
    1282:	bf 92       	push	r11
    1284:	cf 92       	push	r12
    1286:	df 92       	push	r13
    1288:	ef 92       	push	r14
    128a:	ff 92       	push	r15
    128c:	0f 93       	push	r16
	
	xTaskCreate( xSensorTask,( signed char * ) "Sensor", sensorSTACK_SIZE, NULL, uxPriority, &xSensorHandle );
    128e:	a1 2c       	mov	r10, r1
    1290:	b1 2c       	mov	r11, r1
    1292:	c1 2c       	mov	r12, r1
    1294:	d1 2c       	mov	r13, r1
    1296:	0f 2e       	mov	r0, r31
    1298:	fb e7       	ldi	r31, 0x7B	; 123
    129a:	ef 2e       	mov	r14, r31
    129c:	f8 e0       	ldi	r31, 0x08	; 8
    129e:	ff 2e       	mov	r15, r31
    12a0:	f0 2d       	mov	r31, r0
    12a2:	08 2f       	mov	r16, r24
    12a4:	20 e0       	ldi	r18, 0x00	; 0
    12a6:	30 e0       	ldi	r19, 0x00	; 0
    12a8:	40 e0       	ldi	r20, 0x00	; 0
    12aa:	51 e0       	ldi	r21, 0x01	; 1
    12ac:	6a e1       	ldi	r22, 0x1A	; 26
    12ae:	71 e0       	ldi	r23, 0x01	; 1
    12b0:	81 e6       	ldi	r24, 0x61	; 97
    12b2:	98 e0       	ldi	r25, 0x08	; 8
    12b4:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xTaskGenericCreate>
	
}
    12b8:	0f 91       	pop	r16
    12ba:	ff 90       	pop	r15
    12bc:	ef 90       	pop	r14
    12be:	df 90       	pop	r13
    12c0:	cf 90       	pop	r12
    12c2:	bf 90       	pop	r11
    12c4:	af 90       	pop	r10
    12c6:	08 95       	ret

000012c8 <__vector_1>:
#ifdef DATA_READY_INTERRUPT


ISR( INT0_vect ) __attribute__ ((hot, flatten));
ISR( INT0_vect )
{
    12c8:	1f 92       	push	r1
    12ca:	0f 92       	push	r0
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	0f 92       	push	r0
    12d0:	11 24       	eor	r1, r1
    12d2:	2f 93       	push	r18
    12d4:	3f 93       	push	r19
    12d6:	4f 93       	push	r20
    12d8:	5f 93       	push	r21
    12da:	6f 93       	push	r22
    12dc:	7f 93       	push	r23
    12de:	8f 93       	push	r24
    12e0:	9f 93       	push	r25
    12e2:	af 93       	push	r26
    12e4:	bf 93       	push	r27
    12e6:	ef 93       	push	r30
    12e8:	ff 93       	push	r31
	xSemaphoreGiveFromISR(dataReadySemaphore,NULL);
    12ea:	60 e0       	ldi	r22, 0x00	; 0
    12ec:	70 e0       	ldi	r23, 0x00	; 0
    12ee:	80 91 77 08 	lds	r24, 0x0877
    12f2:	90 91 78 08 	lds	r25, 0x0878
    12f6:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <xQueueGiveFromISR>
}
    12fa:	ff 91       	pop	r31
    12fc:	ef 91       	pop	r30
    12fe:	bf 91       	pop	r27
    1300:	af 91       	pop	r26
    1302:	9f 91       	pop	r25
    1304:	8f 91       	pop	r24
    1306:	7f 91       	pop	r23
    1308:	6f 91       	pop	r22
    130a:	5f 91       	pop	r21
    130c:	4f 91       	pop	r20
    130e:	3f 91       	pop	r19
    1310:	2f 91       	pop	r18
    1312:	0f 90       	pop	r0
    1314:	0f be       	out	0x3f, r0	; 63
    1316:	0f 90       	pop	r0
    1318:	1f 90       	pop	r1
    131a:	18 95       	reti

0000131c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    131c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    131e:	03 96       	adiw	r24, 0x03	; 3
    1320:	92 83       	std	Z+2, r25	; 0x02
    1322:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1324:	2f ef       	ldi	r18, 0xFF	; 255
    1326:	3f ef       	ldi	r19, 0xFF	; 255
    1328:	34 83       	std	Z+4, r19	; 0x04
    132a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    132c:	96 83       	std	Z+6, r25	; 0x06
    132e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1330:	90 87       	std	Z+8, r25	; 0x08
    1332:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1334:	10 82       	st	Z, r1
    1336:	08 95       	ret

00001338 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1338:	fc 01       	movw	r30, r24
    133a:	11 86       	std	Z+9, r1	; 0x09
    133c:	10 86       	std	Z+8, r1	; 0x08
    133e:	08 95       	ret

00001340 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1340:	cf 93       	push	r28
    1342:	df 93       	push	r29
    1344:	9c 01       	movw	r18, r24
    1346:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1348:	dc 01       	movw	r26, r24
    134a:	11 96       	adiw	r26, 0x01	; 1
    134c:	cd 91       	ld	r28, X+
    134e:	dc 91       	ld	r29, X
    1350:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1352:	d3 83       	std	Z+3, r29	; 0x03
    1354:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1356:	8c 81       	ldd	r24, Y+4	; 0x04
    1358:	9d 81       	ldd	r25, Y+5	; 0x05
    135a:	95 83       	std	Z+5, r25	; 0x05
    135c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    135e:	8c 81       	ldd	r24, Y+4	; 0x04
    1360:	9d 81       	ldd	r25, Y+5	; 0x05
    1362:	dc 01       	movw	r26, r24
    1364:	13 96       	adiw	r26, 0x03	; 3
    1366:	7c 93       	st	X, r23
    1368:	6e 93       	st	-X, r22
    136a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    136c:	7d 83       	std	Y+5, r23	; 0x05
    136e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1370:	31 87       	std	Z+9, r19	; 0x09
    1372:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1374:	f9 01       	movw	r30, r18
    1376:	80 81       	ld	r24, Z
    1378:	8f 5f       	subi	r24, 0xFF	; 255
    137a:	80 83       	st	Z, r24
}
    137c:	df 91       	pop	r29
    137e:	cf 91       	pop	r28
    1380:	08 95       	ret

00001382 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1382:	cf 93       	push	r28
    1384:	df 93       	push	r29
    1386:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1388:	48 81       	ld	r20, Y
    138a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    138c:	4f 3f       	cpi	r20, 0xFF	; 255
    138e:	2f ef       	ldi	r18, 0xFF	; 255
    1390:	52 07       	cpc	r21, r18
    1392:	21 f4       	brne	.+8      	; 0x139c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1394:	fc 01       	movw	r30, r24
    1396:	a7 81       	ldd	r26, Z+7	; 0x07
    1398:	b0 85       	ldd	r27, Z+8	; 0x08
    139a:	0d c0       	rjmp	.+26     	; 0x13b6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    139c:	dc 01       	movw	r26, r24
    139e:	13 96       	adiw	r26, 0x03	; 3
    13a0:	12 96       	adiw	r26, 0x02	; 2
    13a2:	ed 91       	ld	r30, X+
    13a4:	fc 91       	ld	r31, X
    13a6:	13 97       	sbiw	r26, 0x03	; 3
    13a8:	20 81       	ld	r18, Z
    13aa:	31 81       	ldd	r19, Z+1	; 0x01
    13ac:	42 17       	cp	r20, r18
    13ae:	53 07       	cpc	r21, r19
    13b0:	10 f0       	brcs	.+4      	; 0x13b6 <vListInsert+0x34>
    13b2:	df 01       	movw	r26, r30
    13b4:	f5 cf       	rjmp	.-22     	; 0x13a0 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    13b6:	12 96       	adiw	r26, 0x02	; 2
    13b8:	ed 91       	ld	r30, X+
    13ba:	fc 91       	ld	r31, X
    13bc:	13 97       	sbiw	r26, 0x03	; 3
    13be:	fb 83       	std	Y+3, r31	; 0x03
    13c0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    13c2:	d5 83       	std	Z+5, r29	; 0x05
    13c4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    13c6:	bd 83       	std	Y+5, r27	; 0x05
    13c8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    13ca:	13 96       	adiw	r26, 0x03	; 3
    13cc:	dc 93       	st	X, r29
    13ce:	ce 93       	st	-X, r28
    13d0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    13d2:	99 87       	std	Y+9, r25	; 0x09
    13d4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    13d6:	fc 01       	movw	r30, r24
    13d8:	20 81       	ld	r18, Z
    13da:	2f 5f       	subi	r18, 0xFF	; 255
    13dc:	20 83       	st	Z, r18
}
    13de:	df 91       	pop	r29
    13e0:	cf 91       	pop	r28
    13e2:	08 95       	ret

000013e4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    13e4:	cf 93       	push	r28
    13e6:	df 93       	push	r29
    13e8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    13ea:	a0 85       	ldd	r26, Z+8	; 0x08
    13ec:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    13ee:	c2 81       	ldd	r28, Z+2	; 0x02
    13f0:	d3 81       	ldd	r29, Z+3	; 0x03
    13f2:	84 81       	ldd	r24, Z+4	; 0x04
    13f4:	95 81       	ldd	r25, Z+5	; 0x05
    13f6:	9d 83       	std	Y+5, r25	; 0x05
    13f8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    13fa:	c4 81       	ldd	r28, Z+4	; 0x04
    13fc:	d5 81       	ldd	r29, Z+5	; 0x05
    13fe:	82 81       	ldd	r24, Z+2	; 0x02
    1400:	93 81       	ldd	r25, Z+3	; 0x03
    1402:	9b 83       	std	Y+3, r25	; 0x03
    1404:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1406:	11 96       	adiw	r26, 0x01	; 1
    1408:	cd 91       	ld	r28, X+
    140a:	dc 91       	ld	r29, X
    140c:	12 97       	sbiw	r26, 0x02	; 2
    140e:	ce 17       	cp	r28, r30
    1410:	df 07       	cpc	r29, r31
    1412:	31 f4       	brne	.+12     	; 0x1420 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1414:	8c 81       	ldd	r24, Y+4	; 0x04
    1416:	9d 81       	ldd	r25, Y+5	; 0x05
    1418:	12 96       	adiw	r26, 0x02	; 2
    141a:	9c 93       	st	X, r25
    141c:	8e 93       	st	-X, r24
    141e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1420:	11 86       	std	Z+9, r1	; 0x09
    1422:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1424:	8c 91       	ld	r24, X
    1426:	81 50       	subi	r24, 0x01	; 1
    1428:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    142a:	df 91       	pop	r29
    142c:	cf 91       	pop	r28
    142e:	08 95       	ret

00001430 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1430:	31 e1       	ldi	r19, 0x11	; 17
    1432:	fc 01       	movw	r30, r24
    1434:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1436:	31 97       	sbiw	r30, 0x01	; 1
    1438:	22 e2       	ldi	r18, 0x22	; 34
    143a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    143c:	31 97       	sbiw	r30, 0x01	; 1
    143e:	a3 e3       	ldi	r26, 0x33	; 51
    1440:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1442:	31 97       	sbiw	r30, 0x01	; 1
    1444:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1446:	31 97       	sbiw	r30, 0x01	; 1
    1448:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    144a:	31 97       	sbiw	r30, 0x01	; 1
    144c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    144e:	31 97       	sbiw	r30, 0x01	; 1
    1450:	60 e8       	ldi	r22, 0x80	; 128
    1452:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1454:	31 97       	sbiw	r30, 0x01	; 1
    1456:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1458:	31 97       	sbiw	r30, 0x01	; 1
    145a:	62 e0       	ldi	r22, 0x02	; 2
    145c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    145e:	31 97       	sbiw	r30, 0x01	; 1
    1460:	63 e0       	ldi	r22, 0x03	; 3
    1462:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1464:	31 97       	sbiw	r30, 0x01	; 1
    1466:	64 e0       	ldi	r22, 0x04	; 4
    1468:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    146a:	31 97       	sbiw	r30, 0x01	; 1
    146c:	65 e0       	ldi	r22, 0x05	; 5
    146e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1470:	31 97       	sbiw	r30, 0x01	; 1
    1472:	66 e0       	ldi	r22, 0x06	; 6
    1474:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1476:	31 97       	sbiw	r30, 0x01	; 1
    1478:	67 e0       	ldi	r22, 0x07	; 7
    147a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    147c:	31 97       	sbiw	r30, 0x01	; 1
    147e:	68 e0       	ldi	r22, 0x08	; 8
    1480:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1482:	31 97       	sbiw	r30, 0x01	; 1
    1484:	69 e0       	ldi	r22, 0x09	; 9
    1486:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1488:	31 97       	sbiw	r30, 0x01	; 1
    148a:	60 e1       	ldi	r22, 0x10	; 16
    148c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    148e:	31 97       	sbiw	r30, 0x01	; 1
    1490:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1492:	31 97       	sbiw	r30, 0x01	; 1
    1494:	32 e1       	ldi	r19, 0x12	; 18
    1496:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1498:	31 97       	sbiw	r30, 0x01	; 1
    149a:	33 e1       	ldi	r19, 0x13	; 19
    149c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    149e:	31 97       	sbiw	r30, 0x01	; 1
    14a0:	34 e1       	ldi	r19, 0x14	; 20
    14a2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    14a4:	31 97       	sbiw	r30, 0x01	; 1
    14a6:	35 e1       	ldi	r19, 0x15	; 21
    14a8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    14aa:	31 97       	sbiw	r30, 0x01	; 1
    14ac:	36 e1       	ldi	r19, 0x16	; 22
    14ae:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    14b0:	31 97       	sbiw	r30, 0x01	; 1
    14b2:	37 e1       	ldi	r19, 0x17	; 23
    14b4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    14b6:	31 97       	sbiw	r30, 0x01	; 1
    14b8:	38 e1       	ldi	r19, 0x18	; 24
    14ba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    14bc:	31 97       	sbiw	r30, 0x01	; 1
    14be:	39 e1       	ldi	r19, 0x19	; 25
    14c0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    14c2:	31 97       	sbiw	r30, 0x01	; 1
    14c4:	30 e2       	ldi	r19, 0x20	; 32
    14c6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    14c8:	31 97       	sbiw	r30, 0x01	; 1
    14ca:	31 e2       	ldi	r19, 0x21	; 33
    14cc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    14ce:	31 97       	sbiw	r30, 0x01	; 1
    14d0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    14d2:	31 97       	sbiw	r30, 0x01	; 1
    14d4:	23 e2       	ldi	r18, 0x23	; 35
    14d6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    14d8:	31 97       	sbiw	r30, 0x01	; 1
    14da:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    14dc:	31 97       	sbiw	r30, 0x01	; 1
    14de:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    14e0:	31 97       	sbiw	r30, 0x01	; 1
    14e2:	26 e2       	ldi	r18, 0x26	; 38
    14e4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    14e6:	31 97       	sbiw	r30, 0x01	; 1
    14e8:	27 e2       	ldi	r18, 0x27	; 39
    14ea:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    14ec:	31 97       	sbiw	r30, 0x01	; 1
    14ee:	28 e2       	ldi	r18, 0x28	; 40
    14f0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    14f2:	31 97       	sbiw	r30, 0x01	; 1
    14f4:	29 e2       	ldi	r18, 0x29	; 41
    14f6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    14f8:	31 97       	sbiw	r30, 0x01	; 1
    14fa:	20 e3       	ldi	r18, 0x30	; 48
    14fc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    14fe:	31 97       	sbiw	r30, 0x01	; 1
    1500:	21 e3       	ldi	r18, 0x31	; 49
    1502:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1504:	86 97       	sbiw	r24, 0x26	; 38
    1506:	08 95       	ret

00001508 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    1508:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    150c:	82 e7       	ldi	r24, 0x72	; 114
    150e:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1512:	8b e0       	ldi	r24, 0x0B	; 11
    1514:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    1518:	ef e6       	ldi	r30, 0x6F	; 111
    151a:	f0 e0       	ldi	r31, 0x00	; 0
    151c:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    151e:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    1520:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1522:	a0 91 d3 07 	lds	r26, 0x07D3
    1526:	b0 91 d4 07 	lds	r27, 0x07D4
    152a:	cd 91       	ld	r28, X+
    152c:	cd bf       	out	0x3d, r28	; 61
    152e:	dd 91       	ld	r29, X+
    1530:	de bf       	out	0x3e, r29	; 62
    1532:	ff 91       	pop	r31
    1534:	ef 91       	pop	r30
    1536:	df 91       	pop	r29
    1538:	cf 91       	pop	r28
    153a:	bf 91       	pop	r27
    153c:	af 91       	pop	r26
    153e:	9f 91       	pop	r25
    1540:	8f 91       	pop	r24
    1542:	7f 91       	pop	r23
    1544:	6f 91       	pop	r22
    1546:	5f 91       	pop	r21
    1548:	4f 91       	pop	r20
    154a:	3f 91       	pop	r19
    154c:	2f 91       	pop	r18
    154e:	1f 91       	pop	r17
    1550:	0f 91       	pop	r16
    1552:	ff 90       	pop	r15
    1554:	ef 90       	pop	r14
    1556:	df 90       	pop	r13
    1558:	cf 90       	pop	r12
    155a:	bf 90       	pop	r11
    155c:	af 90       	pop	r10
    155e:	9f 90       	pop	r9
    1560:	8f 90       	pop	r8
    1562:	7f 90       	pop	r7
    1564:	6f 90       	pop	r6
    1566:	5f 90       	pop	r5
    1568:	4f 90       	pop	r4
    156a:	3f 90       	pop	r3
    156c:	2f 90       	pop	r2
    156e:	1f 90       	pop	r1
    1570:	0f 90       	pop	r0
    1572:	0f be       	out	0x3f, r0	; 63
    1574:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1576:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	08 95       	ret

0000157c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    157c:	0f 92       	push	r0
    157e:	0f b6       	in	r0, 0x3f	; 63
    1580:	f8 94       	cli
    1582:	0f 92       	push	r0
    1584:	1f 92       	push	r1
    1586:	11 24       	eor	r1, r1
    1588:	2f 92       	push	r2
    158a:	3f 92       	push	r3
    158c:	4f 92       	push	r4
    158e:	5f 92       	push	r5
    1590:	6f 92       	push	r6
    1592:	7f 92       	push	r7
    1594:	8f 92       	push	r8
    1596:	9f 92       	push	r9
    1598:	af 92       	push	r10
    159a:	bf 92       	push	r11
    159c:	cf 92       	push	r12
    159e:	df 92       	push	r13
    15a0:	ef 92       	push	r14
    15a2:	ff 92       	push	r15
    15a4:	0f 93       	push	r16
    15a6:	1f 93       	push	r17
    15a8:	2f 93       	push	r18
    15aa:	3f 93       	push	r19
    15ac:	4f 93       	push	r20
    15ae:	5f 93       	push	r21
    15b0:	6f 93       	push	r22
    15b2:	7f 93       	push	r23
    15b4:	8f 93       	push	r24
    15b6:	9f 93       	push	r25
    15b8:	af 93       	push	r26
    15ba:	bf 93       	push	r27
    15bc:	cf 93       	push	r28
    15be:	df 93       	push	r29
    15c0:	ef 93       	push	r30
    15c2:	ff 93       	push	r31
    15c4:	a0 91 d3 07 	lds	r26, 0x07D3
    15c8:	b0 91 d4 07 	lds	r27, 0x07D4
    15cc:	0d b6       	in	r0, 0x3d	; 61
    15ce:	0d 92       	st	X+, r0
    15d0:	0e b6       	in	r0, 0x3e	; 62
    15d2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    15d4:	0e 94 c2 11 	call	0x2384	; 0x2384 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    15d8:	a0 91 d3 07 	lds	r26, 0x07D3
    15dc:	b0 91 d4 07 	lds	r27, 0x07D4
    15e0:	cd 91       	ld	r28, X+
    15e2:	cd bf       	out	0x3d, r28	; 61
    15e4:	dd 91       	ld	r29, X+
    15e6:	de bf       	out	0x3e, r29	; 62
    15e8:	ff 91       	pop	r31
    15ea:	ef 91       	pop	r30
    15ec:	df 91       	pop	r29
    15ee:	cf 91       	pop	r28
    15f0:	bf 91       	pop	r27
    15f2:	af 91       	pop	r26
    15f4:	9f 91       	pop	r25
    15f6:	8f 91       	pop	r24
    15f8:	7f 91       	pop	r23
    15fa:	6f 91       	pop	r22
    15fc:	5f 91       	pop	r21
    15fe:	4f 91       	pop	r20
    1600:	3f 91       	pop	r19
    1602:	2f 91       	pop	r18
    1604:	1f 91       	pop	r17
    1606:	0f 91       	pop	r16
    1608:	ff 90       	pop	r15
    160a:	ef 90       	pop	r14
    160c:	df 90       	pop	r13
    160e:	cf 90       	pop	r12
    1610:	bf 90       	pop	r11
    1612:	af 90       	pop	r10
    1614:	9f 90       	pop	r9
    1616:	8f 90       	pop	r8
    1618:	7f 90       	pop	r7
    161a:	6f 90       	pop	r6
    161c:	5f 90       	pop	r5
    161e:	4f 90       	pop	r4
    1620:	3f 90       	pop	r3
    1622:	2f 90       	pop	r2
    1624:	1f 90       	pop	r1
    1626:	0f 90       	pop	r0
    1628:	0f be       	out	0x3f, r0	; 63
    162a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    162c:	08 95       	ret

0000162e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    162e:	0f 92       	push	r0
    1630:	0f b6       	in	r0, 0x3f	; 63
    1632:	f8 94       	cli
    1634:	0f 92       	push	r0
    1636:	1f 92       	push	r1
    1638:	11 24       	eor	r1, r1
    163a:	2f 92       	push	r2
    163c:	3f 92       	push	r3
    163e:	4f 92       	push	r4
    1640:	5f 92       	push	r5
    1642:	6f 92       	push	r6
    1644:	7f 92       	push	r7
    1646:	8f 92       	push	r8
    1648:	9f 92       	push	r9
    164a:	af 92       	push	r10
    164c:	bf 92       	push	r11
    164e:	cf 92       	push	r12
    1650:	df 92       	push	r13
    1652:	ef 92       	push	r14
    1654:	ff 92       	push	r15
    1656:	0f 93       	push	r16
    1658:	1f 93       	push	r17
    165a:	2f 93       	push	r18
    165c:	3f 93       	push	r19
    165e:	4f 93       	push	r20
    1660:	5f 93       	push	r21
    1662:	6f 93       	push	r22
    1664:	7f 93       	push	r23
    1666:	8f 93       	push	r24
    1668:	9f 93       	push	r25
    166a:	af 93       	push	r26
    166c:	bf 93       	push	r27
    166e:	cf 93       	push	r28
    1670:	df 93       	push	r29
    1672:	ef 93       	push	r30
    1674:	ff 93       	push	r31
    1676:	a0 91 d3 07 	lds	r26, 0x07D3
    167a:	b0 91 d4 07 	lds	r27, 0x07D4
    167e:	0d b6       	in	r0, 0x3d	; 61
    1680:	0d 92       	st	X+, r0
    1682:	0e b6       	in	r0, 0x3e	; 62
    1684:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1686:	0e 94 1e 10 	call	0x203c	; 0x203c <xTaskIncrementTick>
    168a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    168c:	0e 94 c2 11 	call	0x2384	; 0x2384 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1690:	a0 91 d3 07 	lds	r26, 0x07D3
    1694:	b0 91 d4 07 	lds	r27, 0x07D4
    1698:	cd 91       	ld	r28, X+
    169a:	cd bf       	out	0x3d, r28	; 61
    169c:	dd 91       	ld	r29, X+
    169e:	de bf       	out	0x3e, r29	; 62
    16a0:	ff 91       	pop	r31
    16a2:	ef 91       	pop	r30
    16a4:	df 91       	pop	r29
    16a6:	cf 91       	pop	r28
    16a8:	bf 91       	pop	r27
    16aa:	af 91       	pop	r26
    16ac:	9f 91       	pop	r25
    16ae:	8f 91       	pop	r24
    16b0:	7f 91       	pop	r23
    16b2:	6f 91       	pop	r22
    16b4:	5f 91       	pop	r21
    16b6:	4f 91       	pop	r20
    16b8:	3f 91       	pop	r19
    16ba:	2f 91       	pop	r18
    16bc:	1f 91       	pop	r17
    16be:	0f 91       	pop	r16
    16c0:	ff 90       	pop	r15
    16c2:	ef 90       	pop	r14
    16c4:	df 90       	pop	r13
    16c6:	cf 90       	pop	r12
    16c8:	bf 90       	pop	r11
    16ca:	af 90       	pop	r10
    16cc:	9f 90       	pop	r9
    16ce:	8f 90       	pop	r8
    16d0:	7f 90       	pop	r7
    16d2:	6f 90       	pop	r6
    16d4:	5f 90       	pop	r5
    16d6:	4f 90       	pop	r4
    16d8:	3f 90       	pop	r3
    16da:	2f 90       	pop	r2
    16dc:	1f 90       	pop	r1
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
    16e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    16e4:	08 95       	ret

000016e6 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    16e6:	0e 94 17 0b 	call	0x162e	; 0x162e <vPortYieldFromTick>
		asm volatile ( "reti" );
    16ea:	18 95       	reti

000016ec <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    16ec:	cf 93       	push	r28
    16ee:	df 93       	push	r29
    16f0:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    16f2:	0e 94 0e 10 	call	0x201c	; 0x201c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    16f6:	80 91 9b 01 	lds	r24, 0x019B
    16fa:	90 91 9c 01 	lds	r25, 0x019C
    16fe:	89 2b       	or	r24, r25
    1700:	31 f4       	brne	.+12     	; 0x170e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1702:	80 ea       	ldi	r24, 0xA0	; 160
    1704:	91 e0       	ldi	r25, 0x01	; 1
    1706:	90 93 9c 01 	sts	0x019C, r25
    170a:	80 93 9b 01 	sts	0x019B, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    170e:	40 91 9d 01 	lds	r20, 0x019D
    1712:	50 91 9e 01 	lds	r21, 0x019E
    1716:	9e 01       	movw	r18, r28
    1718:	24 0f       	add	r18, r20
    171a:	35 1f       	adc	r19, r21
    171c:	2b 3d       	cpi	r18, 0xDB	; 219
    171e:	85 e0       	ldi	r24, 0x05	; 5
    1720:	38 07       	cpc	r19, r24
    1722:	70 f4       	brcc	.+28     	; 0x1740 <pvPortMalloc+0x54>
    1724:	42 17       	cp	r20, r18
    1726:	53 07       	cpc	r21, r19
    1728:	70 f4       	brcc	.+28     	; 0x1746 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    172a:	c0 91 9b 01 	lds	r28, 0x019B
    172e:	d0 91 9c 01 	lds	r29, 0x019C
    1732:	c4 0f       	add	r28, r20
    1734:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
    1736:	30 93 9e 01 	sts	0x019E, r19
    173a:	20 93 9d 01 	sts	0x019D, r18
    173e:	05 c0       	rjmp	.+10     	; 0x174a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1740:	c0 e0       	ldi	r28, 0x00	; 0
    1742:	d0 e0       	ldi	r29, 0x00	; 0
    1744:	02 c0       	rjmp	.+4      	; 0x174a <pvPortMalloc+0x5e>
    1746:	c0 e0       	ldi	r28, 0x00	; 0
    1748:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    174a:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    174e:	ce 01       	movw	r24, r28
    1750:	df 91       	pop	r29
    1752:	cf 91       	pop	r28
    1754:	08 95       	ret

00001756 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1756:	08 95       	ret

00001758 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1758:	1f 93       	push	r17
    175a:	cf 93       	push	r28
    175c:	df 93       	push	r29
    175e:	ec 01       	movw	r28, r24
    1760:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1762:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1764:	88 23       	and	r24, r24
    1766:	e9 f1       	breq	.+122    	; 0x17e2 <prvCopyDataToQueue+0x8a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1768:	41 11       	cpse	r20, r1
    176a:	17 c0       	rjmp	.+46     	; 0x179a <prvCopyDataToQueue+0x42>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    176c:	48 2f       	mov	r20, r24
    176e:	50 e0       	ldi	r21, 0x00	; 0
    1770:	8c 81       	ldd	r24, Y+4	; 0x04
    1772:	9d 81       	ldd	r25, Y+5	; 0x05
    1774:	0e 94 31 13 	call	0x2662	; 0x2662 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1778:	2c 8d       	ldd	r18, Y+28	; 0x1c
    177a:	8c 81       	ldd	r24, Y+4	; 0x04
    177c:	9d 81       	ldd	r25, Y+5	; 0x05
    177e:	82 0f       	add	r24, r18
    1780:	91 1d       	adc	r25, r1
    1782:	9d 83       	std	Y+5, r25	; 0x05
    1784:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1786:	2a 81       	ldd	r18, Y+2	; 0x02
    1788:	3b 81       	ldd	r19, Y+3	; 0x03
    178a:	82 17       	cp	r24, r18
    178c:	93 07       	cpc	r25, r19
    178e:	48 f1       	brcs	.+82     	; 0x17e2 <prvCopyDataToQueue+0x8a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1790:	88 81       	ld	r24, Y
    1792:	99 81       	ldd	r25, Y+1	; 0x01
    1794:	9d 83       	std	Y+5, r25	; 0x05
    1796:	8c 83       	std	Y+4, r24	; 0x04
    1798:	24 c0       	rjmp	.+72     	; 0x17e2 <prvCopyDataToQueue+0x8a>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    179a:	48 2f       	mov	r20, r24
    179c:	50 e0       	ldi	r21, 0x00	; 0
    179e:	8e 81       	ldd	r24, Y+6	; 0x06
    17a0:	9f 81       	ldd	r25, Y+7	; 0x07
    17a2:	0e 94 31 13 	call	0x2662	; 0x2662 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    17a6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    17a8:	30 e0       	ldi	r19, 0x00	; 0
    17aa:	31 95       	neg	r19
    17ac:	21 95       	neg	r18
    17ae:	31 09       	sbc	r19, r1
    17b0:	8e 81       	ldd	r24, Y+6	; 0x06
    17b2:	9f 81       	ldd	r25, Y+7	; 0x07
    17b4:	82 0f       	add	r24, r18
    17b6:	93 1f       	adc	r25, r19
    17b8:	9f 83       	std	Y+7, r25	; 0x07
    17ba:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    17bc:	68 81       	ld	r22, Y
    17be:	79 81       	ldd	r23, Y+1	; 0x01
    17c0:	86 17       	cp	r24, r22
    17c2:	97 07       	cpc	r25, r23
    17c4:	30 f4       	brcc	.+12     	; 0x17d2 <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    17c6:	8a 81       	ldd	r24, Y+2	; 0x02
    17c8:	9b 81       	ldd	r25, Y+3	; 0x03
    17ca:	28 0f       	add	r18, r24
    17cc:	39 1f       	adc	r19, r25
    17ce:	3f 83       	std	Y+7, r19	; 0x07
    17d0:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    17d2:	12 30       	cpi	r17, 0x02	; 2
    17d4:	31 f4       	brne	.+12     	; 0x17e2 <prvCopyDataToQueue+0x8a>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    17d6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17d8:	88 23       	and	r24, r24
    17da:	19 f0       	breq	.+6      	; 0x17e2 <prvCopyDataToQueue+0x8a>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    17dc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17de:	81 50       	subi	r24, 0x01	; 1
    17e0:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    17e2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17e4:	8f 5f       	subi	r24, 0xFF	; 255
    17e6:	8a 8f       	std	Y+26, r24	; 0x1a

	return xReturn;
}
    17e8:	80 e0       	ldi	r24, 0x00	; 0
    17ea:	df 91       	pop	r29
    17ec:	cf 91       	pop	r28
    17ee:	1f 91       	pop	r17
    17f0:	08 95       	ret

000017f2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    17f2:	fc 01       	movw	r30, r24
    17f4:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    17f6:	44 8d       	ldd	r20, Z+28	; 0x1c
    17f8:	44 23       	and	r20, r20
    17fa:	a1 f0       	breq	.+40     	; 0x1824 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    17fc:	50 e0       	ldi	r21, 0x00	; 0
    17fe:	26 81       	ldd	r18, Z+6	; 0x06
    1800:	37 81       	ldd	r19, Z+7	; 0x07
    1802:	24 0f       	add	r18, r20
    1804:	35 1f       	adc	r19, r21
    1806:	37 83       	std	Z+7, r19	; 0x07
    1808:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    180a:	62 81       	ldd	r22, Z+2	; 0x02
    180c:	73 81       	ldd	r23, Z+3	; 0x03
    180e:	26 17       	cp	r18, r22
    1810:	37 07       	cpc	r19, r23
    1812:	20 f0       	brcs	.+8      	; 0x181c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1814:	20 81       	ld	r18, Z
    1816:	31 81       	ldd	r19, Z+1	; 0x01
    1818:	37 83       	std	Z+7, r19	; 0x07
    181a:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    181c:	66 81       	ldd	r22, Z+6	; 0x06
    181e:	77 81       	ldd	r23, Z+7	; 0x07
    1820:	0e 94 31 13 	call	0x2662	; 0x2662 <memcpy>
    1824:	08 95       	ret

00001826 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1826:	0f 93       	push	r16
    1828:	1f 93       	push	r17
    182a:	cf 93       	push	r28
    182c:	df 93       	push	r29
    182e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1830:	0f b6       	in	r0, 0x3f	; 63
    1832:	f8 94       	cli
    1834:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1836:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1838:	18 16       	cp	r1, r24
    183a:	b4 f4       	brge	.+44     	; 0x1868 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    183c:	89 89       	ldd	r24, Y+17	; 0x11
    183e:	88 23       	and	r24, r24
    1840:	99 f0       	breq	.+38     	; 0x1868 <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1842:	8e 01       	movw	r16, r28
    1844:	0f 5e       	subi	r16, 0xEF	; 239
    1846:	1f 4f       	sbci	r17, 0xFF	; 255
    1848:	03 c0       	rjmp	.+6      	; 0x1850 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    184a:	89 89       	ldd	r24, Y+17	; 0x11
    184c:	88 23       	and	r24, r24
    184e:	61 f0       	breq	.+24     	; 0x1868 <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1850:	c8 01       	movw	r24, r16
    1852:	0e 94 9b 12 	call	0x2536	; 0x2536 <xTaskRemoveFromEventList>
    1856:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1858:	0e 94 27 13 	call	0x264e	; 0x264e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    185c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    185e:	81 50       	subi	r24, 0x01	; 1
    1860:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1862:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1864:	18 16       	cp	r1, r24
    1866:	8c f3       	brlt	.-30     	; 0x184a <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1868:	8f ef       	ldi	r24, 0xFF	; 255
    186a:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    186c:	0f 90       	pop	r0
    186e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1870:	0f b6       	in	r0, 0x3f	; 63
    1872:	f8 94       	cli
    1874:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1876:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1878:	18 16       	cp	r1, r24
    187a:	b4 f4       	brge	.+44     	; 0x18a8 <prvUnlockQueue+0x82>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    187c:	88 85       	ldd	r24, Y+8	; 0x08
    187e:	88 23       	and	r24, r24
    1880:	99 f0       	breq	.+38     	; 0x18a8 <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1882:	8e 01       	movw	r16, r28
    1884:	08 5f       	subi	r16, 0xF8	; 248
    1886:	1f 4f       	sbci	r17, 0xFF	; 255
    1888:	03 c0       	rjmp	.+6      	; 0x1890 <prvUnlockQueue+0x6a>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    188a:	88 85       	ldd	r24, Y+8	; 0x08
    188c:	88 23       	and	r24, r24
    188e:	61 f0       	breq	.+24     	; 0x18a8 <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1890:	c8 01       	movw	r24, r16
    1892:	0e 94 9b 12 	call	0x2536	; 0x2536 <xTaskRemoveFromEventList>
    1896:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1898:	0e 94 27 13 	call	0x264e	; 0x264e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    189c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    189e:	81 50       	subi	r24, 0x01	; 1
    18a0:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    18a2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    18a4:	18 16       	cp	r1, r24
    18a6:	8c f3       	brlt	.-30     	; 0x188a <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    18a8:	8f ef       	ldi	r24, 0xFF	; 255
    18aa:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    18ac:	0f 90       	pop	r0
    18ae:	0f be       	out	0x3f, r0	; 63
}
    18b0:	df 91       	pop	r29
    18b2:	cf 91       	pop	r28
    18b4:	1f 91       	pop	r17
    18b6:	0f 91       	pop	r16
    18b8:	08 95       	ret

000018ba <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    18ba:	cf 93       	push	r28
    18bc:	df 93       	push	r29
    18be:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    18c0:	0f b6       	in	r0, 0x3f	; 63
    18c2:	f8 94       	cli
    18c4:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    18c6:	88 81       	ld	r24, Y
    18c8:	99 81       	ldd	r25, Y+1	; 0x01
    18ca:	2c 8d       	ldd	r18, Y+28	; 0x1c
    18cc:	30 e0       	ldi	r19, 0x00	; 0
    18ce:	7b 8d       	ldd	r23, Y+27	; 0x1b
    18d0:	72 9f       	mul	r23, r18
    18d2:	a0 01       	movw	r20, r0
    18d4:	73 9f       	mul	r23, r19
    18d6:	50 0d       	add	r21, r0
    18d8:	11 24       	eor	r1, r1
    18da:	fc 01       	movw	r30, r24
    18dc:	e4 0f       	add	r30, r20
    18de:	f5 1f       	adc	r31, r21
    18e0:	fb 83       	std	Y+3, r31	; 0x03
    18e2:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    18e4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    18e6:	9d 83       	std	Y+5, r25	; 0x05
    18e8:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    18ea:	42 1b       	sub	r20, r18
    18ec:	53 0b       	sbc	r21, r19
    18ee:	84 0f       	add	r24, r20
    18f0:	95 1f       	adc	r25, r21
    18f2:	9f 83       	std	Y+7, r25	; 0x07
    18f4:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    18f6:	8f ef       	ldi	r24, 0xFF	; 255
    18f8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    18fa:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    18fc:	61 11       	cpse	r22, r1
    18fe:	0c c0       	rjmp	.+24     	; 0x1918 <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1900:	88 85       	ldd	r24, Y+8	; 0x08
    1902:	88 23       	and	r24, r24
    1904:	89 f0       	breq	.+34     	; 0x1928 <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1906:	ce 01       	movw	r24, r28
    1908:	08 96       	adiw	r24, 0x08	; 8
    190a:	0e 94 9b 12 	call	0x2536	; 0x2536 <xTaskRemoveFromEventList>
    190e:	81 30       	cpi	r24, 0x01	; 1
    1910:	59 f4       	brne	.+22     	; 0x1928 <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1912:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
    1916:	08 c0       	rjmp	.+16     	; 0x1928 <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1918:	ce 01       	movw	r24, r28
    191a:	08 96       	adiw	r24, 0x08	; 8
    191c:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1920:	ce 01       	movw	r24, r28
    1922:	41 96       	adiw	r24, 0x11	; 17
    1924:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1928:	0f 90       	pop	r0
    192a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    192c:	81 e0       	ldi	r24, 0x01	; 1
    192e:	df 91       	pop	r29
    1930:	cf 91       	pop	r28
    1932:	08 95       	ret

00001934 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1934:	0f 93       	push	r16
    1936:	1f 93       	push	r17
    1938:	cf 93       	push	r28
    193a:	df 93       	push	r29
    193c:	08 2f       	mov	r16, r24
    193e:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    1940:	66 23       	and	r22, r22
    1942:	c9 f0       	breq	.+50     	; 0x1976 <xQueueGenericCreate+0x42>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1944:	86 9f       	mul	r24, r22
    1946:	c0 01       	movw	r24, r0
    1948:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    194a:	80 96       	adiw	r24, 0x20	; 32
    194c:	0e 94 76 0b 	call	0x16ec	; 0x16ec <pvPortMalloc>
    1950:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
    1952:	00 97       	sbiw	r24, 0x00	; 0
    1954:	21 f4       	brne	.+8      	; 0x195e <xQueueGenericCreate+0x2a>
    1956:	16 c0       	rjmp	.+44     	; 0x1984 <xQueueGenericCreate+0x50>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1958:	d9 83       	std	Y+1, r29	; 0x01
    195a:	c8 83       	st	Y, r28
    195c:	05 c0       	rjmp	.+10     	; 0x1968 <xQueueGenericCreate+0x34>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    195e:	9c 01       	movw	r18, r24
    1960:	21 5e       	subi	r18, 0xE1	; 225
    1962:	3f 4f       	sbci	r19, 0xFF	; 255
    1964:	39 83       	std	Y+1, r19	; 0x01
    1966:	28 83       	st	Y, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    1968:	0b 8f       	std	Y+27, r16	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    196a:	1c 8f       	std	Y+28, r17	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    196c:	61 e0       	ldi	r22, 0x01	; 1
    196e:	ce 01       	movw	r24, r28
    1970:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <xQueueGenericReset>
    1974:	07 c0       	rjmp	.+14     	; 0x1984 <xQueueGenericCreate+0x50>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1976:	8f e1       	ldi	r24, 0x1F	; 31
    1978:	90 e0       	ldi	r25, 0x00	; 0
    197a:	0e 94 76 0b 	call	0x16ec	; 0x16ec <pvPortMalloc>
    197e:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
    1980:	00 97       	sbiw	r24, 0x00	; 0
    1982:	51 f7       	brne	.-44     	; 0x1958 <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
    1984:	ce 01       	movw	r24, r28
    1986:	df 91       	pop	r29
    1988:	cf 91       	pop	r28
    198a:	1f 91       	pop	r17
    198c:	0f 91       	pop	r16
    198e:	08 95       	ret

00001990 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1990:	9f 92       	push	r9
    1992:	af 92       	push	r10
    1994:	bf 92       	push	r11
    1996:	cf 92       	push	r12
    1998:	df 92       	push	r13
    199a:	ef 92       	push	r14
    199c:	ff 92       	push	r15
    199e:	0f 93       	push	r16
    19a0:	1f 93       	push	r17
    19a2:	cf 93       	push	r28
    19a4:	df 93       	push	r29
    19a6:	00 d0       	rcall	.+0      	; 0x19a8 <xQueueGenericSend+0x18>
    19a8:	00 d0       	rcall	.+0      	; 0x19aa <xQueueGenericSend+0x1a>
    19aa:	1f 92       	push	r1
    19ac:	cd b7       	in	r28, 0x3d	; 61
    19ae:	de b7       	in	r29, 0x3e	; 62
    19b0:	8c 01       	movw	r16, r24
    19b2:	6b 01       	movw	r12, r22
    19b4:	5d 83       	std	Y+5, r21	; 0x05
    19b6:	4c 83       	std	Y+4, r20	; 0x04
    19b8:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    19ba:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    19bc:	99 24       	eor	r9, r9
    19be:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    19c0:	7c 01       	movw	r14, r24
    19c2:	88 e0       	ldi	r24, 0x08	; 8
    19c4:	e8 0e       	add	r14, r24
    19c6:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19c8:	0f b6       	in	r0, 0x3f	; 63
    19ca:	f8 94       	cli
    19cc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19ce:	f8 01       	movw	r30, r16
    19d0:	92 8d       	ldd	r25, Z+26	; 0x1a
    19d2:	83 8d       	ldd	r24, Z+27	; 0x1b
    19d4:	98 17       	cp	r25, r24
    19d6:	18 f0       	brcs	.+6      	; 0x19de <xQueueGenericSend+0x4e>
    19d8:	f2 e0       	ldi	r31, 0x02	; 2
    19da:	af 12       	cpse	r10, r31
    19dc:	19 c0       	rjmp	.+50     	; 0x1a10 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19de:	4a 2d       	mov	r20, r10
    19e0:	b6 01       	movw	r22, r12
    19e2:	c8 01       	movw	r24, r16
    19e4:	0e 94 ac 0b 	call	0x1758	; 0x1758 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19e8:	f8 01       	movw	r30, r16
    19ea:	91 89       	ldd	r25, Z+17	; 0x11
    19ec:	99 23       	and	r25, r25
    19ee:	49 f0       	breq	.+18     	; 0x1a02 <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    19f0:	c8 01       	movw	r24, r16
    19f2:	41 96       	adiw	r24, 0x11	; 17
    19f4:	0e 94 9b 12 	call	0x2536	; 0x2536 <xTaskRemoveFromEventList>
    19f8:	81 30       	cpi	r24, 0x01	; 1
    19fa:	31 f4       	brne	.+12     	; 0x1a08 <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    19fc:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
    1a00:	03 c0       	rjmp	.+6      	; 0x1a08 <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1a02:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1a04:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1a08:	0f 90       	pop	r0
    1a0a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
    1a0e:	51 c0       	rjmp	.+162    	; 0x1ab2 <xQueueGenericSend+0x122>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a10:	ec 81       	ldd	r30, Y+4	; 0x04
    1a12:	fd 81       	ldd	r31, Y+5	; 0x05
    1a14:	ef 2b       	or	r30, r31
    1a16:	21 f4       	brne	.+8      	; 0x1a20 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a18:	0f 90       	pop	r0
    1a1a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1a1c:	80 e0       	ldi	r24, 0x00	; 0
    1a1e:	49 c0       	rjmp	.+146    	; 0x1ab2 <xQueueGenericSend+0x122>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a20:	b1 10       	cpse	r11, r1
    1a22:	05 c0       	rjmp	.+10     	; 0x1a2e <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a24:	ce 01       	movw	r24, r28
    1a26:	01 96       	adiw	r24, 0x01	; 1
    1a28:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a2c:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a2e:	0f 90       	pop	r0
    1a30:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a32:	0e 94 0e 10 	call	0x201c	; 0x201c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a36:	0f b6       	in	r0, 0x3f	; 63
    1a38:	f8 94       	cli
    1a3a:	0f 92       	push	r0
    1a3c:	f8 01       	movw	r30, r16
    1a3e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a40:	8f 3f       	cpi	r24, 0xFF	; 255
    1a42:	09 f4       	brne	.+2      	; 0x1a46 <xQueueGenericSend+0xb6>
    1a44:	15 8e       	std	Z+29, r1	; 0x1d
    1a46:	f8 01       	movw	r30, r16
    1a48:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a4a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a4c:	09 f4       	brne	.+2      	; 0x1a50 <xQueueGenericSend+0xc0>
    1a4e:	16 8e       	std	Z+30, r1	; 0x1e
    1a50:	0f 90       	pop	r0
    1a52:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a54:	be 01       	movw	r22, r28
    1a56:	6c 5f       	subi	r22, 0xFC	; 252
    1a58:	7f 4f       	sbci	r23, 0xFF	; 255
    1a5a:	ce 01       	movw	r24, r28
    1a5c:	01 96       	adiw	r24, 0x01	; 1
    1a5e:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xTaskCheckForTimeOut>
    1a62:	81 11       	cpse	r24, r1
    1a64:	20 c0       	rjmp	.+64     	; 0x1aa6 <xQueueGenericSend+0x116>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1a66:	0f b6       	in	r0, 0x3f	; 63
    1a68:	f8 94       	cli
    1a6a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a6c:	f8 01       	movw	r30, r16
    1a6e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a70:	0f 90       	pop	r0
    1a72:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a74:	f8 01       	movw	r30, r16
    1a76:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a78:	98 13       	cpse	r25, r24
    1a7a:	0f c0       	rjmp	.+30     	; 0x1a9a <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a7c:	6c 81       	ldd	r22, Y+4	; 0x04
    1a7e:	7d 81       	ldd	r23, Y+5	; 0x05
    1a80:	c7 01       	movw	r24, r14
    1a82:	0e 94 6f 12 	call	0x24de	; 0x24de <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1a86:	c8 01       	movw	r24, r16
    1a88:	0e 94 13 0c 	call	0x1826	; 0x1826 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1a8c:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>
    1a90:	81 11       	cpse	r24, r1
    1a92:	9a cf       	rjmp	.-204    	; 0x19c8 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1a94:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
    1a98:	97 cf       	rjmp	.-210    	; 0x19c8 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1a9a:	c8 01       	movw	r24, r16
    1a9c:	0e 94 13 0c 	call	0x1826	; 0x1826 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1aa0:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>
    1aa4:	91 cf       	rjmp	.-222    	; 0x19c8 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1aa6:	c8 01       	movw	r24, r16
    1aa8:	0e 94 13 0c 	call	0x1826	; 0x1826 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1aac:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1ab0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1ab2:	0f 90       	pop	r0
    1ab4:	0f 90       	pop	r0
    1ab6:	0f 90       	pop	r0
    1ab8:	0f 90       	pop	r0
    1aba:	0f 90       	pop	r0
    1abc:	df 91       	pop	r29
    1abe:	cf 91       	pop	r28
    1ac0:	1f 91       	pop	r17
    1ac2:	0f 91       	pop	r16
    1ac4:	ff 90       	pop	r15
    1ac6:	ef 90       	pop	r14
    1ac8:	df 90       	pop	r13
    1aca:	cf 90       	pop	r12
    1acc:	bf 90       	pop	r11
    1ace:	af 90       	pop	r10
    1ad0:	9f 90       	pop	r9
    1ad2:	08 95       	ret

00001ad4 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1ad4:	cf 93       	push	r28
    1ad6:	df 93       	push	r29
    1ad8:	fc 01       	movw	r30, r24
    1ada:	eb 01       	movw	r28, r22
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1adc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ade:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ae0:	98 17       	cp	r25, r24
    1ae2:	c8 f4       	brcc	.+50     	; 0x1b16 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    1ae4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ae6:	8f 5f       	subi	r24, 0xFF	; 255
    1ae8:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1aea:	86 8d       	ldd	r24, Z+30	; 0x1e
    1aec:	8f 3f       	cpi	r24, 0xFF	; 255
    1aee:	71 f4       	brne	.+28     	; 0x1b0c <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1af0:	81 89       	ldd	r24, Z+17	; 0x11
    1af2:	88 23       	and	r24, r24
    1af4:	91 f0       	breq	.+36     	; 0x1b1a <xQueueGiveFromISR+0x46>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1af6:	cf 01       	movw	r24, r30
    1af8:	41 96       	adiw	r24, 0x11	; 17
    1afa:	0e 94 9b 12 	call	0x2536	; 0x2536 <xTaskRemoveFromEventList>
    1afe:	88 23       	and	r24, r24
    1b00:	71 f0       	breq	.+28     	; 0x1b1e <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1b02:	20 97       	sbiw	r28, 0x00	; 0
    1b04:	71 f0       	breq	.+28     	; 0x1b22 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1b06:	81 e0       	ldi	r24, 0x01	; 1
    1b08:	88 83       	st	Y, r24
    1b0a:	0c c0       	rjmp	.+24     	; 0x1b24 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1b0c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b0e:	8f 5f       	subi	r24, 0xFF	; 255
    1b10:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	07 c0       	rjmp	.+14     	; 0x1b24 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b16:	80 e0       	ldi	r24, 0x00	; 0
    1b18:	05 c0       	rjmp	.+10     	; 0x1b24 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1b1a:	81 e0       	ldi	r24, 0x01	; 1
    1b1c:	03 c0       	rjmp	.+6      	; 0x1b24 <xQueueGiveFromISR+0x50>
    1b1e:	81 e0       	ldi	r24, 0x01	; 1
    1b20:	01 c0       	rjmp	.+2      	; 0x1b24 <xQueueGiveFromISR+0x50>
    1b22:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b24:	df 91       	pop	r29
    1b26:	cf 91       	pop	r28
    1b28:	08 95       	ret

00001b2a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1b2a:	9f 92       	push	r9
    1b2c:	af 92       	push	r10
    1b2e:	bf 92       	push	r11
    1b30:	cf 92       	push	r12
    1b32:	df 92       	push	r13
    1b34:	ef 92       	push	r14
    1b36:	ff 92       	push	r15
    1b38:	0f 93       	push	r16
    1b3a:	1f 93       	push	r17
    1b3c:	cf 93       	push	r28
    1b3e:	df 93       	push	r29
    1b40:	00 d0       	rcall	.+0      	; 0x1b42 <xQueueGenericReceive+0x18>
    1b42:	00 d0       	rcall	.+0      	; 0x1b44 <xQueueGenericReceive+0x1a>
    1b44:	1f 92       	push	r1
    1b46:	cd b7       	in	r28, 0x3d	; 61
    1b48:	de b7       	in	r29, 0x3e	; 62
    1b4a:	8c 01       	movw	r16, r24
    1b4c:	6b 01       	movw	r12, r22
    1b4e:	5d 83       	std	Y+5, r21	; 0x05
    1b50:	4c 83       	std	Y+4, r20	; 0x04
    1b52:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1b54:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1b56:	99 24       	eor	r9, r9
    1b58:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b5a:	7c 01       	movw	r14, r24
    1b5c:	81 e1       	ldi	r24, 0x11	; 17
    1b5e:	e8 0e       	add	r14, r24
    1b60:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1b62:	0f b6       	in	r0, 0x3f	; 63
    1b64:	f8 94       	cli
    1b66:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b68:	f8 01       	movw	r30, r16
    1b6a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b6c:	88 23       	and	r24, r24
    1b6e:	49 f1       	breq	.+82     	; 0x1bc2 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1b70:	e6 80       	ldd	r14, Z+6	; 0x06
    1b72:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b74:	b6 01       	movw	r22, r12
    1b76:	c8 01       	movw	r24, r16
    1b78:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1b7c:	b1 10       	cpse	r11, r1
    1b7e:	10 c0       	rjmp	.+32     	; 0x1ba0 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1b80:	f8 01       	movw	r30, r16
    1b82:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b84:	81 50       	subi	r24, 0x01	; 1
    1b86:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b88:	80 85       	ldd	r24, Z+8	; 0x08
    1b8a:	88 23       	and	r24, r24
    1b8c:	b1 f0       	breq	.+44     	; 0x1bba <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1b8e:	c8 01       	movw	r24, r16
    1b90:	08 96       	adiw	r24, 0x08	; 8
    1b92:	0e 94 9b 12 	call	0x2536	; 0x2536 <xTaskRemoveFromEventList>
    1b96:	81 30       	cpi	r24, 0x01	; 1
    1b98:	81 f4       	brne	.+32     	; 0x1bba <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1b9a:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
    1b9e:	0d c0       	rjmp	.+26     	; 0x1bba <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1ba0:	f8 01       	movw	r30, r16
    1ba2:	f7 82       	std	Z+7, r15	; 0x07
    1ba4:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ba6:	81 89       	ldd	r24, Z+17	; 0x11
    1ba8:	88 23       	and	r24, r24
    1baa:	39 f0       	breq	.+14     	; 0x1bba <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bac:	c8 01       	movw	r24, r16
    1bae:	41 96       	adiw	r24, 0x11	; 17
    1bb0:	0e 94 9b 12 	call	0x2536	; 0x2536 <xTaskRemoveFromEventList>
    1bb4:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1bb6:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1bba:	0f 90       	pop	r0
    1bbc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1bbe:	81 e0       	ldi	r24, 0x01	; 1
    1bc0:	4f c0       	rjmp	.+158    	; 0x1c60 <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1bc2:	4c 81       	ldd	r20, Y+4	; 0x04
    1bc4:	5d 81       	ldd	r21, Y+5	; 0x05
    1bc6:	45 2b       	or	r20, r21
    1bc8:	21 f4       	brne	.+8      	; 0x1bd2 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1bca:	0f 90       	pop	r0
    1bcc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1bce:	80 e0       	ldi	r24, 0x00	; 0
    1bd0:	47 c0       	rjmp	.+142    	; 0x1c60 <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
    1bd2:	a1 10       	cpse	r10, r1
    1bd4:	05 c0       	rjmp	.+10     	; 0x1be0 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1bd6:	ce 01       	movw	r24, r28
    1bd8:	01 96       	adiw	r24, 0x01	; 1
    1bda:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1bde:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1be4:	0e 94 0e 10 	call	0x201c	; 0x201c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1be8:	0f b6       	in	r0, 0x3f	; 63
    1bea:	f8 94       	cli
    1bec:	0f 92       	push	r0
    1bee:	f8 01       	movw	r30, r16
    1bf0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1bf2:	8f 3f       	cpi	r24, 0xFF	; 255
    1bf4:	09 f4       	brne	.+2      	; 0x1bf8 <xQueueGenericReceive+0xce>
    1bf6:	15 8e       	std	Z+29, r1	; 0x1d
    1bf8:	f8 01       	movw	r30, r16
    1bfa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bfc:	8f 3f       	cpi	r24, 0xFF	; 255
    1bfe:	09 f4       	brne	.+2      	; 0x1c02 <xQueueGenericReceive+0xd8>
    1c00:	16 8e       	std	Z+30, r1	; 0x1e
    1c02:	0f 90       	pop	r0
    1c04:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c06:	be 01       	movw	r22, r28
    1c08:	6c 5f       	subi	r22, 0xFC	; 252
    1c0a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c0c:	ce 01       	movw	r24, r28
    1c0e:	01 96       	adiw	r24, 0x01	; 1
    1c10:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xTaskCheckForTimeOut>
    1c14:	81 11       	cpse	r24, r1
    1c16:	1e c0       	rjmp	.+60     	; 0x1c54 <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1c18:	0f b6       	in	r0, 0x3f	; 63
    1c1a:	f8 94       	cli
    1c1c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1c1e:	f8 01       	movw	r30, r16
    1c20:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1c22:	0f 90       	pop	r0
    1c24:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c26:	81 11       	cpse	r24, r1
    1c28:	0f c0       	rjmp	.+30     	; 0x1c48 <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c2a:	6c 81       	ldd	r22, Y+4	; 0x04
    1c2c:	7d 81       	ldd	r23, Y+5	; 0x05
    1c2e:	c7 01       	movw	r24, r14
    1c30:	0e 94 6f 12 	call	0x24de	; 0x24de <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c34:	c8 01       	movw	r24, r16
    1c36:	0e 94 13 0c 	call	0x1826	; 0x1826 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c3a:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>
    1c3e:	81 11       	cpse	r24, r1
    1c40:	90 cf       	rjmp	.-224    	; 0x1b62 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1c42:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
    1c46:	8d cf       	rjmp	.-230    	; 0x1b62 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c48:	c8 01       	movw	r24, r16
    1c4a:	0e 94 13 0c 	call	0x1826	; 0x1826 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c4e:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>
    1c52:	87 cf       	rjmp	.-242    	; 0x1b62 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1c54:	c8 01       	movw	r24, r16
    1c56:	0e 94 13 0c 	call	0x1826	; 0x1826 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c5a:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1c5e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1c60:	0f 90       	pop	r0
    1c62:	0f 90       	pop	r0
    1c64:	0f 90       	pop	r0
    1c66:	0f 90       	pop	r0
    1c68:	0f 90       	pop	r0
    1c6a:	df 91       	pop	r29
    1c6c:	cf 91       	pop	r28
    1c6e:	1f 91       	pop	r17
    1c70:	0f 91       	pop	r16
    1c72:	ff 90       	pop	r15
    1c74:	ef 90       	pop	r14
    1c76:	df 90       	pop	r13
    1c78:	cf 90       	pop	r12
    1c7a:	bf 90       	pop	r11
    1c7c:	af 90       	pop	r10
    1c7e:	9f 90       	pop	r9
    1c80:	08 95       	ret

00001c82 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1c82:	0f 93       	push	r16
    1c84:	1f 93       	push	r17
    1c86:	cf 93       	push	r28
    1c88:	df 93       	push	r29
    1c8a:	ec 01       	movw	r28, r24
    1c8c:	8a 01       	movw	r16, r20
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c8e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c90:	88 23       	and	r24, r24
    1c92:	f1 f0       	breq	.+60     	; 0x1cd0 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c94:	ce 01       	movw	r24, r28
    1c96:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1c9a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c9c:	81 50       	subi	r24, 0x01	; 1
    1c9e:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1ca0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1ca2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ca4:	81 f4       	brne	.+32     	; 0x1cc6 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ca6:	88 85       	ldd	r24, Y+8	; 0x08
    1ca8:	88 23       	and	r24, r24
    1caa:	a1 f0       	breq	.+40     	; 0x1cd4 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cac:	ce 01       	movw	r24, r28
    1cae:	08 96       	adiw	r24, 0x08	; 8
    1cb0:	0e 94 9b 12 	call	0x2536	; 0x2536 <xTaskRemoveFromEventList>
    1cb4:	88 23       	and	r24, r24
    1cb6:	81 f0       	breq	.+32     	; 0x1cd8 <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1cb8:	01 15       	cp	r16, r1
    1cba:	11 05       	cpc	r17, r1
    1cbc:	79 f0       	breq	.+30     	; 0x1cdc <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	f8 01       	movw	r30, r16
    1cc2:	80 83       	st	Z, r24
    1cc4:	0c c0       	rjmp	.+24     	; 0x1cde <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1cc6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1cc8:	8f 5f       	subi	r24, 0xFF	; 255
    1cca:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	07 c0       	rjmp	.+14     	; 0x1cde <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1cd0:	80 e0       	ldi	r24, 0x00	; 0
    1cd2:	05 c0       	rjmp	.+10     	; 0x1cde <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	03 c0       	rjmp	.+6      	; 0x1cde <xQueueReceiveFromISR+0x5c>
    1cd8:	81 e0       	ldi	r24, 0x01	; 1
    1cda:	01 c0       	rjmp	.+2      	; 0x1cde <xQueueReceiveFromISR+0x5c>
    1cdc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1cde:	df 91       	pop	r29
    1ce0:	cf 91       	pop	r28
    1ce2:	1f 91       	pop	r17
    1ce4:	0f 91       	pop	r16
    1ce6:	08 95       	ret

00001ce8 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1ce8:	e0 91 9b 07 	lds	r30, 0x079B
    1cec:	f0 91 9c 07 	lds	r31, 0x079C
    1cf0:	80 81       	ld	r24, Z
    1cf2:	81 11       	cpse	r24, r1
    1cf4:	07 c0       	rjmp	.+14     	; 0x1d04 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1cf6:	8f ef       	ldi	r24, 0xFF	; 255
    1cf8:	9f ef       	ldi	r25, 0xFF	; 255
    1cfa:	90 93 7d 07 	sts	0x077D, r25
    1cfe:	80 93 7c 07 	sts	0x077C, r24
    1d02:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1d04:	e0 91 9b 07 	lds	r30, 0x079B
    1d08:	f0 91 9c 07 	lds	r31, 0x079C
    1d0c:	05 80       	ldd	r0, Z+5	; 0x05
    1d0e:	f6 81       	ldd	r31, Z+6	; 0x06
    1d10:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    1d12:	06 80       	ldd	r0, Z+6	; 0x06
    1d14:	f7 81       	ldd	r31, Z+7	; 0x07
    1d16:	e0 2d       	mov	r30, r0
    1d18:	82 81       	ldd	r24, Z+2	; 0x02
    1d1a:	93 81       	ldd	r25, Z+3	; 0x03
    1d1c:	90 93 7d 07 	sts	0x077D, r25
    1d20:	80 93 7c 07 	sts	0x077C, r24
    1d24:	08 95       	ret

00001d26 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1d26:	cf ea       	ldi	r28, 0xAF	; 175
    1d28:	d7 e0       	ldi	r29, 0x07	; 7
    1d2a:	88 81       	ld	r24, Y
    1d2c:	82 30       	cpi	r24, 0x02	; 2
    1d2e:	08 f4       	brcc	.+2      	; 0x1d32 <prvIdleTask+0xc>
    1d30:	ff cf       	rjmp	.-2      	; 0x1d30 <prvIdleTask+0xa>
			{
				taskYIELD();
    1d32:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
    1d36:	f9 cf       	rjmp	.-14     	; 0x1d2a <prvIdleTask+0x4>

00001d38 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    1d38:	cf 93       	push	r28
    1d3a:	df 93       	push	r29
    1d3c:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1d3e:	e0 91 d3 07 	lds	r30, 0x07D3
    1d42:	f0 91 d4 07 	lds	r31, 0x07D4
    1d46:	93 83       	std	Z+3, r25	; 0x03
    1d48:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1d4a:	80 91 84 07 	lds	r24, 0x0784
    1d4e:	90 91 85 07 	lds	r25, 0x0785
    1d52:	c8 17       	cp	r28, r24
    1d54:	d9 07       	cpc	r29, r25
    1d56:	68 f4       	brcc	.+26     	; 0x1d72 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1d58:	60 91 d3 07 	lds	r22, 0x07D3
    1d5c:	70 91 d4 07 	lds	r23, 0x07D4
    1d60:	80 91 99 07 	lds	r24, 0x0799
    1d64:	90 91 9a 07 	lds	r25, 0x079A
    1d68:	6e 5f       	subi	r22, 0xFE	; 254
    1d6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d6c:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInsert>
    1d70:	17 c0       	rjmp	.+46     	; 0x1da0 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1d72:	60 91 d3 07 	lds	r22, 0x07D3
    1d76:	70 91 d4 07 	lds	r23, 0x07D4
    1d7a:	80 91 9b 07 	lds	r24, 0x079B
    1d7e:	90 91 9c 07 	lds	r25, 0x079C
    1d82:	6e 5f       	subi	r22, 0xFE	; 254
    1d84:	7f 4f       	sbci	r23, 0xFF	; 255
    1d86:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1d8a:	80 91 7c 07 	lds	r24, 0x077C
    1d8e:	90 91 7d 07 	lds	r25, 0x077D
    1d92:	c8 17       	cp	r28, r24
    1d94:	d9 07       	cpc	r29, r25
    1d96:	20 f4       	brcc	.+8      	; 0x1da0 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1d98:	d0 93 7d 07 	sts	0x077D, r29
    1d9c:	c0 93 7c 07 	sts	0x077C, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1da0:	df 91       	pop	r29
    1da2:	cf 91       	pop	r28
    1da4:	08 95       	ret

00001da6 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    1da6:	4f 92       	push	r4
    1da8:	5f 92       	push	r5
    1daa:	6f 92       	push	r6
    1dac:	7f 92       	push	r7
    1dae:	8f 92       	push	r8
    1db0:	9f 92       	push	r9
    1db2:	af 92       	push	r10
    1db4:	bf 92       	push	r11
    1db6:	cf 92       	push	r12
    1db8:	df 92       	push	r13
    1dba:	ef 92       	push	r14
    1dbc:	ff 92       	push	r15
    1dbe:	0f 93       	push	r16
    1dc0:	1f 93       	push	r17
    1dc2:	cf 93       	push	r28
    1dc4:	df 93       	push	r29
    1dc6:	4c 01       	movw	r8, r24
    1dc8:	5b 01       	movw	r10, r22
    1dca:	2a 01       	movw	r4, r20
    1dcc:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1dce:	c1 14       	cp	r12, r1
    1dd0:	d1 04       	cpc	r13, r1
    1dd2:	39 f4       	brne	.+14     	; 0x1de2 <xTaskGenericCreate+0x3c>
    1dd4:	ca 01       	movw	r24, r20
    1dd6:	0e 94 76 0b 	call	0x16ec	; 0x16ec <pvPortMalloc>
    1dda:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
    1ddc:	00 97       	sbiw	r24, 0x00	; 0
    1dde:	09 f4       	brne	.+2      	; 0x1de2 <xTaskGenericCreate+0x3c>
    1de0:	d9 c0       	rjmp	.+434    	; 0x1f94 <xTaskGenericCreate+0x1ee>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    1de2:	86 e2       	ldi	r24, 0x26	; 38
    1de4:	90 e0       	ldi	r25, 0x00	; 0
    1de6:	0e 94 76 0b 	call	0x16ec	; 0x16ec <pvPortMalloc>
    1dea:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
    1dec:	00 97       	sbiw	r24, 0x00	; 0
    1dee:	71 f0       	breq	.+28     	; 0x1e0c <xTaskGenericCreate+0x66>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    1df0:	d8 8e       	std	Y+24, r13	; 0x18
    1df2:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    1df4:	81 e0       	ldi	r24, 0x01	; 1
    1df6:	48 1a       	sub	r4, r24
    1df8:	51 08       	sbc	r5, r1
    1dfa:	c4 0c       	add	r12, r4
    1dfc:	d5 1c       	adc	r13, r5
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1dfe:	d5 01       	movw	r26, r10
    1e00:	8c 91       	ld	r24, X
    1e02:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1e04:	8c 91       	ld	r24, X
    1e06:	81 11       	cpse	r24, r1
    1e08:	05 c0       	rjmp	.+10     	; 0x1e14 <xTaskGenericCreate+0x6e>
    1e0a:	15 c0       	rjmp	.+42     	; 0x1e36 <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    1e0c:	c6 01       	movw	r24, r12
    1e0e:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortFree>
    1e12:	c0 c0       	rjmp	.+384    	; 0x1f94 <xTaskGenericCreate+0x1ee>
    1e14:	ae 01       	movw	r20, r28
    1e16:	46 5e       	subi	r20, 0xE6	; 230
    1e18:	5f 4f       	sbci	r21, 0xFF	; 255
    1e1a:	f5 01       	movw	r30, r10
    1e1c:	31 96       	adiw	r30, 0x01	; 1
		pxTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1e1e:	27 e0       	ldi	r18, 0x07	; 7
    1e20:	cf 01       	movw	r24, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1e22:	31 91       	ld	r19, Z+
    1e24:	da 01       	movw	r26, r20
    1e26:	3d 93       	st	X+, r19
    1e28:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1e2a:	dc 01       	movw	r26, r24
    1e2c:	8c 91       	ld	r24, X
    1e2e:	88 23       	and	r24, r24
    1e30:	11 f0       	breq	.+4      	; 0x1e36 <xTaskGenericCreate+0x90>
    1e32:	21 50       	subi	r18, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1e34:	a9 f7       	brne	.-22     	; 0x1e20 <xTaskGenericCreate+0x7a>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1e36:	18 a2       	std	Y+32, r1	; 0x20
    1e38:	10 2f       	mov	r17, r16
    1e3a:	04 30       	cpi	r16, 0x04	; 4
    1e3c:	08 f0       	brcs	.+2      	; 0x1e40 <xTaskGenericCreate+0x9a>
    1e3e:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    1e40:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1e42:	5e 01       	movw	r10, r28
    1e44:	b2 e0       	ldi	r27, 0x02	; 2
    1e46:	ab 0e       	add	r10, r27
    1e48:	b1 1c       	adc	r11, r1
    1e4a:	c5 01       	movw	r24, r10
    1e4c:	0e 94 9c 09 	call	0x1338	; 0x1338 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1e50:	ce 01       	movw	r24, r28
    1e52:	0c 96       	adiw	r24, 0x0c	; 12
    1e54:	0e 94 9c 09 	call	0x1338	; 0x1338 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1e58:	d9 87       	std	Y+9, r29	; 0x09
    1e5a:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e5c:	84 e0       	ldi	r24, 0x04	; 4
    1e5e:	90 e0       	ldi	r25, 0x00	; 0
    1e60:	81 1b       	sub	r24, r17
    1e62:	91 09       	sbc	r25, r1
    1e64:	9d 87       	std	Y+13, r25	; 0x0d
    1e66:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1e68:	db 8b       	std	Y+19, r29	; 0x13
    1e6a:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    1e6c:	19 a2       	std	Y+33, r1	; 0x21
    1e6e:	1a a2       	std	Y+34, r1	; 0x22
    1e70:	1b a2       	std	Y+35, r1	; 0x23
    1e72:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    1e74:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1e76:	a3 01       	movw	r20, r6
    1e78:	b4 01       	movw	r22, r8
    1e7a:	c6 01       	movw	r24, r12
    1e7c:	0e 94 18 0a 	call	0x1430	; 0x1430 <pxPortInitialiseStack>
    1e80:	99 83       	std	Y+1, r25	; 0x01
    1e82:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    1e84:	e1 14       	cp	r14, r1
    1e86:	f1 04       	cpc	r15, r1
    1e88:	19 f0       	breq	.+6      	; 0x1e90 <xTaskGenericCreate+0xea>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1e8a:	f7 01       	movw	r30, r14
    1e8c:	d1 83       	std	Z+1, r29	; 0x01
    1e8e:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    1e90:	0f b6       	in	r0, 0x3f	; 63
    1e92:	f8 94       	cli
    1e94:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1e96:	80 91 86 07 	lds	r24, 0x0786
    1e9a:	8f 5f       	subi	r24, 0xFF	; 255
    1e9c:	80 93 86 07 	sts	0x0786, r24
			if( pxCurrentTCB == NULL )
    1ea0:	80 91 d3 07 	lds	r24, 0x07D3
    1ea4:	90 91 d4 07 	lds	r25, 0x07D4
    1ea8:	89 2b       	or	r24, r25
    1eaa:	a9 f5       	brne	.+106    	; 0x1f16 <xTaskGenericCreate+0x170>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1eac:	d0 93 d4 07 	sts	0x07D4, r29
    1eb0:	c0 93 d3 07 	sts	0x07D3, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1eb4:	80 91 86 07 	lds	r24, 0x0786
    1eb8:	81 30       	cpi	r24, 0x01	; 1
    1eba:	e1 f5       	brne	.+120    	; 0x1f34 <xTaskGenericCreate+0x18e>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1ebc:	8f ea       	ldi	r24, 0xAF	; 175
    1ebe:	97 e0       	ldi	r25, 0x07	; 7
    1ec0:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
    1ec4:	88 eb       	ldi	r24, 0xB8	; 184
    1ec6:	97 e0       	ldi	r25, 0x07	; 7
    1ec8:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
    1ecc:	81 ec       	ldi	r24, 0xC1	; 193
    1ece:	97 e0       	ldi	r25, 0x07	; 7
    1ed0:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
    1ed4:	8a ec       	ldi	r24, 0xCA	; 202
    1ed6:	97 e0       	ldi	r25, 0x07	; 7
    1ed8:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    1edc:	86 ea       	ldi	r24, 0xA6	; 166
    1ede:	97 e0       	ldi	r25, 0x07	; 7
    1ee0:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1ee4:	8d e9       	ldi	r24, 0x9D	; 157
    1ee6:	97 e0       	ldi	r25, 0x07	; 7
    1ee8:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1eec:	80 e9       	ldi	r24, 0x90	; 144
    1eee:	97 e0       	ldi	r25, 0x07	; 7
    1ef0:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    1ef4:	87 e8       	ldi	r24, 0x87	; 135
    1ef6:	97 e0       	ldi	r25, 0x07	; 7
    1ef8:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1efc:	86 ea       	ldi	r24, 0xA6	; 166
    1efe:	97 e0       	ldi	r25, 0x07	; 7
    1f00:	90 93 9c 07 	sts	0x079C, r25
    1f04:	80 93 9b 07 	sts	0x079B, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1f08:	8d e9       	ldi	r24, 0x9D	; 157
    1f0a:	97 e0       	ldi	r25, 0x07	; 7
    1f0c:	90 93 9a 07 	sts	0x079A, r25
    1f10:	80 93 99 07 	sts	0x0799, r24
    1f14:	0f c0       	rjmp	.+30     	; 0x1f34 <xTaskGenericCreate+0x18e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1f16:	80 91 82 07 	lds	r24, 0x0782
    1f1a:	81 11       	cpse	r24, r1
    1f1c:	0b c0       	rjmp	.+22     	; 0x1f34 <xTaskGenericCreate+0x18e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1f1e:	e0 91 d3 07 	lds	r30, 0x07D3
    1f22:	f0 91 d4 07 	lds	r31, 0x07D4
    1f26:	86 89       	ldd	r24, Z+22	; 0x16
    1f28:	08 17       	cp	r16, r24
    1f2a:	20 f0       	brcs	.+8      	; 0x1f34 <xTaskGenericCreate+0x18e>
					{
						pxCurrentTCB = pxNewTCB;
    1f2c:	d0 93 d4 07 	sts	0x07D4, r29
    1f30:	c0 93 d3 07 	sts	0x07D3, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    1f34:	80 91 7e 07 	lds	r24, 0x077E
    1f38:	8f 5f       	subi	r24, 0xFF	; 255
    1f3a:	80 93 7e 07 	sts	0x077E, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    1f3e:	8e 89       	ldd	r24, Y+22	; 0x16
    1f40:	90 91 83 07 	lds	r25, 0x0783
    1f44:	98 17       	cp	r25, r24
    1f46:	10 f4       	brcc	.+4      	; 0x1f4c <xTaskGenericCreate+0x1a6>
    1f48:	80 93 83 07 	sts	0x0783, r24
    1f4c:	90 e0       	ldi	r25, 0x00	; 0
    1f4e:	9c 01       	movw	r18, r24
    1f50:	22 0f       	add	r18, r18
    1f52:	33 1f       	adc	r19, r19
    1f54:	22 0f       	add	r18, r18
    1f56:	33 1f       	adc	r19, r19
    1f58:	22 0f       	add	r18, r18
    1f5a:	33 1f       	adc	r19, r19
    1f5c:	82 0f       	add	r24, r18
    1f5e:	93 1f       	adc	r25, r19
    1f60:	b5 01       	movw	r22, r10
    1f62:	81 55       	subi	r24, 0x51	; 81
    1f64:	98 4f       	sbci	r25, 0xF8	; 248
    1f66:	0e 94 a0 09 	call	0x1340	; 0x1340 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1f6a:	0f 90       	pop	r0
    1f6c:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1f6e:	80 91 82 07 	lds	r24, 0x0782
    1f72:	88 23       	and	r24, r24
    1f74:	59 f0       	breq	.+22     	; 0x1f8c <xTaskGenericCreate+0x1e6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1f76:	e0 91 d3 07 	lds	r30, 0x07D3
    1f7a:	f0 91 d4 07 	lds	r31, 0x07D4
    1f7e:	86 89       	ldd	r24, Z+22	; 0x16
    1f80:	80 17       	cp	r24, r16
    1f82:	30 f4       	brcc	.+12     	; 0x1f90 <xTaskGenericCreate+0x1ea>
			{
				taskYIELD_IF_USING_PREEMPTION();
    1f84:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
    1f88:	81 e0       	ldi	r24, 0x01	; 1
    1f8a:	05 c0       	rjmp	.+10     	; 0x1f96 <xTaskGenericCreate+0x1f0>
    1f8c:	81 e0       	ldi	r24, 0x01	; 1
    1f8e:	03 c0       	rjmp	.+6      	; 0x1f96 <xTaskGenericCreate+0x1f0>
    1f90:	81 e0       	ldi	r24, 0x01	; 1
    1f92:	01 c0       	rjmp	.+2      	; 0x1f96 <xTaskGenericCreate+0x1f0>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f94:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    1f96:	df 91       	pop	r29
    1f98:	cf 91       	pop	r28
    1f9a:	1f 91       	pop	r17
    1f9c:	0f 91       	pop	r16
    1f9e:	ff 90       	pop	r15
    1fa0:	ef 90       	pop	r14
    1fa2:	df 90       	pop	r13
    1fa4:	cf 90       	pop	r12
    1fa6:	bf 90       	pop	r11
    1fa8:	af 90       	pop	r10
    1faa:	9f 90       	pop	r9
    1fac:	8f 90       	pop	r8
    1fae:	7f 90       	pop	r7
    1fb0:	6f 90       	pop	r6
    1fb2:	5f 90       	pop	r5
    1fb4:	4f 90       	pop	r4
    1fb6:	08 95       	ret

00001fb8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1fb8:	af 92       	push	r10
    1fba:	bf 92       	push	r11
    1fbc:	cf 92       	push	r12
    1fbe:	df 92       	push	r13
    1fc0:	ef 92       	push	r14
    1fc2:	ff 92       	push	r15
    1fc4:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    1fc6:	a1 2c       	mov	r10, r1
    1fc8:	b1 2c       	mov	r11, r1
    1fca:	c1 2c       	mov	r12, r1
    1fcc:	d1 2c       	mov	r13, r1
    1fce:	e1 2c       	mov	r14, r1
    1fd0:	f1 2c       	mov	r15, r1
    1fd2:	00 e0       	ldi	r16, 0x00	; 0
    1fd4:	20 e0       	ldi	r18, 0x00	; 0
    1fd6:	30 e0       	ldi	r19, 0x00	; 0
    1fd8:	45 e5       	ldi	r20, 0x55	; 85
    1fda:	50 e0       	ldi	r21, 0x00	; 0
    1fdc:	61 e2       	ldi	r22, 0x21	; 33
    1fde:	71 e0       	ldi	r23, 0x01	; 1
    1fe0:	83 e9       	ldi	r24, 0x93	; 147
    1fe2:	9e e0       	ldi	r25, 0x0E	; 14
    1fe4:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1fe8:	81 30       	cpi	r24, 0x01	; 1
    1fea:	81 f4       	brne	.+32     	; 0x200c <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1fec:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1fee:	8f ef       	ldi	r24, 0xFF	; 255
    1ff0:	9f ef       	ldi	r25, 0xFF	; 255
    1ff2:	90 93 7d 07 	sts	0x077D, r25
    1ff6:	80 93 7c 07 	sts	0x077C, r24
		xSchedulerRunning = pdTRUE;
    1ffa:	81 e0       	ldi	r24, 0x01	; 1
    1ffc:	80 93 82 07 	sts	0x0782, r24
		xTickCount = ( TickType_t ) 0U;
    2000:	10 92 85 07 	sts	0x0785, r1
    2004:	10 92 84 07 	sts	0x0784, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2008:	0e 94 84 0a 	call	0x1508	; 0x1508 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    200c:	0f 91       	pop	r16
    200e:	ff 90       	pop	r15
    2010:	ef 90       	pop	r14
    2012:	df 90       	pop	r13
    2014:	cf 90       	pop	r12
    2016:	bf 90       	pop	r11
    2018:	af 90       	pop	r10
    201a:	08 95       	ret

0000201c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    201c:	80 91 7b 07 	lds	r24, 0x077B
    2020:	8f 5f       	subi	r24, 0xFF	; 255
    2022:	80 93 7b 07 	sts	0x077B, r24
    2026:	08 95       	ret

00002028 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    2028:	0f b6       	in	r0, 0x3f	; 63
    202a:	f8 94       	cli
    202c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    202e:	80 91 84 07 	lds	r24, 0x0784
    2032:	90 91 85 07 	lds	r25, 0x0785
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2036:	0f 90       	pop	r0
    2038:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    203a:	08 95       	ret

0000203c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    203c:	cf 92       	push	r12
    203e:	df 92       	push	r13
    2040:	ef 92       	push	r14
    2042:	ff 92       	push	r15
    2044:	0f 93       	push	r16
    2046:	1f 93       	push	r17
    2048:	cf 93       	push	r28
    204a:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    204c:	80 91 7b 07 	lds	r24, 0x077B
    2050:	81 11       	cpse	r24, r1
    2052:	9a c0       	rjmp	.+308    	; 0x2188 <xTaskIncrementTick+0x14c>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    2054:	80 91 84 07 	lds	r24, 0x0784
    2058:	90 91 85 07 	lds	r25, 0x0785
    205c:	01 96       	adiw	r24, 0x01	; 1
    205e:	90 93 85 07 	sts	0x0785, r25
    2062:	80 93 84 07 	sts	0x0784, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2066:	e0 90 84 07 	lds	r14, 0x0784
    206a:	f0 90 85 07 	lds	r15, 0x0785

			if( xConstTickCount == ( TickType_t ) 0U )
    206e:	e1 14       	cp	r14, r1
    2070:	f1 04       	cpc	r15, r1
    2072:	b9 f4       	brne	.+46     	; 0x20a2 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
    2074:	80 91 9b 07 	lds	r24, 0x079B
    2078:	90 91 9c 07 	lds	r25, 0x079C
    207c:	20 91 99 07 	lds	r18, 0x0799
    2080:	30 91 9a 07 	lds	r19, 0x079A
    2084:	30 93 9c 07 	sts	0x079C, r19
    2088:	20 93 9b 07 	sts	0x079B, r18
    208c:	90 93 9a 07 	sts	0x079A, r25
    2090:	80 93 99 07 	sts	0x0799, r24
    2094:	80 91 7f 07 	lds	r24, 0x077F
    2098:	8f 5f       	subi	r24, 0xFF	; 255
    209a:	80 93 7f 07 	sts	0x077F, r24
    209e:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    20a2:	80 91 7c 07 	lds	r24, 0x077C
    20a6:	90 91 7d 07 	lds	r25, 0x077D
    20aa:	e8 16       	cp	r14, r24
    20ac:	f9 06       	cpc	r15, r25
    20ae:	08 f4       	brcc	.+2      	; 0x20b2 <xTaskIncrementTick+0x76>
    20b0:	54 c0       	rjmp	.+168    	; 0x215a <xTaskIncrementTick+0x11e>
    20b2:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    20b4:	cc 24       	eor	r12, r12
    20b6:	c3 94       	inc	r12
    20b8:	01 c0       	rjmp	.+2      	; 0x20bc <xTaskIncrementTick+0x80>
    20ba:	dc 2c       	mov	r13, r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    20bc:	e0 91 9b 07 	lds	r30, 0x079B
    20c0:	f0 91 9c 07 	lds	r31, 0x079C
    20c4:	80 81       	ld	r24, Z
    20c6:	81 11       	cpse	r24, r1
    20c8:	07 c0       	rjmp	.+14     	; 0x20d8 <xTaskIncrementTick+0x9c>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    20ca:	8f ef       	ldi	r24, 0xFF	; 255
    20cc:	9f ef       	ldi	r25, 0xFF	; 255
    20ce:	90 93 7d 07 	sts	0x077D, r25
    20d2:	80 93 7c 07 	sts	0x077C, r24
						break;
    20d6:	42 c0       	rjmp	.+132    	; 0x215c <xTaskIncrementTick+0x120>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    20d8:	e0 91 9b 07 	lds	r30, 0x079B
    20dc:	f0 91 9c 07 	lds	r31, 0x079C
    20e0:	05 80       	ldd	r0, Z+5	; 0x05
    20e2:	f6 81       	ldd	r31, Z+6	; 0x06
    20e4:	e0 2d       	mov	r30, r0
    20e6:	c6 81       	ldd	r28, Z+6	; 0x06
    20e8:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    20ea:	2a 81       	ldd	r18, Y+2	; 0x02
    20ec:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    20ee:	e2 16       	cp	r14, r18
    20f0:	f3 06       	cpc	r15, r19
    20f2:	28 f4       	brcc	.+10     	; 0x20fe <xTaskIncrementTick+0xc2>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    20f4:	30 93 7d 07 	sts	0x077D, r19
    20f8:	20 93 7c 07 	sts	0x077C, r18
							break;
    20fc:	2f c0       	rjmp	.+94     	; 0x215c <xTaskIncrementTick+0x120>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    20fe:	8e 01       	movw	r16, r28
    2100:	0e 5f       	subi	r16, 0xFE	; 254
    2102:	1f 4f       	sbci	r17, 0xFF	; 255
    2104:	c8 01       	movw	r24, r16
    2106:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    210a:	8c 89       	ldd	r24, Y+20	; 0x14
    210c:	9d 89       	ldd	r25, Y+21	; 0x15
    210e:	89 2b       	or	r24, r25
    2110:	21 f0       	breq	.+8      	; 0x211a <xTaskIncrementTick+0xde>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2112:	ce 01       	movw	r24, r28
    2114:	0c 96       	adiw	r24, 0x0c	; 12
    2116:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    211a:	2e 89       	ldd	r18, Y+22	; 0x16
    211c:	80 91 83 07 	lds	r24, 0x0783
    2120:	82 17       	cp	r24, r18
    2122:	10 f4       	brcc	.+4      	; 0x2128 <xTaskIncrementTick+0xec>
    2124:	20 93 83 07 	sts	0x0783, r18
    2128:	30 e0       	ldi	r19, 0x00	; 0
    212a:	c9 01       	movw	r24, r18
    212c:	88 0f       	add	r24, r24
    212e:	99 1f       	adc	r25, r25
    2130:	88 0f       	add	r24, r24
    2132:	99 1f       	adc	r25, r25
    2134:	88 0f       	add	r24, r24
    2136:	99 1f       	adc	r25, r25
    2138:	82 0f       	add	r24, r18
    213a:	93 1f       	adc	r25, r19
    213c:	b8 01       	movw	r22, r16
    213e:	81 55       	subi	r24, 0x51	; 81
    2140:	98 4f       	sbci	r25, 0xF8	; 248
    2142:	0e 94 a0 09 	call	0x1340	; 0x1340 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2146:	e0 91 d3 07 	lds	r30, 0x07D3
    214a:	f0 91 d4 07 	lds	r31, 0x07D4
    214e:	9e 89       	ldd	r25, Y+22	; 0x16
    2150:	86 89       	ldd	r24, Z+22	; 0x16
    2152:	98 17       	cp	r25, r24
    2154:	08 f0       	brcs	.+2      	; 0x2158 <xTaskIncrementTick+0x11c>
    2156:	b1 cf       	rjmp	.-158    	; 0x20ba <xTaskIncrementTick+0x7e>
    2158:	b1 cf       	rjmp	.-158    	; 0x20bc <xTaskIncrementTick+0x80>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    215a:	d1 2c       	mov	r13, r1
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    215c:	e0 91 d3 07 	lds	r30, 0x07D3
    2160:	f0 91 d4 07 	lds	r31, 0x07D4
    2164:	86 89       	ldd	r24, Z+22	; 0x16
    2166:	90 e0       	ldi	r25, 0x00	; 0
    2168:	fc 01       	movw	r30, r24
    216a:	ee 0f       	add	r30, r30
    216c:	ff 1f       	adc	r31, r31
    216e:	ee 0f       	add	r30, r30
    2170:	ff 1f       	adc	r31, r31
    2172:	ee 0f       	add	r30, r30
    2174:	ff 1f       	adc	r31, r31
    2176:	8e 0f       	add	r24, r30
    2178:	9f 1f       	adc	r25, r31
    217a:	fc 01       	movw	r30, r24
    217c:	e1 55       	subi	r30, 0x51	; 81
    217e:	f8 4f       	sbci	r31, 0xF8	; 248
    2180:	80 81       	ld	r24, Z
    2182:	82 30       	cpi	r24, 0x02	; 2
    2184:	40 f4       	brcc	.+16     	; 0x2196 <xTaskIncrementTick+0x15a>
    2186:	09 c0       	rjmp	.+18     	; 0x219a <xTaskIncrementTick+0x15e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2188:	80 91 81 07 	lds	r24, 0x0781
    218c:	8f 5f       	subi	r24, 0xFF	; 255
    218e:	80 93 81 07 	sts	0x0781, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2192:	d1 2c       	mov	r13, r1
    2194:	02 c0       	rjmp	.+4      	; 0x219a <xTaskIncrementTick+0x15e>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    2196:	dd 24       	eor	r13, r13
    2198:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    219a:	80 91 80 07 	lds	r24, 0x0780
    219e:	88 23       	and	r24, r24
    21a0:	11 f0       	breq	.+4      	; 0x21a6 <xTaskIncrementTick+0x16a>
		{
			xSwitchRequired = pdTRUE;
    21a2:	dd 24       	eor	r13, r13
    21a4:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    21a6:	8d 2d       	mov	r24, r13
    21a8:	df 91       	pop	r29
    21aa:	cf 91       	pop	r28
    21ac:	1f 91       	pop	r17
    21ae:	0f 91       	pop	r16
    21b0:	ff 90       	pop	r15
    21b2:	ef 90       	pop	r14
    21b4:	df 90       	pop	r13
    21b6:	cf 90       	pop	r12
    21b8:	08 95       	ret

000021ba <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    21ba:	df 92       	push	r13
    21bc:	ef 92       	push	r14
    21be:	ff 92       	push	r15
    21c0:	0f 93       	push	r16
    21c2:	1f 93       	push	r17
    21c4:	cf 93       	push	r28
    21c6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	f8 94       	cli
    21cc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    21ce:	80 91 7b 07 	lds	r24, 0x077B
    21d2:	81 50       	subi	r24, 0x01	; 1
    21d4:	80 93 7b 07 	sts	0x077B, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    21d8:	80 91 7b 07 	lds	r24, 0x077B
    21dc:	81 11       	cpse	r24, r1
    21de:	61 c0       	rjmp	.+194    	; 0x22a2 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    21e0:	80 91 86 07 	lds	r24, 0x0786
    21e4:	88 23       	and	r24, r24
    21e6:	09 f4       	brne	.+2      	; 0x21ea <xTaskResumeAll+0x30>
    21e8:	5e c0       	rjmp	.+188    	; 0x22a6 <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    21ea:	0f 2e       	mov	r0, r31
    21ec:	f0 e9       	ldi	r31, 0x90	; 144
    21ee:	ef 2e       	mov	r14, r31
    21f0:	f7 e0       	ldi	r31, 0x07	; 7
    21f2:	ff 2e       	mov	r15, r31
    21f4:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    21f6:	dd 24       	eor	r13, r13
    21f8:	d3 94       	inc	r13
    21fa:	30 c0       	rjmp	.+96     	; 0x225c <xTaskResumeAll+0xa2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    21fc:	e0 91 95 07 	lds	r30, 0x0795
    2200:	f0 91 96 07 	lds	r31, 0x0796
    2204:	c6 81       	ldd	r28, Z+6	; 0x06
    2206:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2208:	ce 01       	movw	r24, r28
    220a:	0c 96       	adiw	r24, 0x0c	; 12
    220c:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2210:	8e 01       	movw	r16, r28
    2212:	0e 5f       	subi	r16, 0xFE	; 254
    2214:	1f 4f       	sbci	r17, 0xFF	; 255
    2216:	c8 01       	movw	r24, r16
    2218:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    221c:	8e 89       	ldd	r24, Y+22	; 0x16
    221e:	90 91 83 07 	lds	r25, 0x0783
    2222:	98 17       	cp	r25, r24
    2224:	10 f4       	brcc	.+4      	; 0x222a <xTaskResumeAll+0x70>
    2226:	80 93 83 07 	sts	0x0783, r24
    222a:	90 e0       	ldi	r25, 0x00	; 0
    222c:	9c 01       	movw	r18, r24
    222e:	22 0f       	add	r18, r18
    2230:	33 1f       	adc	r19, r19
    2232:	22 0f       	add	r18, r18
    2234:	33 1f       	adc	r19, r19
    2236:	22 0f       	add	r18, r18
    2238:	33 1f       	adc	r19, r19
    223a:	82 0f       	add	r24, r18
    223c:	93 1f       	adc	r25, r19
    223e:	b8 01       	movw	r22, r16
    2240:	81 55       	subi	r24, 0x51	; 81
    2242:	98 4f       	sbci	r25, 0xF8	; 248
    2244:	0e 94 a0 09 	call	0x1340	; 0x1340 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2248:	e0 91 d3 07 	lds	r30, 0x07D3
    224c:	f0 91 d4 07 	lds	r31, 0x07D4
    2250:	9e 89       	ldd	r25, Y+22	; 0x16
    2252:	86 89       	ldd	r24, Z+22	; 0x16
    2254:	98 17       	cp	r25, r24
    2256:	10 f0       	brcs	.+4      	; 0x225c <xTaskResumeAll+0xa2>
					{
						xYieldPending = pdTRUE;
    2258:	d0 92 80 07 	sts	0x0780, r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    225c:	f7 01       	movw	r30, r14
    225e:	80 81       	ld	r24, Z
    2260:	81 11       	cpse	r24, r1
    2262:	cc cf       	rjmp	.-104    	; 0x21fc <xTaskResumeAll+0x42>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    2264:	80 91 81 07 	lds	r24, 0x0781
    2268:	88 23       	and	r24, r24
    226a:	99 f0       	breq	.+38     	; 0x2292 <xTaskResumeAll+0xd8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    226c:	80 91 81 07 	lds	r24, 0x0781
    2270:	88 23       	and	r24, r24
    2272:	79 f0       	breq	.+30     	; 0x2292 <xTaskResumeAll+0xd8>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    2274:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    2276:	0e 94 1e 10 	call	0x203c	; 0x203c <xTaskIncrementTick>
    227a:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
    227c:	c0 93 80 07 	sts	0x0780, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    2280:	80 91 81 07 	lds	r24, 0x0781
    2284:	81 50       	subi	r24, 0x01	; 1
    2286:	80 93 81 07 	sts	0x0781, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    228a:	80 91 81 07 	lds	r24, 0x0781
    228e:	81 11       	cpse	r24, r1
    2290:	f2 cf       	rjmp	.-28     	; 0x2276 <xTaskResumeAll+0xbc>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    2292:	80 91 80 07 	lds	r24, 0x0780
    2296:	81 30       	cpi	r24, 0x01	; 1
    2298:	41 f4       	brne	.+16     	; 0x22aa <xTaskResumeAll+0xf0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    229a:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    229e:	81 e0       	ldi	r24, 0x01	; 1
    22a0:	05 c0       	rjmp	.+10     	; 0x22ac <xTaskResumeAll+0xf2>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    22a2:	80 e0       	ldi	r24, 0x00	; 0
    22a4:	03 c0       	rjmp	.+6      	; 0x22ac <xTaskResumeAll+0xf2>
    22a6:	80 e0       	ldi	r24, 0x00	; 0
    22a8:	01 c0       	rjmp	.+2      	; 0x22ac <xTaskResumeAll+0xf2>
    22aa:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    22ac:	0f 90       	pop	r0
    22ae:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    22b0:	df 91       	pop	r29
    22b2:	cf 91       	pop	r28
    22b4:	1f 91       	pop	r17
    22b6:	0f 91       	pop	r16
    22b8:	ff 90       	pop	r15
    22ba:	ef 90       	pop	r14
    22bc:	df 90       	pop	r13
    22be:	08 95       	ret

000022c0 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    22c0:	0f 93       	push	r16
    22c2:	1f 93       	push	r17
    22c4:	cf 93       	push	r28
    22c6:	df 93       	push	r29
    22c8:	8c 01       	movw	r16, r24
    22ca:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    22cc:	0e 94 0e 10 	call	0x201c	; 0x201c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    22d0:	80 91 84 07 	lds	r24, 0x0784
    22d4:	90 91 85 07 	lds	r25, 0x0785

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    22d8:	f8 01       	movw	r30, r16
    22da:	20 81       	ld	r18, Z
    22dc:	31 81       	ldd	r19, Z+1	; 0x01
    22de:	c2 0f       	add	r28, r18
    22e0:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    22e2:	82 17       	cp	r24, r18
    22e4:	93 07       	cpc	r25, r19
    22e6:	48 f4       	brcc	.+18     	; 0x22fa <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    22e8:	c2 17       	cp	r28, r18
    22ea:	d3 07       	cpc	r29, r19
    22ec:	10 f5       	brcc	.+68     	; 0x2332 <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22ee:	d1 83       	std	Z+1, r29	; 0x01
    22f0:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    22f2:	8c 17       	cp	r24, r28
    22f4:	9d 07       	cpc	r25, r29
    22f6:	90 f4       	brcc	.+36     	; 0x231c <vTaskDelayUntil+0x5c>
    22f8:	07 c0       	rjmp	.+14     	; 0x2308 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    22fa:	c2 17       	cp	r28, r18
    22fc:	d3 07       	cpc	r29, r19
    22fe:	a8 f0       	brcs	.+42     	; 0x232a <vTaskDelayUntil+0x6a>
    2300:	8c 17       	cp	r24, r28
    2302:	9d 07       	cpc	r25, r29
    2304:	90 f0       	brcs	.+36     	; 0x232a <vTaskDelayUntil+0x6a>
    2306:	15 c0       	rjmp	.+42     	; 0x2332 <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2308:	80 91 d3 07 	lds	r24, 0x07D3
    230c:	90 91 d4 07 	lds	r25, 0x07D4
    2310:	02 96       	adiw	r24, 0x02	; 2
    2312:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2316:	ce 01       	movw	r24, r28
    2318:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    231c:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2320:	81 11       	cpse	r24, r1
    2322:	0b c0       	rjmp	.+22     	; 0x233a <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
    2324:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
    2328:	08 c0       	rjmp	.+16     	; 0x233a <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    232a:	f8 01       	movw	r30, r16
    232c:	d1 83       	std	Z+1, r29	; 0x01
    232e:	c0 83       	st	Z, r28
    2330:	eb cf       	rjmp	.-42     	; 0x2308 <vTaskDelayUntil+0x48>
    2332:	f8 01       	movw	r30, r16
    2334:	d1 83       	std	Z+1, r29	; 0x01
    2336:	c0 83       	st	Z, r28
    2338:	f1 cf       	rjmp	.-30     	; 0x231c <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    233a:	df 91       	pop	r29
    233c:	cf 91       	pop	r28
    233e:	1f 91       	pop	r17
    2340:	0f 91       	pop	r16
    2342:	08 95       	ret

00002344 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2344:	cf 93       	push	r28
    2346:	df 93       	push	r29
    2348:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    234a:	00 97       	sbiw	r24, 0x00	; 0
    234c:	b1 f0       	breq	.+44     	; 0x237a <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    234e:	0e 94 0e 10 	call	0x201c	; 0x201c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2352:	80 91 84 07 	lds	r24, 0x0784
    2356:	90 91 85 07 	lds	r25, 0x0785
    235a:	c8 0f       	add	r28, r24
    235c:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    235e:	80 91 d3 07 	lds	r24, 0x07D3
    2362:	90 91 d4 07 	lds	r25, 0x07D4
    2366:	02 96       	adiw	r24, 0x02	; 2
    2368:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    236c:	ce 01       	movw	r24, r28
    236e:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2372:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2376:	81 11       	cpse	r24, r1
    2378:	02 c0       	rjmp	.+4      	; 0x237e <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    237a:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    237e:	df 91       	pop	r29
    2380:	cf 91       	pop	r28
    2382:	08 95       	ret

00002384 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2384:	80 91 7b 07 	lds	r24, 0x077B
    2388:	88 23       	and	r24, r24
    238a:	21 f0       	breq	.+8      	; 0x2394 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    238c:	81 e0       	ldi	r24, 0x01	; 1
    238e:	80 93 80 07 	sts	0x0780, r24
    2392:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    2394:	10 92 80 07 	sts	0x0780, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2398:	80 91 83 07 	lds	r24, 0x0783
    239c:	90 e0       	ldi	r25, 0x00	; 0
    239e:	fc 01       	movw	r30, r24
    23a0:	ee 0f       	add	r30, r30
    23a2:	ff 1f       	adc	r31, r31
    23a4:	ee 0f       	add	r30, r30
    23a6:	ff 1f       	adc	r31, r31
    23a8:	ee 0f       	add	r30, r30
    23aa:	ff 1f       	adc	r31, r31
    23ac:	8e 0f       	add	r24, r30
    23ae:	9f 1f       	adc	r25, r31
    23b0:	fc 01       	movw	r30, r24
    23b2:	e1 55       	subi	r30, 0x51	; 81
    23b4:	f8 4f       	sbci	r31, 0xF8	; 248
    23b6:	80 81       	ld	r24, Z
    23b8:	81 11       	cpse	r24, r1
    23ba:	17 c0       	rjmp	.+46     	; 0x23ea <vTaskSwitchContext+0x66>
    23bc:	80 91 83 07 	lds	r24, 0x0783
    23c0:	81 50       	subi	r24, 0x01	; 1
    23c2:	80 93 83 07 	sts	0x0783, r24
    23c6:	80 91 83 07 	lds	r24, 0x0783
    23ca:	90 e0       	ldi	r25, 0x00	; 0
    23cc:	fc 01       	movw	r30, r24
    23ce:	ee 0f       	add	r30, r30
    23d0:	ff 1f       	adc	r31, r31
    23d2:	ee 0f       	add	r30, r30
    23d4:	ff 1f       	adc	r31, r31
    23d6:	ee 0f       	add	r30, r30
    23d8:	ff 1f       	adc	r31, r31
    23da:	8e 0f       	add	r24, r30
    23dc:	9f 1f       	adc	r25, r31
    23de:	fc 01       	movw	r30, r24
    23e0:	e1 55       	subi	r30, 0x51	; 81
    23e2:	f8 4f       	sbci	r31, 0xF8	; 248
    23e4:	80 81       	ld	r24, Z
    23e6:	88 23       	and	r24, r24
    23e8:	49 f3       	breq	.-46     	; 0x23bc <vTaskSwitchContext+0x38>
    23ea:	e0 91 83 07 	lds	r30, 0x0783
    23ee:	f0 e0       	ldi	r31, 0x00	; 0
    23f0:	cf 01       	movw	r24, r30
    23f2:	88 0f       	add	r24, r24
    23f4:	99 1f       	adc	r25, r25
    23f6:	88 0f       	add	r24, r24
    23f8:	99 1f       	adc	r25, r25
    23fa:	88 0f       	add	r24, r24
    23fc:	99 1f       	adc	r25, r25
    23fe:	e8 0f       	add	r30, r24
    2400:	f9 1f       	adc	r31, r25
    2402:	e1 55       	subi	r30, 0x51	; 81
    2404:	f8 4f       	sbci	r31, 0xF8	; 248
    2406:	a1 81       	ldd	r26, Z+1	; 0x01
    2408:	b2 81       	ldd	r27, Z+2	; 0x02
    240a:	12 96       	adiw	r26, 0x02	; 2
    240c:	0d 90       	ld	r0, X+
    240e:	bc 91       	ld	r27, X
    2410:	a0 2d       	mov	r26, r0
    2412:	b2 83       	std	Z+2, r27	; 0x02
    2414:	a1 83       	std	Z+1, r26	; 0x01
    2416:	cf 01       	movw	r24, r30
    2418:	03 96       	adiw	r24, 0x03	; 3
    241a:	a8 17       	cp	r26, r24
    241c:	b9 07       	cpc	r27, r25
    241e:	31 f4       	brne	.+12     	; 0x242c <vTaskSwitchContext+0xa8>
    2420:	12 96       	adiw	r26, 0x02	; 2
    2422:	8d 91       	ld	r24, X+
    2424:	9c 91       	ld	r25, X
    2426:	13 97       	sbiw	r26, 0x03	; 3
    2428:	92 83       	std	Z+2, r25	; 0x02
    242a:	81 83       	std	Z+1, r24	; 0x01
    242c:	01 80       	ldd	r0, Z+1	; 0x01
    242e:	f2 81       	ldd	r31, Z+2	; 0x02
    2430:	e0 2d       	mov	r30, r0
    2432:	86 81       	ldd	r24, Z+6	; 0x06
    2434:	97 81       	ldd	r25, Z+7	; 0x07
    2436:	90 93 d4 07 	sts	0x07D4, r25
    243a:	80 93 d3 07 	sts	0x07D3, r24
    243e:	08 95       	ret

00002440 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    2440:	0f 93       	push	r16
    2442:	1f 93       	push	r17
    2444:	cf 93       	push	r28
    2446:	df 93       	push	r29
    2448:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    244a:	0f b6       	in	r0, 0x3f	; 63
    244c:	f8 94       	cli
    244e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    2450:	00 97       	sbiw	r24, 0x00	; 0
    2452:	21 f4       	brne	.+8      	; 0x245c <vTaskSuspend+0x1c>
    2454:	c0 91 d3 07 	lds	r28, 0x07D3
    2458:	d0 91 d4 07 	lds	r29, 0x07D4

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    245c:	8e 01       	movw	r16, r28
    245e:	0e 5f       	subi	r16, 0xFE	; 254
    2460:	1f 4f       	sbci	r17, 0xFF	; 255
    2462:	c8 01       	movw	r24, r16
    2464:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2468:	8c 89       	ldd	r24, Y+20	; 0x14
    246a:	9d 89       	ldd	r25, Y+21	; 0x15
    246c:	89 2b       	or	r24, r25
    246e:	21 f0       	breq	.+8      	; 0x2478 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2470:	ce 01       	movw	r24, r28
    2472:	0c 96       	adiw	r24, 0x0c	; 12
    2474:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    2478:	b8 01       	movw	r22, r16
    247a:	87 e8       	ldi	r24, 0x87	; 135
    247c:	97 e0       	ldi	r25, 0x07	; 7
    247e:	0e 94 a0 09 	call	0x1340	; 0x1340 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    2482:	0f 90       	pop	r0
    2484:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    2486:	80 91 d3 07 	lds	r24, 0x07D3
    248a:	90 91 d4 07 	lds	r25, 0x07D4
    248e:	c8 17       	cp	r28, r24
    2490:	d9 07       	cpc	r29, r25
    2492:	a9 f4       	brne	.+42     	; 0x24be <vTaskSuspend+0x7e>
		{
			if( xSchedulerRunning != pdFALSE )
    2494:	80 91 82 07 	lds	r24, 0x0782
    2498:	88 23       	and	r24, r24
    249a:	19 f0       	breq	.+6      	; 0x24a2 <vTaskSuspend+0x62>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    249c:	0e 94 be 0a 	call	0x157c	; 0x157c <vPortYield>
    24a0:	19 c0       	rjmp	.+50     	; 0x24d4 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    24a2:	80 91 86 07 	lds	r24, 0x0786
    24a6:	90 91 87 07 	lds	r25, 0x0787
    24aa:	98 13       	cpse	r25, r24
    24ac:	05 c0       	rjmp	.+10     	; 0x24b8 <vTaskSuspend+0x78>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    24ae:	10 92 d4 07 	sts	0x07D4, r1
    24b2:	10 92 d3 07 	sts	0x07D3, r1
    24b6:	0e c0       	rjmp	.+28     	; 0x24d4 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    24b8:	0e 94 c2 11 	call	0x2384	; 0x2384 <vTaskSwitchContext>
    24bc:	0b c0       	rjmp	.+22     	; 0x24d4 <vTaskSuspend+0x94>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    24be:	80 91 82 07 	lds	r24, 0x0782
    24c2:	88 23       	and	r24, r24
    24c4:	39 f0       	breq	.+14     	; 0x24d4 <vTaskSuspend+0x94>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    24c6:	0f b6       	in	r0, 0x3f	; 63
    24c8:	f8 94       	cli
    24ca:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    24cc:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    24d0:	0f 90       	pop	r0
    24d2:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    24d4:	df 91       	pop	r29
    24d6:	cf 91       	pop	r28
    24d8:	1f 91       	pop	r17
    24da:	0f 91       	pop	r16
    24dc:	08 95       	ret

000024de <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    24de:	cf 93       	push	r28
    24e0:	df 93       	push	r29
    24e2:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    24e4:	60 91 d3 07 	lds	r22, 0x07D3
    24e8:	70 91 d4 07 	lds	r23, 0x07D4
    24ec:	64 5f       	subi	r22, 0xF4	; 244
    24ee:	7f 4f       	sbci	r23, 0xFF	; 255
    24f0:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    24f4:	80 91 d3 07 	lds	r24, 0x07D3
    24f8:	90 91 d4 07 	lds	r25, 0x07D4
    24fc:	02 96       	adiw	r24, 0x02	; 2
    24fe:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    2502:	cf 3f       	cpi	r28, 0xFF	; 255
    2504:	8f ef       	ldi	r24, 0xFF	; 255
    2506:	d8 07       	cpc	r29, r24
    2508:	59 f4       	brne	.+22     	; 0x2520 <vTaskPlaceOnEventList+0x42>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    250a:	60 91 d3 07 	lds	r22, 0x07D3
    250e:	70 91 d4 07 	lds	r23, 0x07D4
    2512:	6e 5f       	subi	r22, 0xFE	; 254
    2514:	7f 4f       	sbci	r23, 0xFF	; 255
    2516:	87 e8       	ldi	r24, 0x87	; 135
    2518:	97 e0       	ldi	r25, 0x07	; 7
    251a:	0e 94 a0 09 	call	0x1340	; 0x1340 <vListInsertEnd>
    251e:	08 c0       	rjmp	.+16     	; 0x2530 <vTaskPlaceOnEventList+0x52>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    2520:	80 91 84 07 	lds	r24, 0x0784
    2524:	90 91 85 07 	lds	r25, 0x0785
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2528:	8c 0f       	add	r24, r28
    252a:	9d 1f       	adc	r25, r29
    252c:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2530:	df 91       	pop	r29
    2532:	cf 91       	pop	r28
    2534:	08 95       	ret

00002536 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2536:	0f 93       	push	r16
    2538:	1f 93       	push	r17
    253a:	cf 93       	push	r28
    253c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    253e:	dc 01       	movw	r26, r24
    2540:	15 96       	adiw	r26, 0x05	; 5
    2542:	ed 91       	ld	r30, X+
    2544:	fc 91       	ld	r31, X
    2546:	16 97       	sbiw	r26, 0x06	; 6
    2548:	c6 81       	ldd	r28, Z+6	; 0x06
    254a:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    254c:	8e 01       	movw	r16, r28
    254e:	04 5f       	subi	r16, 0xF4	; 244
    2550:	1f 4f       	sbci	r17, 0xFF	; 255
    2552:	c8 01       	movw	r24, r16
    2554:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2558:	80 91 7b 07 	lds	r24, 0x077B
    255c:	81 11       	cpse	r24, r1
    255e:	1c c0       	rjmp	.+56     	; 0x2598 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2560:	0a 50       	subi	r16, 0x0A	; 10
    2562:	11 09       	sbc	r17, r1
    2564:	c8 01       	movw	r24, r16
    2566:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    256a:	8e 89       	ldd	r24, Y+22	; 0x16
    256c:	90 91 83 07 	lds	r25, 0x0783
    2570:	98 17       	cp	r25, r24
    2572:	10 f4       	brcc	.+4      	; 0x2578 <xTaskRemoveFromEventList+0x42>
    2574:	80 93 83 07 	sts	0x0783, r24
    2578:	90 e0       	ldi	r25, 0x00	; 0
    257a:	9c 01       	movw	r18, r24
    257c:	22 0f       	add	r18, r18
    257e:	33 1f       	adc	r19, r19
    2580:	22 0f       	add	r18, r18
    2582:	33 1f       	adc	r19, r19
    2584:	22 0f       	add	r18, r18
    2586:	33 1f       	adc	r19, r19
    2588:	82 0f       	add	r24, r18
    258a:	93 1f       	adc	r25, r19
    258c:	b8 01       	movw	r22, r16
    258e:	81 55       	subi	r24, 0x51	; 81
    2590:	98 4f       	sbci	r25, 0xF8	; 248
    2592:	0e 94 a0 09 	call	0x1340	; 0x1340 <vListInsertEnd>
    2596:	05 c0       	rjmp	.+10     	; 0x25a2 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2598:	b8 01       	movw	r22, r16
    259a:	80 e9       	ldi	r24, 0x90	; 144
    259c:	97 e0       	ldi	r25, 0x07	; 7
    259e:	0e 94 a0 09 	call	0x1340	; 0x1340 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    25a2:	e0 91 d3 07 	lds	r30, 0x07D3
    25a6:	f0 91 d4 07 	lds	r31, 0x07D4
    25aa:	9e 89       	ldd	r25, Y+22	; 0x16
    25ac:	86 89       	ldd	r24, Z+22	; 0x16
    25ae:	89 17       	cp	r24, r25
    25b0:	20 f4       	brcc	.+8      	; 0x25ba <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    25b2:	81 e0       	ldi	r24, 0x01	; 1
    25b4:	80 93 80 07 	sts	0x0780, r24
    25b8:	01 c0       	rjmp	.+2      	; 0x25bc <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    25ba:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    25bc:	df 91       	pop	r29
    25be:	cf 91       	pop	r28
    25c0:	1f 91       	pop	r17
    25c2:	0f 91       	pop	r16
    25c4:	08 95       	ret

000025c6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    25c6:	20 91 7f 07 	lds	r18, 0x077F
    25ca:	fc 01       	movw	r30, r24
    25cc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    25ce:	20 91 84 07 	lds	r18, 0x0784
    25d2:	30 91 85 07 	lds	r19, 0x0785
    25d6:	32 83       	std	Z+2, r19	; 0x02
    25d8:	21 83       	std	Z+1, r18	; 0x01
    25da:	08 95       	ret

000025dc <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    25dc:	0f b6       	in	r0, 0x3f	; 63
    25de:	f8 94       	cli
    25e0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    25e2:	40 91 84 07 	lds	r20, 0x0784
    25e6:	50 91 85 07 	lds	r21, 0x0785

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    25ea:	db 01       	movw	r26, r22
    25ec:	2d 91       	ld	r18, X+
    25ee:	3c 91       	ld	r19, X
    25f0:	2f 3f       	cpi	r18, 0xFF	; 255
    25f2:	bf ef       	ldi	r27, 0xFF	; 255
    25f4:	3b 07       	cpc	r19, r27
    25f6:	19 f1       	breq	.+70     	; 0x263e <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    25f8:	e0 91 7f 07 	lds	r30, 0x077F
    25fc:	dc 01       	movw	r26, r24
    25fe:	fc 91       	ld	r31, X
    2600:	fe 17       	cp	r31, r30
    2602:	39 f0       	breq	.+14     	; 0x2612 <xTaskCheckForTimeOut+0x36>
    2604:	11 96       	adiw	r26, 0x01	; 1
    2606:	ed 91       	ld	r30, X+
    2608:	fc 91       	ld	r31, X
    260a:	12 97       	sbiw	r26, 0x02	; 2
    260c:	4e 17       	cp	r20, r30
    260e:	5f 07       	cpc	r21, r31
    2610:	c0 f4       	brcc	.+48     	; 0x2642 <xTaskCheckForTimeOut+0x66>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2612:	dc 01       	movw	r26, r24
    2614:	11 96       	adiw	r26, 0x01	; 1
    2616:	ed 91       	ld	r30, X+
    2618:	fc 91       	ld	r31, X
    261a:	12 97       	sbiw	r26, 0x02	; 2
    261c:	da 01       	movw	r26, r20
    261e:	ae 1b       	sub	r26, r30
    2620:	bf 0b       	sbc	r27, r31
    2622:	a2 17       	cp	r26, r18
    2624:	b3 07       	cpc	r27, r19
    2626:	78 f4       	brcc	.+30     	; 0x2646 <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2628:	e4 1b       	sub	r30, r20
    262a:	f5 0b       	sbc	r31, r21
    262c:	2e 0f       	add	r18, r30
    262e:	3f 1f       	adc	r19, r31
    2630:	fb 01       	movw	r30, r22
    2632:	31 83       	std	Z+1, r19	; 0x01
    2634:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    2636:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    263a:	80 e0       	ldi	r24, 0x00	; 0
    263c:	05 c0       	rjmp	.+10     	; 0x2648 <xTaskCheckForTimeOut+0x6c>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    263e:	80 e0       	ldi	r24, 0x00	; 0
    2640:	03 c0       	rjmp	.+6      	; 0x2648 <xTaskCheckForTimeOut+0x6c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2642:	81 e0       	ldi	r24, 0x01	; 1
    2644:	01 c0       	rjmp	.+2      	; 0x2648 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2646:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2648:	0f 90       	pop	r0
    264a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    264c:	08 95       	ret

0000264e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    264e:	81 e0       	ldi	r24, 0x01	; 1
    2650:	80 93 80 07 	sts	0x0780, r24
    2654:	08 95       	ret

00002656 <__tablejump2__>:
    2656:	ee 0f       	add	r30, r30
    2658:	ff 1f       	adc	r31, r31

0000265a <__tablejump__>:
    265a:	05 90       	lpm	r0, Z+
    265c:	f4 91       	lpm	r31, Z
    265e:	e0 2d       	mov	r30, r0
    2660:	09 94       	ijmp

00002662 <memcpy>:
    2662:	fb 01       	movw	r30, r22
    2664:	dc 01       	movw	r26, r24
    2666:	02 c0       	rjmp	.+4      	; 0x266c <memcpy+0xa>
    2668:	01 90       	ld	r0, Z+
    266a:	0d 92       	st	X+, r0
    266c:	41 50       	subi	r20, 0x01	; 1
    266e:	50 40       	sbci	r21, 0x00	; 0
    2670:	d8 f7       	brcc	.-10     	; 0x2668 <memcpy+0x6>
    2672:	08 95       	ret

00002674 <_exit>:
    2674:	f8 94       	cli

00002676 <__stop_program>:
    2676:	ff cf       	rjmp	.-2      	; 0x2676 <__stop_program>
